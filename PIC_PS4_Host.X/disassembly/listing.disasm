Disassembly Listing for PIC_PS4_Host
Generated From:
D:/PIC/PIC_PS4_Host/trunk/PIC_PS4_Host.X/dist/default/production/PIC_PS4_Host.X.production.elf
Apr 24, 2016 7:45:17 PM

---  D:/PIC/PIC_PS4_Host/trunk/outputs.c  ---------------------------------------------------------------
1:                 /***********************************************************************
2:                     PS4 USB Host
3:                     Copyright (C) 2013 Cross Product Creations
4:                 
5:                     This program is free software: you can redistribute it and/or modify
6:                     it under the terms of the GNU General Public License as published by
7:                     the Free Software Foundation, either version 3 of the License, or
8:                     (at your option) any later version.
9:                 
10:                    This program is distributed in the hope that it will be useful,
11:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                    GNU General Public License for more details.
14:                
15:                    You should have received a copy of the GNU General Public License
16:                    along with this program.  If not, see <http://www.gnu.org/licenses/>.
17:                 *************************************************************************/
18:                
19:                #include "outputs.h"
20:                #include "main.h"
21:                #include "HardwareProfile.h"
22:                #include "uart2.h"
23:                #include "DEE Emulation 16-bit/DEE Emulation 16-bit.h"
24:                #include "PS4_controller.h"
25:                #include "PS4_SPI.h"
26:                #include <stdlib.h>
27:                
28:                /********************************************
29:                 * Index: Input
30:                 * //////////////SERVOS///////////////
31:                    0:L-Stick X-axis
32:                    1:L-Stick Y-axis
33:                    2:R-Stick X-axis
34:                    3:R-Stick Y-axis
35:                    4:L-Trig analog
36:                    5:R-Trig analog
37:                    6:TouchPad1(Left side when split)-X
38:                    7:TouchPad1(Left side when split)-Y
39:                    8:TouchPad2(Right side when split)-X
40:                    9:TouchPad2(Right side when split)-Y
41:                    10:X-Accelerometer
42:                    11:Z-Accelerometer
43:                 * //buttons
44:                    12:D-Pad Up
45:                    13:D-Pad Right
46:                    14:D-Pad Down
47:                    15:D-Pad Left
48:                    16:Triangle button
49:                    17:Circle button
50:                    18:Cross button
51:                    19:Square button
52:                    20:L-Bumper
53:                    21:R-Bumper
54:                    22:L-Trig button
55:                    23:R-Trig button
56:                    24:L-Stick button
57:                    25:R-Stick button
58:                    26:Share button
59:                    27:Options button
60:                    28:Touchpad click
61:                    29:PS button
62:                 **********************************************/
63:                
64:                
65:                ///////////////////////PWM REGISTERS//////////////////
66:                static unsigned int oc10r, oc10rs, oc10con1, oc11r, oc11rs, oc11con1, oc12r, oc12rs, oc12con1;
67:                static volatile unsigned int* const OCxR_REG_PTRS[12] = {&OC1R, &OC2R, &OC3R, &OC4R, &OC5R, &OC6R, &OC7R, &OC8R, &OC9R, &oc10r, &oc11r, &oc12r};
68:                static volatile unsigned int* const OCxRS_REG_PTRS[12] = {&OC1RS, &OC2RS, &OC3RS, &OC4RS, &OC5RS, &OC6RS, &OC7RS, &OC8RS, &OC9RS, &oc10rs, &oc11rs, &oc12rs};
69:                static volatile unsigned int* const OCxCON1_REG_PTRS[12] = {&OC1CON1, &OC2CON1, &OC3CON1, &OC4CON1, &OC5CON1, &OC6CON1, &OC7CON1, &OC8CON1, &OC9CON1, &oc10con1, &oc11con1, &oc12con1};
70:                
71:                static SERVO_SETTINGS ServoSettings[NUM_SERVOS];
72:                static signed long int servoState[NUM_SERVOS] = {300000, 300000, 300000, 300000, 300000, 300000, 300000, 300000, 300000, 300000, 30000, 30000};
73:                
74:                ///////////////CONFIG SETTINGS/////////////////////////
75:                //see LoadDefaultSettings for default settings.
76:                static BUTTON_SETTINGS ButtonSettings[NUM_BUTTONS];
77:                static BOOL triggerLink;
78:                static BUTTONS buttonToggles;
79:                static unsigned int spiBusMode;
80:                static unsigned int disconnectToggleReset;
81:                static unsigned int idleTimeout;
82:                static BOOL lStickDiffMix;
83:                static BOOL rStickDiffMix;
84:                static unsigned int LEDBrightness;
85:                LED_COLORS LEDColorSetting;
86:                static unsigned int PPMOutput = 0;
87:                static unsigned int ButtonsFourBitCode[4];
88:                static unsigned int ButtonsPPM[4];
89:                
90:                static enum {
91:                    MECANUM_OFF = 0,
92:                    MECANUM_ON_NO_REMAP = 1,
93:                    MECANUM_REMAP_4 = 2,
94:                    MECANUM_REMAP_5 = 3,
95:                    MECANUM_REMAP_6 = 4,
96:                    MECANUM_REMAP_7 = 5,
97:                    MECANUM_REMAP_8 = 6,
98:                    MECANUM_REMAP_9 = 7,
99:                    MECANUM_REMAP_10 = 8,
100:                   MECANUM_REMAP_11 = 9,
101:                   MECANUM_REMAP_12 = 10,
102:               } mecanumSteering = MECANUM_OFF;
103:               
104:               
105:               //////////////PUBLIC FUNCTIONS///////////////////////////
106:               
107:               void InitOutputs(void) {
00490E  781F88     MOV W8, [W15++]
108:                   unsigned int i;
109:               
110:                   //Set initial Servo period, time base Timer 2
111:                   T2CON = 0; //clear state
004910  EB0000     CLR W0
004912  880880     MOV W0, T2CON
112:                   T2CONbits.TSIDL = 0; //Continue in Idle
004914  A9A111     BCLR 0x111, #5
113:                   T2CONbits.TGATE = 0; //No gate accumulation
004916  A9C110     BCLR T2CON, #6
114:                   T2CONbits.TCKPS = 0b01; //Prescale 1:8
004918  201101     MOV #0x110, W1
00491A  784091     MOV.B [W1], W1
00491C  B3CCF2     MOV.B #0xCF, W2
00491E  60C082     AND.B W1, W2, W1
004920  A04401     BSET.B W1, #4
004922  FD0080     EXCH W0, W1
004924  B7E110     MOV.B WREG, T2CON
004926  FD0080     EXCH W0, W1
115:                   T2CONbits.T32 = 0; //16-bit mode
004928  A96110     BCLR T2CON, #3
116:                   T2CONbits.TCS = 0; //Clock Source: Internal Clock (Fosc/2)
00492A  A92110     BCLR T2CON, #1
117:                   TMR2 = 0;
00492C  880830     MOV W0, TMR2
00492E  780080     MOV W0, W1
004930  284F47     MOV #0x84F4, W7
004932  200066     MOV #0x6, W6
004934  284DC5     MOV #0x84DC, W5
004936  200014     MOV #0x1, W4
004938  284C43     MOV #0x84C4, W3
00493A  20BB82     MOV #0xBB8, W2
118:               
119:                   //***
120:               
121:                   for (i = 0; i < NUM_SERVOS; i++) {
00494A  508FF8     SUB W1, #0x18, [W15]
00494C  3AFFF7     BRA NZ, 0x493C
122:                       *OCxCON1_REG_PTRS[i] = 0b110;
00493C  7B8061     MOV [W1+W7], W0
00493E  780806     MOV W6, [W0]
123:                       *OCxRS_REG_PTRS[i] = 1; //this is just to keep it rolling over so we can stagger the outputs below
004940  7A8061     MOV [W1+W5], W0
004942  780804     MOV W4, [W0]
124:                       *OCxR_REG_PTRS[i] = 3000;
004944  798061     MOV [W1+W3], W0
004946  780802     MOV W2, [W0]
004948  E88081     INC2 W1, W1
125:                   }
126:                   OC3RS = 10;
00494E  2000A0     MOV #0xA, W0
004950  880D40     MOV W0, OC3RS
127:                   OC1CON2 = 0x003F; //use own OCxRS register for sync
004952  2003F0     MOV #0x3F, W0
004954  880C90     MOV W0, OC1CON2
128:                   OC2CON2 = 0x003F; //use own OCxRS register for sync
004956  880CE0     MOV W0, OC2CON2
129:                   OC3CON2 = 0x003F; //use own OCxRS register for sync
004958  880D30     MOV W0, OC3CON2
130:                   OC4CON2 = 0x003F; //use own OCxRS register for sync
00495A  880D80     MOV W0, OC4CON2
131:                   OC5CON2 = 0x003F; //use own OCxRS register for sync
00495C  880DD0     MOV W0, OC5CON2
132:                   OC6CON2 = 0x003F; //use own OCxRS register for sync
00495E  880E20     MOV W0, OC6CON2
133:                   OC7CON2 = 0x003F; //use own OCxRS register for sync
004960  880E70     MOV W0, OC7CON2
134:                   OC8CON2 = 0x003F; //use own OCxRS register for sync
004962  880EC0     MOV W0, OC8CON2
135:                   OC9CON2 = 0x003F; //use own OCxRS register for sync
004964  880F10     MOV W0, OC9CON2
136:                   
137:                   T2CONbits.TON = 1; //Timer2 On
004966  A8E111     BSET 0x111, #7
138:                   
139:                   //stagger the pulses so that they don't all go high at the same time.
140:                   DelayMs(100); //I think we need to wait for TMR2 to roll over
004968  26A000     MOV #0x6A00, W0
00496A  200181     MOV #0x18, W1
00496C  07EB13     RCALL ___delay32
141:                   OC1RS = 40000;
00496E  29C408     MOV #0x9C40, W8
004970  880CA8     MOV W8, OC1RS
142:                   DelayMs(2);
004972  27D000     MOV #0x7D00, W0
004974  200001     MOV #0x0, W1
004976  07EB0E     RCALL ___delay32
143:                   OC2RS = 40000;
004978  880CF8     MOV W8, OC2RS
144:                   DelayMs(2);
00497A  27D000     MOV #0x7D00, W0
00497C  200001     MOV #0x0, W1
00497E  07EB0A     RCALL ___delay32
145:                   OC3RS = 40000;
004980  880D48     MOV W8, OC3RS
146:                   DelayMs(2);
004982  27D000     MOV #0x7D00, W0
004984  200001     MOV #0x0, W1
004986  07EB06     RCALL ___delay32
147:                   OC4RS = 40000;
004988  880D98     MOV W8, OC4RS
148:                   DelayMs(2);
00498A  27D000     MOV #0x7D00, W0
00498C  200001     MOV #0x0, W1
00498E  07EB02     RCALL ___delay32
149:                   OC5RS = 40000;
004990  880DE8     MOV W8, OC5RS
150:                   DelayMs(2);
004992  27D000     MOV #0x7D00, W0
004994  200001     MOV #0x0, W1
004996  07EAFE     RCALL ___delay32
151:                   OC6RS = 40000;
004998  880E38     MOV W8, OC6RS
152:                   DelayMs(2);
00499A  27D000     MOV #0x7D00, W0
00499C  200001     MOV #0x0, W1
00499E  07EAFA     RCALL ___delay32
153:                   OC7RS = 40000;
0049A0  880E88     MOV W8, OC7RS
154:                   DelayMs(2);
0049A2  27D000     MOV #0x7D00, W0
0049A4  200001     MOV #0x0, W1
0049A6  07EAF6     RCALL ___delay32
155:                   OC8RS = 40000;
0049A8  880ED8     MOV W8, OC8RS
156:                   DelayMs(2);
0049AA  27D000     MOV #0x7D00, W0
0049AC  200001     MOV #0x0, W1
0049AE  07EAF2     RCALL ___delay32
157:                   OC9RS = 40000;
0049B0  880F28     MOV W8, OC9RS
158:               
159:                   
160:                   //Stagger the servo signal turn-on sequence to reduce the inrush current
161:                   RPOR10bits.RP21R = 18; //Map PWM 1 Output to RP21
0049B2  BFC6D5     MOV.B 0x6D5, WREG
0049B4  B3CC08     MOV.B #0xC0, W8
0049B6  604008     AND.B W0, W8, W0
0049B8  B34120     IOR.B #0x12, W0
0049BA  B7E6D5     MOV.B WREG, 0x6D5
162:                   OC1CON2bits.OCTRIS = 0;
0049BC  A9A192     BCLR OC1CON2, #5
163:                   DelayMs(100);
0049BE  26A000     MOV #0x6A00, W0
0049C0  200181     MOV #0x18, W1
0049C2  07EAE8     RCALL ___delay32
164:                   RPOR13bits.RP26R = 19; //Map PWM 2 Output to RP26
0049C4  BFC6DA     MOV.B RPOR13, WREG
0049C6  604008     AND.B W0, W8, W0
0049C8  B34130     IOR.B #0x13, W0
0049CA  B7E6DA     MOV.B WREG, RPOR13
165:                   OC2CON2bits.OCTRIS = 0;
0049CC  A9A19C     BCLR OC2CON2, #5
166:                   DelayMs(100);
0049CE  26A000     MOV #0x6A00, W0
0049D0  200181     MOV #0x18, W1
0049D2  07EAE0     RCALL ___delay32
167:                   RPOR9bits.RP19R = 20; //Map PWM 3 Output to RP19
0049D4  BFC6D3     MOV.B 0x6D3, WREG
0049D6  604008     AND.B W0, W8, W0
0049D8  B34140     IOR.B #0x14, W0
0049DA  B7E6D3     MOV.B WREG, 0x6D3
168:                   OC3CON2bits.OCTRIS = 0;
0049DC  A9A1A6     BCLR OC3CON2, #5
169:                   DelayMs(100);
0049DE  26A000     MOV #0x6A00, W0
0049E0  200181     MOV #0x18, W1
0049E2  07EAD8     RCALL ___delay32
170:                   RPOR13bits.RP27R = 21; //Map PWM 4 Output to RP27
0049E4  BFC6DB     MOV.B 0x6DB, WREG
0049E6  604008     AND.B W0, W8, W0
0049E8  B34150     IOR.B #0x15, W0
0049EA  B7E6DB     MOV.B WREG, 0x6DB
171:                   OC4CON2bits.OCTRIS = 0;
0049EC  A9A1B0     BCLR OC4CON2, #5
172:                   DelayMs(100);
0049EE  26A000     MOV #0x6A00, W0
0049F0  200181     MOV #0x18, W1
0049F2  07EAD0     RCALL ___delay32
173:                   RPOR9bits.RP18R = 22; //Map PWM 5 Output to RP18
0049F4  BFC6D2     MOV.B RPOR9, WREG
0049F6  604008     AND.B W0, W8, W0
0049F8  B34160     IOR.B #0x16, W0
0049FA  B7E6D2     MOV.B WREG, RPOR9
174:                   OC5CON2bits.OCTRIS = 0;
0049FC  A9A1BA     BCLR OC5CON2, #5
175:                   DelayMs(100);
0049FE  26A000     MOV #0x6A00, W0
004A00  200181     MOV #0x18, W1
004A02  07EAC8     RCALL ___delay32
176:                   RPOR14bits.RP28R = 23; //Map PWM 6 Output to RP28
004A04  BFC6DC     MOV.B RPOR14, WREG
004A06  604008     AND.B W0, W8, W0
004A08  B34170     IOR.B #0x17, W0
004A0A  B7E6DC     MOV.B WREG, RPOR14
177:                   OC6CON2bits.OCTRIS = 0;
004A0C  A9A1C4     BCLR OC6CON2, #5
178:                   DelayMs(100);
004A0E  26A000     MOV #0x6A00, W0
004A10  200181     MOV #0x18, W1
004A12  07EAC0     RCALL ___delay32
179:                   RPOR6bits.RP13R = 24; //Map PWM 7 Output to RP13
004A14  BFC6CD     MOV.B 0x6CD, WREG
004A16  604008     AND.B W0, W8, W0
004A18  B34180     IOR.B #0x18, W0
004A1A  B7E6CD     MOV.B WREG, 0x6CD
180:                   OC7CON2bits.OCTRIS = 0;
004A1C  A9A1CE     BCLR OC7CON2, #5
181:                   DelayMs(100);
004A1E  26A000     MOV #0x6A00, W0
004A20  200181     MOV #0x18, W1
004A22  07EAB8     RCALL ___delay32
182:                   RPOR0bits.RP1R = 25; //Map PWM 8 Output to RP1
004A24  BFC6C1     MOV.B 0x6C1, WREG
004A26  604008     AND.B W0, W8, W0
004A28  B34190     IOR.B #0x19, W0
004A2A  B7E6C1     MOV.B WREG, 0x6C1
183:                   OC8CON2bits.OCTRIS = 0;
004A2C  A9A1D8     BCLR OC8CON2, #5
184:                   DelayMs(100);
004A2E  26A000     MOV #0x6A00, W0
004A30  200181     MOV #0x18, W1
004A32  07EAB0     RCALL ___delay32
185:                   RPOR0bits.RP0R = 35; //Map PWM 9 Output to RP0
004A34  BFC6C0     MOV.B RPOR0, WREG
004A36  604008     AND.B W0, W8, W0
004A38  B34230     IOR.B #0x23, W0
004A3A  B7E6C0     MOV.B WREG, RPOR0
186:                   OC9CON2bits.OCTRIS = 0;
004A3C  A9A1E2     BCLR OC9CON2, #5
187:               
188:                       /////////////Use Timer3 for PWM 10
189:                   T3CON = 0; //clear state
004A3E  EB0100     CLR W2
004A40  880892     MOV W2, T3CON
190:                   T3CONbits.TSIDL = 0; //Continue in Idle
004A42  A9A113     BCLR 0x113, #5
191:                   T3CONbits.TGATE = 0; //No gate accumulation
004A44  A9C112     BCLR T3CON, #6
192:                   T3CONbits.TCKPS = 0b01; //Prescale 1:8
004A46  BFC112     MOV.B T3CON, WREG
004A48  B3CCF1     MOV.B #0xCF, W1
004A4A  604001     AND.B W0, W1, W0
004A4C  A04400     BSET.B W0, #4
004A4E  B7E112     MOV.B WREG, T3CON
193:                   T3CONbits.TCS = 0; //Clock Source: Internal Clock (Fosc/2)
004A50  A92112     BCLR T3CON, #1
194:                   TMR3 = 0;
004A52  880852     MOV W2, TMR3
195:                   T3CONbits.TON = 1;
004A54  A8E113     BSET 0x113, #7
196:                   //enable timer4 interrupt
197:                   _T3IE = 1;
004A56  A80095     BSET 0x95, #0
198:                   _T3IP = 7; //high priority interrupt
004A58  B3C070     MOV.B #0x7, W0
004A5A  B760A8     IOR.B IPC2
199:                   //////////////////////////////////
200:               }
004A5C  78044F     MOV [--W15], W8
004A5E  060000     RETURN
201:               
202:               /*******************************************************************************
203:               Function: LoadDefaultSettings(BOOL loadAll, unsigned int index)
204:               
205:               Precondition:
206:                None
207:               
208:               Overview:
209:                load default settings
210:               
211:               Input:
212:                loadAll:load all the default settings
213:                index: load the default settings for the channel if loadAll is False.
214:               
215:               Output:
216:                None
217:               
218:                *******************************************************************************/
219:               void LoadDefaultSettings(BOOL loadAll, unsigned int index) {
004A60  BE9F88     MOV.D W8, [W15++]
004A62  780480     MOV W0, W9
004A64  780401     MOV W1, W8
220:                   unsigned int i = 0;
221:                   if (loadAll == FALSE) {
004A66  E00000     CP0 W0
004A68  3A0005     BRA NZ, 0x4A74
222:                       i = index;
223:                       UART2PrintString("Loading default settings for ");
004A6A  2850C0     MOV #0x850C, W0
004A6C  072608     RCALL UART2PrintString
224:                       PrintIndexLabel(i);
004A6E  780008     MOV W8, W0
004A70  070E0F     RCALL PrintIndexLabel
004A72  370012     BRA 0x4A98
225:                   }
226:                   else {
227:                       UART2PrintString("Loading all default settings...");
004A74  2852A0     MOV #0x852A, W0
004A76  072603     RCALL UART2PrintString
228:                       triggerLink = FALSE;
004A78  EB0080     CLR W1
004A7A  885661     MOV W1, triggerLink
229:                       spiBusMode = 0;
004A7C  885791     MOV W1, spiBusMode
230:                       disconnectToggleReset = 0;
004A7E  8857A1     MOV W1, disconnectToggleReset
231:                       idleTimeout = 60000;//
004A80  2EA600     MOV #0xEA60, W0
004A82  8857B0     MOV W0, idleTimeout
232:                       lStickDiffMix = FALSE;
004A84  8857C1     MOV W1, lStickDiffMix
233:                       rStickDiffMix = FALSE;
004A86  8857D1     MOV W1, rStickDiffMix
234:                       mecanumSteering = MECANUM_OFF;
004A88  884011     MOV W1, mecanumSteering
235:                       LEDBrightness = 1;
004A8A  200010     MOV #0x1, W0
004A8C  8857E0     MOV W0, LEDBrightness
236:                       LEDColorSetting = 12;
004A8E  2000C0     MOV #0xC, W0
004A90  885870     MOV W0, LEDColorSetting
237:                       PPMOutput = 0;
004A92  884001     MOV W1, PPMOutput
004A94  780401     MOV W1, W8
004A96  370002     BRA 0x4A9C
238:               
239:                   }
240:                   do {
241:                       if (i < NUM_SERVOS) { //servo settings
004A98  540FEB     SUB W8, #0xB, [W15]
004A9A  3E0028     BRA GTU, 0x4AEC
242:                           ServoSettings[i].offset = 0;
004A9C  B9407A     MUL.SU W8, #26, W0
004A9E  209041     MOV #0x904, W1
004AA0  EB0180     CLR W3
004AA2  78B003     MOV W3, [W0+W1]
243:                           ServoSettings[i].range = 125;
004AA4  E88200     INC2 W0, W4
004AA6  2007D2     MOV #0x7D, W2
004AA8  78B202     MOV W2, [W4+W1]
244:                           ServoSettings[i].deadband = 0;
004AAA  400164     ADD W0, #0x4, W2
004AAC  78B103     MOV W3, [W2+W1]
245:                           ServoSettings[i].sensitivity = 10;
004AAE  400266     ADD W0, #0x6, W4
004AB0  2000A2     MOV #0xA, W2
004AB2  78B202     MOV W2, [W4+W1]
246:                           ServoSettings[i].direction = FORWARD;
004AB4  400168     ADD W0, #0x8, W2
004AB6  78B103     MOV W3, [W2+W1]
247:                           ServoSettings[i].absOrRel = ABSOLUTE;
004AB8  40016A     ADD W0, #0xA, W2
004ABA  78B103     MOV W3, [W2+W1]
248:                           ServoSettings[i].filterStrength = 0;
004ABC  400170     ADD W0, #0x10, W2
004ABE  78B103     MOV W3, [W2+W1]
249:                           ServoSettings[i].touchpadMode = TPAD;
004AC0  40016C     ADD W0, #0xC, W2
004AC2  78B103     MOV W3, [W2+W1]
250:                           ServoSettings[i].touchpadSplit = SPLIT;
004AC4  40026E     ADD W0, #0xE, W4
004AC6  200012     MOV #0x1, W2
004AC8  78B202     MOV W2, [W4+W1]
251:                           ServoSettings[i].trim = 0;
004ACA  400172     ADD W0, #0x12, W2
004ACC  78B103     MOV W3, [W2+W1]
252:                           ServoSettings[i].zeroPosition = 0;
004ACE  400274     ADD W0, #0x14, W4
004AD0  78B203     MOV W3, [W4+W1]
253:                           ServoSettings[i].holdRecall = OFF;
004AD2  400176     ADD W0, #0x16, W2
004AD4  78B103     MOV W3, [W2+W1]
254:                           ServoSettings[i].servoRecallValue = 3000;
004AD6  400078     ADD W0, #0x18, W0
004AD8  20BB82     MOV #0xBB8, W2
004ADA  78B002     MOV W2, [W0+W1]
255:               
256:                           switch (i) //specific cases
004ADC  540FE3     SUB W8, #0x3, [W15]
004ADE  3E0002     BRA GTU, 0x4AE4
257:                           {
258:                               case L_STICK_X:
259:                               case L_STICK_Y:
260:                               case R_STICK_X:
261:                               case R_STICK_Y:
262:                                   ServoSettings[i].zeroPosition = 128;
004AE0  200800     MOV #0x80, W0
004AE2  78B200     MOV W0, [W4+W1]
263:                                   break;
264:                           }            
265:               
266:                           DataEEWrite(3000, EEPROM_SERVO_HOME + i);
004AE4  4400E4     ADD W8, #0x4, W1
004AE6  20BB80     MOV #0xBB8, W0
004AE8  072354     RCALL DataEEWrite
004AEA  37000D     BRA 0x4B06
267:                       }
268:                       else { //button settings
269:                           ButtonSettings[i - NUM_SERVOS].invert = FALSE;
004AEC  54006C     SUB W8, #0xC, W0
004AEE  DD0043     SL W0, #3, W0
004AF0  20A3C2     MOV #0xA3C, W2
004AF2  EB0180     CLR W3
004AF4  793003     MOV W3, [W0+W2]
270:                           ButtonSettings[i - NUM_SERVOS].outputMode = PUSHBUTTON;
004AF6  E88080     INC2 W0, W1
004AF8  793083     MOV W3, [W1+W2]
271:                           ButtonSettings[i - NUM_SERVOS].pulseWidth = 5;
004AFA  4001E4     ADD W0, #0x4, W3
004AFC  200051     MOV #0x5, W1
004AFE  793181     MOV W1, [W3+W2]
272:                           ButtonSettings[i - NUM_SERVOS].autofirePeriod = 20;
004B00  400066     ADD W0, #0x6, W0
004B02  200141     MOV #0x14, W1
004B04  793001     MOV W1, [W0+W2]
273:                       }
274:                       i++;
004B06  E80408     INC W8, W8
275:                   } while (i < (NUM_SERVOS + NUM_BUTTONS) && loadAll == TRUE);
004B08  540FFD     SUB W8, #0x1D, [W15]
004B0A  3E0002     BRA GTU, 0x4B10
004B0C  548FE1     SUB W9, #0x1, [W15]
004B0E  32FFC4     BRA Z, 0x4A98
276:                   UART2PrintString("Done\n\r");
004B10  2854A0     MOV #0x854A, W0
004B12  0725B5     RCALL UART2PrintString
277:               }
004B14  BE044F     MOV.D [--W15], W8
004B16  060000     RETURN
278:               
279:               /*******************************************************************************
280:               Function: SaveLoadSubroutine( BOOL save)
281:               
282:               Precondition:
283:                None
284:               
285:               Overview:
286:                 Save or load settings.
287:               
288:               Input:
289:                 if save==1, then save, if save==0, then load
290:               
291:               Output:
292:                None
293:               
294:                *******************************************************************************/
295:               
296:               void SaveLoadSubroutine(BOOL save_switch) {
004B18  BE9F88     MOV.D W8, [W15++]
004B1A  BE9F8A     MOV.D W10, [W15++]
004B1C  BE9F8C     MOV.D W12, [W15++]
004B1E  780600     MOV W0, W12
004B20  EB0580     CLR W11
004B22  20010D     MOV #0x10, W13
004B24  B9587A     MUL.SU W11, #26, W0
004B26  209042     MOV #0x904, W2
004B28  410400     ADD W2, W0, W8
004B2A  78048D     MOV W13, W9
004B2C  EB0500     CLR W10
297:                   unsigned int i = 0;
298:                   unsigned int j = 0;
299:                   unsigned int memory_index = EEPROM_CONFIG_SETTINGS_START;
300:               
301:                   //servo settings
302:                   for (i = 0; i < NUM_SERVOS; i++) {
004B4A  E8058B     INC W11, W11
004B4C  4686ED     ADD W13, #0xD, W13
004B4E  558FEC     SUB W11, #0xC, [W15]
004B50  3AFFE9     BRA NZ, 0x4B24
004B52  EB0680     CLR W13
004B54  DD68C3     SL W13, #3, W1
004B56  20A3C0     MOV #0xA3C, W0
004B58  408400     ADD W1, W0, W8
004B5A  780589     MOV W9, W11
004B5C  20004A     MOV #0x4, W10
303:                       for (j = 0; j < SERVO_SETTINGS_LENGTH; j++) {
004B42  E8050A     INC W10, W10
004B44  E88408     INC2 W8, W8
004B46  550FED     SUB W10, #0xD, [W15]
004B48  3AFFF2     BRA NZ, 0x4B2E
304:                           if (save_switch) DataEEWrite(ServoSettings[i].array[j], memory_index);
004B2E  E0000C     CP0 W12
004B30  320004     BRA Z, 0x4B3A
004B32  780089     MOV W9, W1
004B34  780018     MOV [W8], W0
004B36  07232D     RCALL DataEEWrite
004B38  370003     BRA 0x4B40
305:                           else ServoSettings[i].array[j] = DataEERead(memory_index);
004B3A  780009     MOV W9, W0
004B3C  0722DF     RCALL DataEERead
004B3E  780C00     MOV W0, [W8]
306:                           memory_index++;
004B40  E80489     INC W9, W9
307:                       }
308:                   }
309:               
310:                   //button settings
311:                   for (i = 0; i < NUM_BUTTONS; i++) {
004B7A  E8068D     INC W13, W13
004B7C  4484E4     ADD W9, #0x4, W9
004B7E  568FF2     SUB W13, #0x12, [W15]
004B80  3AFFE9     BRA NZ, 0x4B54
312:                       for (j = 0; j < 4; j++) {
004B76  E0000A     CP0 W10
004B78  3AFFF2     BRA NZ, 0x4B5E
313:                           if (save_switch) DataEEWrite(ButtonSettings[i].array[j], memory_index);
004B5E  E0000C     CP0 W12
004B60  320004     BRA Z, 0x4B6A
004B62  78008B     MOV W11, W1
004B64  780018     MOV [W8], W0
004B66  072315     RCALL DataEEWrite
004B68  370003     BRA 0x4B70
314:                           else ButtonSettings[i].array[j] = DataEERead(memory_index);
004B6A  78000B     MOV W11, W0
004B6C  0722C7     RCALL DataEERead
004B6E  780C00     MOV W0, [W8]
315:                           memory_index++;
004B70  E8058B     INC W11, W11
004B72  E9050A     DEC W10, W10
004B74  E88408     INC2 W8, W8
316:                       }
317:                   }
318:               
319:                   //universal settings
320:                   if (save_switch) DataEEWrite(triggerLink, memory_index);
004B82  E0000C     CP0 W12
004B84  320004     BRA Z, 0x4B8E
004B86  805660     MOV triggerLink, W0
004B88  78008B     MOV W11, W1
004B8A  072303     RCALL DataEEWrite
004B8C  370003     BRA 0x4B94
321:                   else triggerLink = DataEERead(memory_index);
004B8E  78000B     MOV W11, W0
004B90  0722B5     RCALL DataEERead
004B92  885660     MOV W0, triggerLink
322:                   memory_index++;
004B94  E8008B     INC W11, W1
323:               
324:                   if (save_switch) DataEEWrite(spiBusMode, memory_index);
004B96  E0000C     CP0 W12
004B98  320003     BRA Z, 0x4BA0
004B9A  805790     MOV spiBusMode, W0
004B9C  0722FA     RCALL DataEEWrite
004B9E  370003     BRA 0x4BA6
325:                   else spiBusMode = DataEERead(memory_index);
004BA0  780001     MOV W1, W0
004BA2  0722AC     RCALL DataEERead
004BA4  885790     MOV W0, spiBusMode
326:                   memory_index++;
004BA6  E8808B     INC2 W11, W1
327:               
328:                   if (save_switch) DataEEWrite(disconnectToggleReset, memory_index);
004BA8  E0000C     CP0 W12
004BAA  320003     BRA Z, 0x4BB2
004BAC  8057A0     MOV disconnectToggleReset, W0
004BAE  0722F1     RCALL DataEEWrite
004BB0  370003     BRA 0x4BB8
329:                   else disconnectToggleReset = DataEERead(memory_index);
004BB2  780001     MOV W1, W0
004BB4  0722A3     RCALL DataEERead
004BB6  8857A0     MOV W0, disconnectToggleReset
330:                   memory_index++;
004BB8  4580E3     ADD W11, #0x3, W1
331:               
332:                   if (save_switch) DataEEWrite(idleTimeout, memory_index);
004BBA  E0000C     CP0 W12
004BBC  320003     BRA Z, 0x4BC4
004BBE  8057B0     MOV idleTimeout, W0
004BC0  0722E8     RCALL DataEEWrite
004BC2  370003     BRA 0x4BCA
333:                   else idleTimeout = DataEERead(memory_index);
004BC4  780001     MOV W1, W0
004BC6  07229A     RCALL DataEERead
004BC8  8857B0     MOV W0, idleTimeout
334:                   memory_index++;
004BCA  4580E4     ADD W11, #0x4, W1
335:               
336:                   if (save_switch) DataEEWrite(lStickDiffMix, memory_index);
004BCC  E0000C     CP0 W12
004BCE  320003     BRA Z, 0x4BD6
004BD0  8057C0     MOV lStickDiffMix, W0
004BD2  0722DF     RCALL DataEEWrite
004BD4  370003     BRA 0x4BDC
337:                   else lStickDiffMix = DataEERead(memory_index);
004BD6  780001     MOV W1, W0
004BD8  072291     RCALL DataEERead
004BDA  8857C0     MOV W0, lStickDiffMix
338:                   memory_index++;
004BDC  4580E5     ADD W11, #0x5, W1
339:               
340:                   if (save_switch) DataEEWrite(rStickDiffMix, memory_index);
004BDE  E0000C     CP0 W12
004BE0  320003     BRA Z, 0x4BE8
004BE2  8057D0     MOV rStickDiffMix, W0
004BE4  0722D6     RCALL DataEEWrite
004BE6  370003     BRA 0x4BEE
341:                   else rStickDiffMix = DataEERead(memory_index);
004BE8  780001     MOV W1, W0
004BEA  072288     RCALL DataEERead
004BEC  8857D0     MOV W0, rStickDiffMix
342:                   memory_index++;
004BEE  4580E6     ADD W11, #0x6, W1
343:               
344:                   if (save_switch) DataEEWrite(mecanumSteering, memory_index);
004BF0  E0000C     CP0 W12
004BF2  320003     BRA Z, 0x4BFA
004BF4  804010     MOV mecanumSteering, W0
004BF6  0722CD     RCALL DataEEWrite
004BF8  370003     BRA 0x4C00
345:                   else mecanumSteering = DataEERead(memory_index);
004BFA  780001     MOV W1, W0
004BFC  07227F     RCALL DataEERead
004BFE  884010     MOV W0, mecanumSteering
346:                   memory_index++;
004C00  4580E7     ADD W11, #0x7, W1
347:               
348:                   if (save_switch) DataEEWrite(LEDBrightness, memory_index);
004C02  E0000C     CP0 W12
004C04  320003     BRA Z, 0x4C0C
004C06  8057E0     MOV LEDBrightness, W0
004C08  0722C4     RCALL DataEEWrite
004C0A  370003     BRA 0x4C12
349:                   else LEDBrightness = DataEERead(memory_index);
004C0C  780001     MOV W1, W0
004C0E  072276     RCALL DataEERead
004C10  8857E0     MOV W0, LEDBrightness
350:                   memory_index++;
004C12  4580E8     ADD W11, #0x8, W1
351:               
352:                   if (save_switch) DataEEWrite(LEDColorSetting, memory_index);
004C14  E0000C     CP0 W12
004C16  320003     BRA Z, 0x4C1E
004C18  805870     MOV LEDColorSetting, W0
004C1A  0722BB     RCALL DataEEWrite
004C1C  370003     BRA 0x4C24
353:                   else LEDColorSetting = DataEERead(memory_index);
004C1E  780001     MOV W1, W0
004C20  07226D     RCALL DataEERead
004C22  885870     MOV W0, LEDColorSetting
354:                   memory_index++;
004C24  4580E9     ADD W11, #0x9, W1
355:                   
356:                   if (save_switch) DataEEWrite(PPMOutput, memory_index);
004C26  E0000C     CP0 W12
004C28  320003     BRA Z, 0x4C30
004C2A  804000     MOV PPMOutput, W0
004C2C  0722B2     RCALL DataEEWrite
004C2E  370003     BRA 0x4C36
357:                   else PPMOutput = DataEERead(memory_index);
004C30  780001     MOV W1, W0
004C32  072264     RCALL DataEERead
004C34  884000     MOV W0, PPMOutput
358:                   memory_index++;
359:                   
360:                   UART2PutDec(memory_index);
004C36  45806A     ADD W11, #0xA, W0
004C38  072536     RCALL UART2PutDec
361:                   UART2PrintString(" EEPROM words used.\n\r");
004C3A  285510     MOV #0x8551, W0
004C3C  072520     RCALL UART2PrintString
362:               
363:                   //when adding settings here, don't forget to update the default load settings function above
364:               }
004C3E  BE064F     MOV.D [--W15], W12
004C40  BE054F     MOV.D [--W15], W10
004C42  BE044F     MOV.D [--W15], W8
004C44  060000     RETURN
365:               
366:               /*******************************************************************************
367:               Function: LoadSavedSettings()
368:               
369:               Precondition:
370:                None
371:               
372:               Overview:
373:                Wrapper for SaveLoadSettings, loads previously saved settings
374:               
375:               Input:
376:                 None
377:               
378:               Output:
379:                None
380:               
381:                *******************************************************************************/
382:               void LoadSavedSettings(void) {
383:                   UART2PrintString("Loading saved settings...");
004C46  285670     MOV #0x8567, W0
004C48  07251A     RCALL UART2PrintString
384:                   SaveLoadSubroutine(0);
004C4A  EB0000     CLR W0
004C4C  07FF65     RCALL SaveLoadSubroutine
385:                   UART2PrintString("Done\n\r");
004C4E  2854A0     MOV #0x854A, W0
004C50  072516     RCALL UART2PrintString
386:               }
004C52  060000     RETURN
387:               
388:               /*******************************************************************************
389:               Function: SaveSettings()
390:               
391:               Precondition:
392:                None
393:               
394:               Overview:
395:                Wrapper for SaveLoadSettings, saves settings
396:               
397:               Input:
398:                 None
399:               
400:               Output:
401:                None
402:               
403:                *******************************************************************************/
404:               void SaveSettings(void) {
405:               
406:                   UART2PrintString("Saving Settings...");
004C54  285810     MOV #0x8581, W0
004C56  072513     RCALL UART2PrintString
407:                   SaveLoadSubroutine(1);
004C58  200010     MOV #0x1, W0
004C5A  07FF5E     RCALL SaveLoadSubroutine
408:                   UART2PrintString("Done.\n\r");
004C5C  285940     MOV #0x8594, W0
004C5E  07250F     RCALL UART2PrintString
409:               }
004C60  060000     RETURN
410:               
411:               //Return servo settings
412:               
413:               SERVO_SETTINGS* GetServoSettings(void) {
414:                   return ServoSettings;
415:               }
004C62  209040     MOV #0x904, W0
004C64  060000     RETURN
416:               
417:               BUTTON_SETTINGS* GetButtonSettings(void) {
418:                   return ButtonSettings;
419:               }
004C66  20A3C0     MOV #0xA3C, W0
004C68  060000     RETURN
420:               
421:               unsigned int GetTimeoutSetting(void) {
004C6A  8057B0     MOV idleTimeout, W0
422:                   return idleTimeout;
423:               }
004C6C  060000     RETURN
424:               
425:               /*******************************************************************************
426:               Function: ConfigOutput()
427:               
428:               Precondition:
429:                None
430:               
431:               Overview:
432:                   This routine allows the user to modify output settings
433:               
434:               Input: 
435:                configFlag == TRUE will continue to run the routine.
436:                configFlag == FALSE will exit the routine.
437:               
438:               Output:
439:                 0 = save and exited;
440:                 1 = stay in config mode;
441:               
442:                *******************************************************************************/
443:               
444:               BOOL ConfigOutput(BOOL configFlag) {
004C6E  BE9F88     MOV.D W8, [W15++]
004C70  781F8A     MOV W10, [W15++]
004C72  780500     MOV W0, W10
445:                   static BOOL configCmdReleased = FALSE;
446:                   static unsigned int cycleCounter = 0; //increment each time we enter the function
447:                   static unsigned int index = 0; //index to mark which output we're configuring
448:                   static BOOL settingsSaved;
449:               
450:                   /*
451:                    //Servos
452:                   0:L-Stick X-axis
453:                   1:L-Stick Y-axis
454:                   2:R-Stick X-axis
455:                   3:R-Stick Y-axis
456:                   4:L-Trig analog
457:                   5:R-Trig analog
458:                   6:TouchPad1(Left side when split)-X
459:                   7:TouchPad1(Left side when split)-Y
460:                   8:TouchPad2(Right side when split)-X
461:                   9:TouchPad2(Right side when split)-Y
462:                   10:X-Accelerometer
463:                   11:Z-Accelerometer
464:                * //Buttons
465:                   12:Share button 
466:                   13:L-Stick button 
467:                   14:R-Stick button 
468:                   15:Options button 
469:                   16:D-Pad Up 
470:                   17:D-Pad Right 
471:                   18:D-Pad Down 
472:                   19:D-Pad Left 
473:                   20:L-Bumper
474:                   21:R-Bumper
475:                   22:L-Trig button
476:                   23:R-Trig button
477:                   24:Triangle button
478:                   25:Circle button
479:                   26:Cross button
480:                   27:Square button
481:                   28:PS button
482:                   29:Touchpad click
483:                    */
484:               
485:                   /////////////////////////////////////////////////////////////////////////////////
486:                   //wait for user to release the "enter config" command buttons so it won't start
487:                   //making changes right away.
488:                   if (configCmdReleased == FALSE && GetPressDuration()->share == 0 && GetPressDuration()->psButton == 0) {
004C74  E2080A     CP0 configCmdReleased
004C76  3A0020     BRA NZ, 0x4CB8
004C78  071F46     RCALL GetPressDuration
004C7A  9058E0     MOV.B [W0+30], W1
004C7C  FB8081     ZE W1, W1
004C7E  905870     MOV.B [W0+31], W0
004C80  DD0048     SL W0, #8, W0
004C82  700001     IOR W0, W1, W0
004C84  3A0013     BRA NZ, 0x4CAC
004C86  071F3F     RCALL GetPressDuration
004C88  9060A0     MOV.B [W0+34], W1
004C8A  FB8081     ZE W1, W1
004C8C  906030     MOV.B [W0+35], W0
004C8E  DD0048     SL W0, #8, W0
004C90  700401     IOR W0, W1, W8
004C92  3A000C     BRA NZ, 0x4CAC
489:                       //initialize config mode flags
490:                       UART2PrintString("===Entering Config Mode:\n\r\n\r*Press 'Esc' to display config guide===\n\r\n\r");
004C94  2859C0     MOV #0x859C, W0
004C96  0724F3     RCALL UART2PrintString
491:                       configCmdReleased = TRUE;
004C98  200010     MOV #0x1, W0
004C9A  884050     MOV W0, configCmdReleased
492:                       index = 0;
004C9C  884038     MOV W8, index
493:                       cycleCounter = 0;
004C9E  884048     MOV W8, cycleCounter
494:                       PrintIndexLabel(index);
004CA0  780008     MOV W8, W0
004CA2  070CF6     RCALL PrintIndexLabel
495:                       UpdateButtonOutputs(FALSE, 0); //update the button outputs before we start and reset the "select" and "PS button" outputs.
004CA4  780088     MOV W8, W1
004CA6  780008     MOV W8, W0
004CA8  070631     RCALL UpdateButtonOutputs
004CAA  370006     BRA 0x4CB8
496:               
497:                   }
498:                   else if (configCmdReleased == FALSE) //force user to release buttons so we don't start making changes right away
004CAC  E2080A     CP0 configCmdReleased
004CAE  3A0004     BRA NZ, 0x4CB8
499:                   {
500:                       UpdateRumbleFeedback(2);
004CB0  200020     MOV #0x2, W0
004CB2  072005     RCALL UpdateRumbleFeedback
004CB4  200010     MOV #0x1, W0
004CB6  370627     BRA 0x5906
501:                       return TRUE;
502:                   }
503:               
504:               
505:                   //////////exit when button is released to prevent the Start button output from activating
506:                   //////////immediately upon exit.
507:                   cycleCounter++;
004CB8  EC2808     INC cycleCounter
508:               
509:                   ////////////////////Commands here apply when configuring either servos or buttons////////////////////////
510:                   /////////////////////IF NEITHER STICK BUTTON IS DEPRESSED. Beware of overlap with other configs commands/////////////////////////////////
511:                   if (!GetButtonPress()->rStickPress && !GetButtonPress()->lStickPress) {
004CBA  071F23     RCALL GetButtonPress
004CBC  9058A0     MOV.B [W0+26], W1
004CBE  FB8081     ZE W1, W1
004CC0  905830     MOV.B [W0+27], W0
004CC2  DD0048     SL W0, #8, W0
004CC4  700001     IOR W0, W1, W0
004CC6  3A0088     BRA NZ, 0x4DD8
004CC8  071F1C     RCALL GetButtonPress
004CCA  905880     MOV.B [W0+24], W1
004CCC  FB8081     ZE W1, W1
004CCE  905810     MOV.B [W0+25], W0
004CD0  DD0048     SL W0, #8, W0
004CD2  700001     IOR W0, W1, W0
004CD4  3A0081     BRA NZ, 0x4DD8
512:                       //update index
513:                       if (GetNewPress()->rBumper) {
004CD6  071F19     RCALL GetNewPress
004CD8  9050A0     MOV.B [W0+18], W1
004CDA  FB8081     ZE W1, W1
004CDC  905030     MOV.B [W0+19], W0
004CDE  DD0048     SL W0, #8, W0
004CE0  700001     IOR W0, W1, W0
004CE2  320008     BRA Z, 0x4CF4
514:                           index++;
004CE4  804031     MOV index, W1
004CE6  E80081     INC W1, W1
515:                           index = index % (NUM_SERVOS + NUM_BUTTONS);
004CE8  2001E2     MOV #0x1E, W2
004CEA  090011     REPEAT #0x11
004CEC  D88082     DIV.UW W1, W2
004CEE  FD0080     EXCH W0, W1
004CF0  884030     MOV W0, index
516:                           PrintIndexLabel(index);
004CF2  070CCE     RCALL PrintIndexLabel
517:                       }
518:                       if (GetNewPress()->lBumper) {
004CF4  071F0A     RCALL GetNewPress
004CF6  905080     MOV.B [W0+16], W1
004CF8  FB8081     ZE W1, W1
004CFA  905010     MOV.B [W0+17], W0
004CFC  DD0048     SL W0, #8, W0
004CFE  700001     IOR W0, W1, W0
004D00  32000F     BRA Z, 0x4D20
519:                           if (index == 0) {
004D02  804030     MOV index, W0
004D04  E00000     CP0 W0
004D06  3A0003     BRA NZ, 0x4D0E
520:                               index = (NUM_SERVOS + NUM_BUTTONS) - 1;
004D08  2001D0     MOV #0x1D, W0
004D0A  884030     MOV W0, index
004D0C  370002     BRA 0x4D12
521:                           }
522:                           else {
523:                               index--;
004D0E  E90000     DEC W0, W0
004D10  884030     MOV W0, index
524:                           }
525:                           index = index % (NUM_SERVOS + NUM_BUTTONS);
004D12  804031     MOV index, W1
004D14  2001E2     MOV #0x1E, W2
004D16  090011     REPEAT #0x11
004D18  D88082     DIV.UW W1, W2
004D1A  FD0080     EXCH W0, W1
004D1C  884030     MOV W0, index
526:                           PrintIndexLabel(index);
004D1E  070CB8     RCALL PrintIndexLabel
527:                       }
528:                       SetLEDColor(index % 10, 10, (index / 10)*20, (index / 10)*10);
004D20  804034     MOV index, W4
004D22  2000A6     MOV #0xA, W6
004D24  090011     REPEAT #0x11
004D26  D88206     DIV.UW W4, W6
004D28  780200     MOV W0, W4
004D2A  780001     MOV W1, W0
004D2C  B9216A     MUL.SU W4, #10, W2
004D2E  B92274     MUL.SU W4, #20, W4
004D30  784182     MOV.B W2, W3
004D32  784104     MOV.B W4, W2
004D34  784086     MOV.B W6, W1
004D36  071EF7     RCALL SetLEDColor
529:               
530:                       //Reset Defaults
531:                       if (GetPressDuration()->share == 100 && GetButtonPress()->options == 0) //check start button to make sure user isn't trying to disconnect
004D38  071EE6     RCALL GetPressDuration
004D3A  9058E0     MOV.B [W0+30], W1
004D3C  FB8081     ZE W1, W1
004D3E  905870     MOV.B [W0+31], W0
004D40  DD0048     SL W0, #8, W0
004D42  700001     IOR W0, W1, W0
004D44  200641     MOV #0x64, W1
004D46  500F81     SUB W0, W1, [W15]
004D48  3A000B     BRA NZ, 0x4D60
004D4A  071EDB     RCALL GetButtonPress
004D4C  9058C0     MOV.B [W0+28], W1
004D4E  FB8081     ZE W1, W1
004D50  905850     MOV.B [W0+29], W0
004D52  DD0048     SL W0, #8, W0
004D54  700001     IOR W0, W1, W0
004D56  3A0004     BRA NZ, 0x4D60
532:                       {
533:                           LoadDefaultSettings(FALSE, index);
004D58  804031     MOV index, W1
004D5A  07FE82     RCALL LoadDefaultSettings
534:                           UpdateRumbleFeedback(5);
004D5C  200050     MOV #0x5, W0
004D5E  071FAF     RCALL UpdateRumbleFeedback
535:                       }
536:               
537:                       if (GetPressDuration()->share == 300 && GetButtonPress()->options == 0) //check start button to make sure user isn't trying to disconnect
004D60  071ED2     RCALL GetPressDuration
004D62  9058E0     MOV.B [W0+30], W1
004D64  FB8081     ZE W1, W1
004D66  905870     MOV.B [W0+31], W0
004D68  DD0048     SL W0, #8, W0
004D6A  700001     IOR W0, W1, W0
004D6C  2012C1     MOV #0x12C, W1
004D6E  500F81     SUB W0, W1, [W15]
004D70  3A000B     BRA NZ, 0x4D88
004D72  071EC7     RCALL GetButtonPress
004D74  9058C0     MOV.B [W0+28], W1
004D76  FB8081     ZE W1, W1
004D78  905850     MOV.B [W0+29], W0
004D7A  DD0048     SL W0, #8, W0
004D7C  700081     IOR W0, W1, W1
004D7E  3A0004     BRA NZ, 0x4D88
538:                       {
539:                           LoadDefaultSettings(TRUE, 0);
004D80  200010     MOV #0x1, W0
004D82  07FE6E     RCALL LoadDefaultSettings
540:                           UpdateRumbleFeedback(10);
004D84  2000A0     MOV #0xA, W0
004D86  071F9B     RCALL UpdateRumbleFeedback
541:                       }
542:               
543:                       //Save and exit
544:                       if (GetPressDuration()->options == 100 && GetButtonPress()->share == 0) //check select button to make sure user isn't trying to disconnect
004D88  071EBE     RCALL GetPressDuration
004D8A  9058C0     MOV.B [W0+28], W1
004D8C  FB8081     ZE W1, W1
004D8E  905850     MOV.B [W0+29], W0
004D90  DD0048     SL W0, #8, W0
004D92  700001     IOR W0, W1, W0
004D94  200641     MOV #0x64, W1
004D96  500F81     SUB W0, W1, [W15]
004D98  3A000D     BRA NZ, 0x4DB4
004D9A  071EB3     RCALL GetButtonPress
004D9C  9058E0     MOV.B [W0+30], W1
004D9E  FB8081     ZE W1, W1
004DA0  905870     MOV.B [W0+31], W0
004DA2  DD0048     SL W0, #8, W0
004DA4  700001     IOR W0, W1, W0
004DA6  3A0006     BRA NZ, 0x4DB4
545:                       {
546:                           SaveSettings();
004DA8  07FF55     RCALL SaveSettings
547:                           settingsSaved = TRUE;
004DAA  200010     MOV #0x1, W0
004DAC  884020     MOV W0, settingsSaved
548:                           UpdateRumbleFeedback(5);
004DAE  200050     MOV #0x5, W0
004DB0  071F86     RCALL UpdateRumbleFeedback
004DB2  370121     BRA 0x4FF6
549:                       }
550:                       else if ((GetButtonPress()->options == 0 && settingsSaved == TRUE) || configFlag == FALSE) {
004DB4  071EA6     RCALL GetButtonPress
004DB6  9058C0     MOV.B [W0+28], W1
004DB8  FB8081     ZE W1, W1
004DBA  905850     MOV.B [W0+29], W0
004DBC  DD0048     SL W0, #8, W0
004DBE  700001     IOR W0, W1, W0
004DC0  3A0003     BRA NZ, 0x4DC8
004DC2  804020     MOV settingsSaved, W0
004DC4  500FE1     SUB W0, #0x1, [W15]
004DC6  320002     BRA Z, 0x4DCC
004DC8  E0000A     CP0 W10
004DCA  3A0115     BRA NZ, 0x4FF6
551:                           UART2PrintString("Exiting Config Mode.\n\r");
004DCC  285E40     MOV #0x85E4, W0
004DCE  072457     RCALL UART2PrintString
552:                           //reset flags
553:                           configCmdReleased = FALSE;
004DD0  EB0000     CLR W0
004DD2  884050     MOV W0, configCmdReleased
554:                           settingsSaved = FALSE;
004DD4  884020     MOV W0, settingsSaved
004DD6  370597     BRA 0x5906
555:                           return FALSE;
556:                       }
557:                   } /////////////////////IF RIGHT STICK BUTTON IS DEPRESSED  Beware of overlap with other configs commands/////////////////////////////////
558:                   else if (GetButtonPress()->rStickPress && !GetButtonPress()->lStickPress) //if right stick switch is pressed
004DD8  071E94     RCALL GetButtonPress
004DDA  9058A0     MOV.B [W0+26], W1
004DDC  FB8081     ZE W1, W1
004DDE  905830     MOV.B [W0+27], W0
004DE0  DD0048     SL W0, #8, W0
004DE2  700001     IOR W0, W1, W0
004DE4  32005B     BRA Z, 0x4E9C
004DE6  071E8D     RCALL GetButtonPress
004DE8  905880     MOV.B [W0+24], W1
004DEA  FB8081     ZE W1, W1
004DEC  905810     MOV.B [W0+25], W0
004DEE  DD0048     SL W0, #8, W0
004DF0  700001     IOR W0, W1, W0
004DF2  3A0054     BRA NZ, 0x4E9C
559:                   {
560:                       //Cycle SPI bus modes;
561:                       if (GetNewPress()->triangle) //if right stick switch is pressed
004DF4  071E8A     RCALL GetNewPress
004DF6  904880     MOV.B [W0+8], W1
004DF8  FB8081     ZE W1, W1
004DFA  904810     MOV.B [W0+9], W0
004DFC  DD0048     SL W0, #8, W0
004DFE  700001     IOR W0, W1, W0
004E00  320029     BRA Z, 0x4E54
562:                       {
563:                           spiBusMode++;
564:                           spiBusMode = spiBusMode % 4;
004E02  EC0AF2     INC spiBusMode, WREG
004E04  600063     AND W0, #0x3, W0
004E06  885790     MOV W0, spiBusMode
565:                           switch (spiBusMode) {
004E08  500FE1     SUB W0, #0x1, [W15]
004E0A  32000D     BRA Z, 0x4E26
004E0C  390005     BRA NC, 0x4E18
004E0E  500FE2     SUB W0, #0x2, [W15]
004E10  320011     BRA Z, 0x4E34
004E12  500FE3     SUB W0, #0x3, [W15]
004E14  3A001D     BRA NZ, 0x4E50
004E16  370015     BRA 0x4E42
566:                               case 0:
567:                                   UART2PrintString("SPI Bus Mode 0\n\r");
004E18  285FB0     MOV #0x85FB, W0
004E1A  072431     RCALL UART2PrintString
568:                                   SPI1STATbits.SPIEN = 0;
004E1C  A9E241     BCLR 0x241, #7
569:                                   SPI1CON1bits.CKP = 0;
004E1E  A9C242     BCLR SPI1CON1, #6
570:                                   SPI1CON1bits.CKE = 1;
004E20  A80243     BSET 0x243, #0
571:                                   SPI1STATbits.SPIEN = 1;
004E22  A8E241     BSET 0x241, #7
004E24  370017     BRA 0x4E54
572:                                   break;
573:               
574:                               case 1:
575:                                   UART2PrintString("SPI Bus Mode 1\n\r");
004E26  2860C0     MOV #0x860C, W0
004E28  07242A     RCALL UART2PrintString
576:                                   SPI1STATbits.SPIEN = 0;
004E2A  A9E241     BCLR 0x241, #7
577:                                   SPI1CON1bits.CKP = 0;
004E2C  A9C242     BCLR SPI1CON1, #6
578:                                   SPI1CON1bits.CKE = 0;
004E2E  A90243     BCLR 0x243, #0
579:                                   SPI1STATbits.SPIEN = 1;
004E30  A8E241     BSET 0x241, #7
004E32  370010     BRA 0x4E54
580:                                   break;
581:               
582:                               case 2:
583:                                   UART2PrintString("SPI Bus Mode 2\n\r");
004E34  2861D0     MOV #0x861D, W0
004E36  072423     RCALL UART2PrintString
584:                                   SPI1STATbits.SPIEN = 0;
004E38  A9E241     BCLR 0x241, #7
585:                                   SPI1CON1bits.CKP = 1;
004E3A  A8C242     BSET SPI1CON1, #6
586:                                   SPI1CON1bits.CKE = 1;
004E3C  A80243     BSET 0x243, #0
587:                                   SPI1STATbits.SPIEN = 1;
004E3E  A8E241     BSET 0x241, #7
004E40  370009     BRA 0x4E54
588:                                   break;
589:               
590:                               case 3:
591:                                   UART2PrintString("SPI Bus Mode 3\n\r");
004E42  2862E0     MOV #0x862E, W0
004E44  07241C     RCALL UART2PrintString
592:                                   SPI1STATbits.SPIEN = 0;
004E46  A9E241     BCLR 0x241, #7
593:                                   SPI1CON1bits.CKP = 1;
004E48  A8C242     BSET SPI1CON1, #6
594:                                   SPI1CON1bits.CKE = 0;
004E4A  A90243     BCLR 0x243, #0
595:                                   SPI1STATbits.SPIEN = 1;
004E4C  A8E241     BSET 0x241, #7
004E4E  370002     BRA 0x4E54
596:                                   break;
597:               
598:                               default:
599:                                   UART2PrintString("ERROR SPI BUS MODE\n\r");
004E50  2863F0     MOV #0x863F, W0
004E52  072415     RCALL UART2PrintString
600:                                   break;
601:                           }
602:                       }
603:                       if (GetNewPress()->cross) {
004E54  071E5A     RCALL GetNewPress
004E56  9048C0     MOV.B [W0+12], W1
004E58  FB8081     ZE W1, W1
004E5A  904850     MOV.B [W0+13], W0
004E5C  DD0048     SL W0, #8, W0
004E5E  700001     IOR W0, W1, W0
004E60  32000A     BRA Z, 0x4E76
604:                           if (idleTimeout == 0) {
004E62  E20AF6     CP0 idleTimeout
004E64  3A0005     BRA NZ, 0x4E70
605:                               idleTimeout = 60000;
004E66  2EA600     MOV #0xEA60, W0
004E68  8857B0     MOV W0, idleTimeout
606:                               UART2PrintString("Idle auto-off set to 10 min.\n\r");
004E6A  286540     MOV #0x8654, W0
004E6C  072408     RCALL UART2PrintString
004E6E  370003     BRA 0x4E76
607:                           }
608:                           else {
609:                               idleTimeout = 0;
004E70  EF2AF6     CLR idleTimeout
610:                               UART2PrintString("Idle auto-off disabled.\n\r");
004E72  286730     MOV #0x8673, W0
004E74  072404     RCALL UART2PrintString
611:                           }
612:                       }
613:                       if (GetNewPress()->psButton) {
004E76  071E49     RCALL GetNewPress
004E78  9060A0     MOV.B [W0+34], W1
004E7A  FB8081     ZE W1, W1
004E7C  906030     MOV.B [W0+35], W0
004E7E  DD0048     SL W0, #8, W0
004E80  700001     IOR W0, W1, W0
004E82  3200B9     BRA Z, 0x4FF6
614:                           disconnectToggleReset = !disconnectToggleReset;
004E84  EE0AF4     NEG disconnectToggleReset, WREG
004E86  B70AF4     IOR disconnectToggleReset, WREG
004E88  DE004F     LSR W0, #15, W0
004E8A  100061     SUBR W0, #0x1, W0
004E8C  8857A0     MOV W0, disconnectToggleReset
615:                           if (disconnectToggleReset) UART2PrintString("Toggled outputs reset on disconnect.\n\r");
004E8E  320003     BRA Z, 0x4E96
004E90  2868D0     MOV #0x868D, W0
004E92  0723F5     RCALL UART2PrintString
004E94  3700B0     BRA 0x4FF6
616:                           else UART2PrintString("Toggled outputs preserved on disconnect.\n\r");
004E96  286B40     MOV #0x86B4, W0
004E98  0723F2     RCALL UART2PrintString
004E9A  3700AD     BRA 0x4FF6
617:                       }
618:                   }
619:                       /////////////////////IF LEFT STICK BUTTON IS DEPRESSED  These are universal settings, beware with overlap for channel specific settings/////////////////////////////////
620:                   else if (GetButtonPress()->lStickPress && !GetButtonPress()->rStickPress) //if left stick switch is pressed
004E9C  071E32     RCALL GetButtonPress
004E9E  905880     MOV.B [W0+24], W1
004EA0  FB8081     ZE W1, W1
004EA2  905810     MOV.B [W0+25], W0
004EA4  DD0048     SL W0, #8, W0
004EA6  700001     IOR W0, W1, W0
004EA8  3200A6     BRA Z, 0x4FF6
004EAA  071E2B     RCALL GetButtonPress
004EAC  9058A0     MOV.B [W0+26], W1
004EAE  FB8081     ZE W1, W1
004EB0  905830     MOV.B [W0+27], W0
004EB2  DD0048     SL W0, #8, W0
004EB4  700001     IOR W0, W1, W0
004EB6  3A009F     BRA NZ, 0x4FF6
621:                   {
622:                       if (GetNewPress()->dPadRight || (GetPressDuration()->dPadRight > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
004EB8  071E28     RCALL GetNewPress
004EBA  9040A0     MOV.B [W0+2], W1
004EBC  FB8081     ZE W1, W1
004EBE  904030     MOV.B [W0+3], W0
004EC0  DD0048     SL W0, #8, W0
004EC2  700001     IOR W0, W1, W0
004EC4  3A000B     BRA NZ, 0x4EDC
004EC6  071E1F     RCALL GetPressDuration
004EC8  9040A0     MOV.B [W0+2], W1
004ECA  FB8081     ZE W1, W1
004ECC  904030     MOV.B [W0+3], W0
004ECE  DD0048     SL W0, #8, W0
004ED0  700001     IOR W0, W1, W0
004ED2  200321     MOV #0x32, W1
004ED4  500F81     SUB W0, W1, [W15]
004ED6  360011     BRA LEU, 0x4EFA
004ED8  AB0808     BTST cycleCounter, #0
004EDA  3A000F     BRA NZ, 0x4EFA
623:                           if (LEDBrightness < 50) {
004EDC  8057E1     MOV LEDBrightness, W1
004EDE  200310     MOV #0x31, W0
004EE0  508F80     SUB W1, W0, [W15]
004EE2  3E0003     BRA GTU, 0x4EEA
624:                               LEDBrightness++;
004EE4  E80001     INC W1, W0
004EE6  8857E0     MOV W0, LEDBrightness
004EE8  370002     BRA 0x4EEE
625:                           }
626:                           else {
627:                               UpdateRumbleFeedback(2);
004EEA  200020     MOV #0x2, W0
004EEC  071EE8     RCALL UpdateRumbleFeedback
628:                           }
629:                           UART2PrintString("LED Brightness: ");
004EEE  286DF0     MOV #0x86DF, W0
004EF0  0723C6     RCALL UART2PrintString
630:                           UART2PutDec(LEDBrightness);
004EF2  BFCAFC     MOV.B LEDBrightness, WREG
004EF4  0723D8     RCALL UART2PutDec
631:                           UART2PrintString("\n\r");
004EF6  286F00     MOV #0x86F0, W0
004EF8  0723C2     RCALL UART2PrintString
632:                       }
633:               
634:                       //LED Brightness
635:                       if (GetNewPress()->dPadLeft || (GetPressDuration()->dPadLeft > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
004EFA  071E07     RCALL GetNewPress
004EFC  9040E0     MOV.B [W0+6], W1
004EFE  FB8081     ZE W1, W1
004F00  904070     MOV.B [W0+7], W0
004F02  DD0048     SL W0, #8, W0
004F04  700001     IOR W0, W1, W0
004F06  3A000B     BRA NZ, 0x4F1E
004F08  071DFE     RCALL GetPressDuration
004F0A  9040E0     MOV.B [W0+6], W1
004F0C  FB8081     ZE W1, W1
004F0E  904070     MOV.B [W0+7], W0
004F10  DD0048     SL W0, #8, W0
004F12  700001     IOR W0, W1, W0
004F14  200321     MOV #0x32, W1
004F16  500F81     SUB W0, W1, [W15]
004F18  360010     BRA LEU, 0x4F3A
004F1A  AB0808     BTST cycleCounter, #0
004F1C  3A000E     BRA NZ, 0x4F3A
636:                           if (LEDBrightness > 0) {
004F1E  8057E0     MOV LEDBrightness, W0
004F20  E00000     CP0 W0
004F22  320003     BRA Z, 0x4F2A
637:                               LEDBrightness--;
004F24  E90000     DEC W0, W0
004F26  8857E0     MOV W0, LEDBrightness
004F28  370002     BRA 0x4F2E
638:                           }
639:                           else {
640:                               UpdateRumbleFeedback(2);
004F2A  200020     MOV #0x2, W0
004F2C  071EC8     RCALL UpdateRumbleFeedback
641:                           }
642:                           UART2PrintString("LED Brightness: ");
004F2E  286DF0     MOV #0x86DF, W0
004F30  0723A6     RCALL UART2PrintString
643:                           UART2PutDec(LEDBrightness);
004F32  BFCAFC     MOV.B LEDBrightness, WREG
004F34  0723B8     RCALL UART2PutDec
644:                           UART2PrintString("\n\r");
004F36  286F00     MOV #0x86F0, W0
004F38  0723A2     RCALL UART2PrintString
645:                       }
646:                       
647:                       if (GetNewPress()->share) {
004F3A  071DE7     RCALL GetNewPress
004F3C  9058E0     MOV.B [W0+30], W1
004F3E  FB8081     ZE W1, W1
004F40  905870     MOV.B [W0+31], W0
004F42  DD0048     SL W0, #8, W0
004F44  700001     IOR W0, W1, W0
004F46  320045     BRA Z, 0x4FD2
648:                           LEDColorSetting++;
004F48  EC0B0E     INC LEDColorSetting, WREG
004F4A  885870     MOV W0, LEDColorSetting
649:                           if (LEDColorSetting > BATTERY) 
004F4C  500FEC     SUB W0, #0xC, [W15]
004F4E  360001     BRA LEU, 0x4F52
650:                           {
651:                               LEDColorSetting = 0;
004F50  EF2B0E     CLR LEDColorSetting
652:                           }
653:                           UART2PrintString("LED Color Setting: ");
004F52  286F30     MOV #0x86F3, W0
004F54  072394     RCALL UART2PrintString
654:                           switch (LEDColorSetting) {
004F56  805870     MOV LEDColorSetting, W0
004F58  200001     MOV #0x0, W1
004F5A  500FEC     SUB W0, #0xC, [W15]
004F5C  588FE0     SUBB W1, #0x0, [W15]
004F5E  3E0035     BRA GTU, 0x4FCA
004F60  016000     BRA W0
004F62  37000F     BRA 0x4F82
004F64  370011     BRA 0x4F88
004F66  370013     BRA 0x4F8E
004F68  370015     BRA 0x4F94
004F6A  370017     BRA 0x4F9A
004F6C  370019     BRA 0x4FA0
004F6E  370006     BRA 0x4F7C
004F70  37001A     BRA 0x4FA6
004F72  37001C     BRA 0x4FAC
004F74  37001E     BRA 0x4FB2
004F76  370020     BRA 0x4FB8
004F78  370022     BRA 0x4FBE
004F7A  370024     BRA 0x4FC4
655:                               case BLUE: //blue
656:                                   UART2PrintString("Blue");                    
004F7C  287070     MOV #0x8707, W0
004F7E  07237F     RCALL UART2PrintString
004F80  370026     BRA 0x4FCE
657:                                   break;
658:                               case RED: //red
659:                                   UART2PrintString("Red");  
004F82  2870C0     MOV #0x870C, W0
004F84  07237C     RCALL UART2PrintString
004F86  370023     BRA 0x4FCE
660:                                   break;
661:                               case ORANGE: //orange
662:                                   UART2PrintString("Orange");  
004F88  287100     MOV #0x8710, W0
004F8A  072379     RCALL UART2PrintString
004F8C  370020     BRA 0x4FCE
663:                                   break;
664:                               case YELLOW: //yellow
665:                                   UART2PrintString("Yellow");  
004F8E  287170     MOV #0x8717, W0
004F90  072376     RCALL UART2PrintString
004F92  37001D     BRA 0x4FCE
666:                                   break;
667:                               case LIME://lime
668:                                   UART2PrintString("Lime");  
004F94  2871E0     MOV #0x871E, W0
004F96  072373     RCALL UART2PrintString
004F98  37001A     BRA 0x4FCE
669:                                   break;
670:                               case GREEN: //green
671:                                   UART2PrintString("Green");  
004F9A  287230     MOV #0x8723, W0
004F9C  072370     RCALL UART2PrintString
004F9E  370017     BRA 0x4FCE
672:                                   break;
673:                               case TURQUOISE: //turquoise
674:                                   UART2PrintString("Turquoise");  
004FA0  287290     MOV #0x8729, W0
004FA2  07236D     RCALL UART2PrintString
004FA4  370014     BRA 0x4FCE
675:                                   break;
676:                               case PURPLE: //purple
677:                                   UART2PrintString("Purple");  
004FA6  287330     MOV #0x8733, W0
004FA8  07236A     RCALL UART2PrintString
004FAA  370011     BRA 0x4FCE
678:                                   break;
679:                               case PINK: //pink
680:                                   UART2PrintString("Pink");  
004FAC  2873A0     MOV #0x873A, W0
004FAE  072367     RCALL UART2PrintString
004FB0  37000E     BRA 0x4FCE
681:                                   break;
682:                               case WHITE: //white
683:                                   UART2PrintString("White");  
004FB2  2873F0     MOV #0x873F, W0
004FB4  072364     RCALL UART2PrintString
004FB6  37000B     BRA 0x4FCE
684:                                   break;
685:                               case LED_OFF:
686:                                   UART2PrintString("Off");
004FB8  287450     MOV #0x8745, W0
004FBA  072361     RCALL UART2PrintString
004FBC  370008     BRA 0x4FCE
687:                                   break;
688:                               case COLOR_ADC:
689:                                   UART2PrintString("ADC");
004FBE  287490     MOV #0x8749, W0
004FC0  07235E     RCALL UART2PrintString
004FC2  370005     BRA 0x4FCE
690:                                   break;
691:                               case BATTERY:
692:                                   UART2PrintString("Battery");  
004FC4  2874D0     MOV #0x874D, W0
004FC6  07235B     RCALL UART2PrintString
004FC8  370002     BRA 0x4FCE
693:                                   break;
694:                               default:
695:                                   UART2PrintString("Error");  
004FCA  287550     MOV #0x8755, W0
004FCC  072358     RCALL UART2PrintString
696:                                   break;
697:                               }
698:                           UART2PrintString("\n\r");
004FCE  286F00     MOV #0x86F0, W0
004FD0  072356     RCALL UART2PrintString
699:                       }
700:                       if (GetNewPress()->options) {
004FD2  071D9B     RCALL GetNewPress
004FD4  9058C0     MOV.B [W0+28], W1
004FD6  FB8081     ZE W1, W1
004FD8  905850     MOV.B [W0+29], W0
004FDA  DD0048     SL W0, #8, W0
004FDC  700001     IOR W0, W1, W0
004FDE  32000B     BRA Z, 0x4FF6
701:                           PPMOutput = !PPMOutput;
004FE0  EE0800     NEG PPMOutput, WREG
004FE2  B70800     IOR PPMOutput, WREG
004FE4  DE004F     LSR W0, #15, W0
004FE6  100061     SUBR W0, #0x1, W0
004FE8  884000     MOV W0, PPMOutput
702:                           UART2PrintString("PPM Output Mode = ");
004FEA  2875B0     MOV #0x875B, W0
004FEC  072348     RCALL UART2PrintString
703:                           UART2PutDecInt(PPMOutput);
004FEE  804000     MOV PPMOutput, W0
004FF0  072394     RCALL UART2PutDecInt
704:                           UART2PrintString("\n\r");
004FF2  286F00     MOV #0x86F0, W0
004FF4  072344     RCALL UART2PrintString
705:                       }
706:                   }
707:               
708:                   /////////////////SET SERVO SETTINGS///////////////////////
709:                   if (index < NUM_SERVOS) {
004FF6  804030     MOV index, W0
004FF8  500FEB     SUB W0, #0xB, [W15]
004FFA  3E0329     BRA GTU, 0x564E
710:                       /////////////////////If right stick is depressed while configuring servos/////////////////////////////////
711:                       //if the RStick button is held down, enable different set of options.
712:                       if (GetButtonPress()->rStickPress && !GetButtonPress()->lStickPress) {
004FFC  071D82     RCALL GetButtonPress
004FFE  9058A0     MOV.B [W0+26], W1
005000  FB8081     ZE W1, W1
005002  905830     MOV.B [W0+27], W0
005004  DD0048     SL W0, #8, W0
005006  700001     IOR W0, W1, W0
005008  3200CB     BRA Z, 0x51A0
00500A  071D7B     RCALL GetButtonPress
00500C  905880     MOV.B [W0+24], W1
00500E  FB8081     ZE W1, W1
005010  905810     MOV.B [W0+25], W0
005012  DD0048     SL W0, #8, W0
005014  700001     IOR W0, W1, W0
005016  3A00C4     BRA NZ, 0x51A0
713:                           //Increase output trim
714:                           if (GetNewPress()->dPadRight || (GetPressDuration()->dPadRight > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
005018  071D78     RCALL GetNewPress
00501A  9040A0     MOV.B [W0+2], W1
00501C  FB8081     ZE W1, W1
00501E  904030     MOV.B [W0+3], W0
005020  DD0048     SL W0, #8, W0
005022  700001     IOR W0, W1, W0
005024  3A000B     BRA NZ, 0x503C
005026  071D6F     RCALL GetPressDuration
005028  9040A0     MOV.B [W0+2], W1
00502A  FB8081     ZE W1, W1
00502C  904030     MOV.B [W0+3], W0
00502E  DD0048     SL W0, #8, W0
005030  700001     IOR W0, W1, W0
005032  200321     MOV #0x32, W1
005034  500F81     SUB W0, W1, [W15]
005036  360019     BRA LEU, 0x506A
005038  AB0808     BTST cycleCounter, #0
00503A  3A0017     BRA NZ, 0x506A
715:                               if (ServoSettings[index].trim < TRIM_MAX) {
00503C  804030     MOV index, W0
00503E  B9007A     MUL.SU W0, #26, W0
005040  400172     ADD W0, #0x12, W2
005042  209043     MOV #0x904, W3
005044  7980E2     MOV [W2+W3], W1
005046  200C70     MOV #0xC7, W0
005048  508F80     SUB W1, W0, [W15]
00504A  3C0003     BRA GT, 0x5052
716:                                   ServoSettings[index].trim++;
00504C  E80001     INC W1, W0
00504E  79B100     MOV W0, [W2+W3]
005050  370002     BRA 0x5056
717:                               }
718:                               else {
719:                                   UpdateRumbleFeedback(2);
005052  200020     MOV #0x2, W0
005054  071E34     RCALL UpdateRumbleFeedback
720:                               }
721:                               UART2PrintString("Trim = ");
005056  2876E0     MOV #0x876E, W0
005058  072312     RCALL UART2PrintString
722:                               UART2PutDecSInt(ServoSettings[index].trim);
00505A  804030     MOV index, W0
00505C  B9007A     MUL.SU W0, #26, W0
00505E  400072     ADD W0, #0x12, W0
005060  209042     MOV #0x904, W2
005062  790060     MOV [W0+W2], W0
005064  072386     RCALL UART2PutDecSInt
723:                               UART2PrintString("\n\r");
005066  286F00     MOV #0x86F0, W0
005068  07230A     RCALL UART2PrintString
724:                           }
725:               
726:                           //Decrease output trim
727:                           if (GetNewPress()->dPadLeft || (GetPressDuration()->dPadLeft > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00506A  071D4F     RCALL GetNewPress
00506C  9040E0     MOV.B [W0+6], W1
00506E  FB8081     ZE W1, W1
005070  904070     MOV.B [W0+7], W0
005072  DD0048     SL W0, #8, W0
005074  700001     IOR W0, W1, W0
005076  3A000B     BRA NZ, 0x508E
005078  071D46     RCALL GetPressDuration
00507A  9040E0     MOV.B [W0+6], W1
00507C  FB8081     ZE W1, W1
00507E  904070     MOV.B [W0+7], W0
005080  DD0048     SL W0, #8, W0
005082  700001     IOR W0, W1, W0
005084  200321     MOV #0x32, W1
005086  500F81     SUB W0, W1, [W15]
005088  360019     BRA LEU, 0x50BC
00508A  AB0808     BTST cycleCounter, #0
00508C  3A0017     BRA NZ, 0x50BC
728:                               if (ServoSettings[index].trim > TRIM_MIN) {
00508E  804030     MOV index, W0
005090  B9007A     MUL.SU W0, #26, W0
005092  400172     ADD W0, #0x12, W2
005094  209043     MOV #0x904, W3
005096  7980E2     MOV [W2+W3], W1
005098  2FF380     MOV #0xFF38, W0
00509A  508F80     SUB W1, W0, [W15]
00509C  340003     BRA LE, 0x50A4
729:                                   ServoSettings[index].trim--;
00509E  E90001     DEC W1, W0
0050A0  79B100     MOV W0, [W2+W3]
0050A2  370002     BRA 0x50A8
730:                               }
731:                               else {
732:                                   UpdateRumbleFeedback(2);
0050A4  200020     MOV #0x2, W0
0050A6  071E0B     RCALL UpdateRumbleFeedback
733:                               }
734:                               UART2PrintString("Trim = ");
0050A8  2876E0     MOV #0x876E, W0
0050AA  0722E9     RCALL UART2PrintString
735:                               UART2PutDecSInt(ServoSettings[index].trim);
0050AC  804030     MOV index, W0
0050AE  B9007A     MUL.SU W0, #26, W0
0050B0  400072     ADD W0, #0x12, W0
0050B2  209042     MOV #0x904, W2
0050B4  790060     MOV [W0+W2], W0
0050B6  07235D     RCALL UART2PutDecSInt
736:                               UART2PrintString("\n\r");
0050B8  286F00     MOV #0x86F0, W0
0050BA  0722E1     RCALL UART2PrintString
737:                           }
738:               
739:                           if (index == TPAD1_X || index == TPAD1_Y || index == TPAD2_X || index == TPAD2_Y) {
0050BC  804030     MOV index, W0
0050BE  500066     SUB W0, #0x6, W0
0050C0  500FE3     SUB W0, #0x3, [W15]
0050C2  3E0033     BRA GTU, 0x512A
740:                               //TPAD/Virtual Joystick
741:                               if (GetNewPress()->dPadUp) {
0050C4  071D22     RCALL GetNewPress
0050C6  FB8090     ZE [W0], W1
0050C8  904010     MOV.B [W0+1], W0
0050CA  DD0048     SL W0, #8, W0
0050CC  700001     IOR W0, W1, W0
0050CE  320013     BRA Z, 0x50F6
742:               
743:                                   if (ServoSettings[index].touchpadMode == TPAD) {
0050D0  804032     MOV index, W2
0050D2  B9107A     MUL.SU W2, #26, W0
0050D4  4000EC     ADD W0, #0xC, W1
0050D6  209043     MOV #0x904, W3
0050D8  798061     MOV [W1+W3], W0
0050DA  E00000     CP0 W0
0050DC  3A0005     BRA NZ, 0x50E8
744:                                       ServoSettings[index].touchpadMode = JOYSTICK;
0050DE  200010     MOV #0x1, W0
0050E0  79B080     MOV W0, [W1+W3]
745:                                       UART2PrintString("Touchpad Mode = Virtual Joystick\n\r");
0050E2  287760     MOV #0x8776, W0
0050E4  0722CC     RCALL UART2PrintString
0050E6  370007     BRA 0x50F6
746:                                   }
747:                                   else {
748:                                       ServoSettings[index].touchpadMode = TPAD;
0050E8  B9107A     MUL.SU W2, #26, W0
0050EA  40006C     ADD W0, #0xC, W0
0050EC  EB0180     CLR W3
0050EE  209042     MOV #0x904, W2
0050F0  793003     MOV W3, [W0+W2]
749:                                       UART2PrintString("Touchpad Mode = Touchpad\n\r");
0050F2  287990     MOV #0x8799, W0
0050F4  0722C4     RCALL UART2PrintString
750:                                   }
751:                               }
752:               
753:                               //Split Touchpad
754:                               if (GetNewPress()->dPadDown) {
0050F6  071D09     RCALL GetNewPress
0050F8  9040C0     MOV.B [W0+4], W1
0050FA  FB8081     ZE W1, W1
0050FC  904050     MOV.B [W0+5], W0
0050FE  DD0048     SL W0, #8, W0
005100  700001     IOR W0, W1, W0
005102  320013     BRA Z, 0x512A
755:               
756:                                   if (ServoSettings[index].touchpadSplit == WHOLE) {
005104  804032     MOV index, W2
005106  B9107A     MUL.SU W2, #26, W0
005108  4000EE     ADD W0, #0xE, W1
00510A  209043     MOV #0x904, W3
00510C  798061     MOV [W1+W3], W0
00510E  E00000     CP0 W0
005110  3A0005     BRA NZ, 0x511C
757:                                       ServoSettings[index].touchpadSplit = SPLIT;
005112  200010     MOV #0x1, W0
005114  79B080     MOV W0, [W1+W3]
758:                                       UART2PrintString("Touchpad Split = On\n\r");
005116  287B40     MOV #0x87B4, W0
005118  0722B2     RCALL UART2PrintString
00511A  370007     BRA 0x512A
759:                                   }
760:                                   else {
761:                                       ServoSettings[index].touchpadSplit = WHOLE;
00511C  B9107A     MUL.SU W2, #26, W0
00511E  40006E     ADD W0, #0xE, W0
005120  EB0180     CLR W3
005122  209042     MOV #0x904, W2
005124  793003     MOV W3, [W0+W2]
762:                                       UART2PrintString("Touchpad Split = Off\n\r");
005126  287CA0     MOV #0x87CA, W0
005128  0722AA     RCALL UART2PrintString
763:                                   }
764:                               }
765:                           }
766:               
767:                           //Set servo forward/reverse
768:                           if (GetNewPress()->lBumper) {
00512A  071CEF     RCALL GetNewPress
00512C  905080     MOV.B [W0+16], W1
00512E  FB8081     ZE W1, W1
005130  905010     MOV.B [W0+17], W0
005132  DD0048     SL W0, #8, W0
005134  700001     IOR W0, W1, W0
005136  320016     BRA Z, 0x5164
769:                               ServoSettings[index].direction = !ServoSettings[index].direction;
005138  804033     MOV index, W3
00513A  EB0200     CLR W4
00513C  B9187A     MUL.SU W3, #26, W0
00513E  400068     ADD W0, #0x8, W0
005140  209042     MOV #0x904, W2
005142  790060     MOV [W0+W2], W0
005144  E00000     CP0 W0
005146  3A0001     BRA NZ, 0x514A
005148  200014     MOV #0x1, W4
00514A  B9187A     MUL.SU W3, #26, W0
00514C  400068     ADD W0, #0x8, W0
00514E  209042     MOV #0x904, W2
005150  793004     MOV W4, [W0+W2]
770:                               if (ServoSettings[index].direction == FORWARD) {
005152  E00004     CP0 W4
005154  3A0003     BRA NZ, 0x515C
771:                                   UART2PrintString("Servo/Motor Forward.\n\r");
005156  287E10     MOV #0x87E1, W0
005158  072292     RCALL UART2PrintString
00515A  370004     BRA 0x5164
772:                               }
773:                               else if (ServoSettings[index].direction == REVERSE) {
00515C  520FE1     SUB W4, #0x1, [W15]
00515E  3A0002     BRA NZ, 0x5164
774:                                   UART2PrintString("Servo/Motor Reverse.\n\r");
005160  287F80     MOV #0x87F8, W0
005162  07228D     RCALL UART2PrintString
775:                               }
776:                           }
777:               
778:                           //Set absolute/relative mode
779:                           if (GetNewPress()->rBumper) {
005164  071CD2     RCALL GetNewPress
005166  9050A0     MOV.B [W0+18], W1
005168  FB8081     ZE W1, W1
00516A  905030     MOV.B [W0+19], W0
00516C  DD0048     SL W0, #8, W0
00516E  700001     IOR W0, W1, W0
005170  32026E     BRA Z, 0x564E
780:                               ServoSettings[index].absOrRel = !ServoSettings[index].absOrRel;
005172  804033     MOV index, W3
005174  EB0200     CLR W4
005176  B9187A     MUL.SU W3, #26, W0
005178  40006A     ADD W0, #0xA, W0
00517A  209042     MOV #0x904, W2
00517C  790060     MOV [W0+W2], W0
00517E  E00000     CP0 W0
005180  3A0001     BRA NZ, 0x5184
005182  200014     MOV #0x1, W4
005184  B9187A     MUL.SU W3, #26, W0
005186  40006A     ADD W0, #0xA, W0
005188  209042     MOV #0x904, W2
00518A  793004     MOV W4, [W0+W2]
781:                               if (ServoSettings[index].absOrRel == ABSOLUTE) {
00518C  E00004     CP0 W4
00518E  3A0003     BRA NZ, 0x5196
782:                                   UART2PrintString("Absolute input mode.\n\r");
005190  2880F0     MOV #0x880F, W0
005192  072275     RCALL UART2PrintString
005194  37025C     BRA 0x564E
783:                               }
784:                               else if (ServoSettings[index].absOrRel == RELATIVE) {
005196  520FE1     SUB W4, #0x1, [W15]
005198  3A025A     BRA NZ, 0x564E
785:                                   UART2PrintString("Relative input mode.\n\r");
00519A  288260     MOV #0x8826, W0
00519C  072270     RCALL UART2PrintString
00519E  370257     BRA 0x564E
786:                               }
787:                           }
788:               
789:                       }//end settings if rstick is held down
790:               
791:                           /////////////////////If left stick is depressed while configuring servos/////////////////////////////////
792:                       else if (GetButtonPress()->lStickPress && !GetButtonPress()->rStickPress) {
0051A0  071CB0     RCALL GetButtonPress
0051A2  905880     MOV.B [W0+24], W1
0051A4  FB8081     ZE W1, W1
0051A6  905810     MOV.B [W0+25], W0
0051A8  DD0048     SL W0, #8, W0
0051AA  700001     IOR W0, W1, W0
0051AC  3200D7     BRA Z, 0x535C
0051AE  071CA9     RCALL GetButtonPress
0051B0  9058A0     MOV.B [W0+26], W1
0051B2  FB8081     ZE W1, W1
0051B4  905830     MOV.B [W0+27], W0
0051B6  DD0048     SL W0, #8, W0
0051B8  700001     IOR W0, W1, W0
0051BA  3A00D0     BRA NZ, 0x535C
793:                           //set filter coefficient
794:                           if (GetNewPress()->dPadUp || (GetPressDuration()->dPadUp > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0051BC  071CA6     RCALL GetNewPress
0051BE  FB8090     ZE [W0], W1
0051C0  904010     MOV.B [W0+1], W0
0051C2  DD0048     SL W0, #8, W0
0051C4  700001     IOR W0, W1, W0
0051C6  3A000A     BRA NZ, 0x51DC
0051C8  071C9E     RCALL GetPressDuration
0051CA  FB8090     ZE [W0], W1
0051CC  904010     MOV.B [W0+1], W0
0051CE  DD0048     SL W0, #8, W0
0051D0  700001     IOR W0, W1, W0
0051D2  200321     MOV #0x32, W1
0051D4  500F81     SUB W0, W1, [W15]
0051D6  360019     BRA LEU, 0x520A
0051D8  AB0808     BTST cycleCounter, #0
0051DA  3A0017     BRA NZ, 0x520A
795:                               if (ServoSettings[index].filterStrength < 50) {
0051DC  804030     MOV index, W0
0051DE  B9007A     MUL.SU W0, #26, W0
0051E0  400170     ADD W0, #0x10, W2
0051E2  209043     MOV #0x904, W3
0051E4  7980E2     MOV [W2+W3], W1
0051E6  200310     MOV #0x31, W0
0051E8  508F80     SUB W1, W0, [W15]
0051EA  3C0003     BRA GT, 0x51F2
796:                                   ServoSettings[index].filterStrength++;
0051EC  E80001     INC W1, W0
0051EE  79B100     MOV W0, [W2+W3]
0051F0  370002     BRA 0x51F6
797:                               }
798:                               else {
799:                                   UpdateRumbleFeedback(2);
0051F2  200020     MOV #0x2, W0
0051F4  071D64     RCALL UpdateRumbleFeedback
800:                               }
801:                               UART2PrintString("Smoothing: ");
0051F6  2883D0     MOV #0x883D, W0
0051F8  072242     RCALL UART2PrintString
802:                               UART2PutDec(ServoSettings[index].filterStrength);
0051FA  804030     MOV index, W0
0051FC  B9007A     MUL.SU W0, #26, W0
0051FE  400070     ADD W0, #0x10, W0
005200  209042     MOV #0x904, W2
005202  790060     MOV [W0+W2], W0
005204  072250     RCALL UART2PutDec
803:                               UART2PrintString("\n\r");
005206  286F00     MOV #0x86F0, W0
005208  07223A     RCALL UART2PrintString
804:                           }
805:               
806:                           //LED Brightness
807:                           if (GetNewPress()->dPadDown || (GetPressDuration()->dPadDown > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00520A  071C7F     RCALL GetNewPress
00520C  9040C0     MOV.B [W0+4], W1
00520E  FB8081     ZE W1, W1
005210  904050     MOV.B [W0+5], W0
005212  DD0048     SL W0, #8, W0
005214  700001     IOR W0, W1, W0
005216  3A000B     BRA NZ, 0x522E
005218  071C76     RCALL GetPressDuration
00521A  9040C0     MOV.B [W0+4], W1
00521C  FB8081     ZE W1, W1
00521E  904050     MOV.B [W0+5], W0
005220  DD0048     SL W0, #8, W0
005222  700001     IOR W0, W1, W0
005224  200321     MOV #0x32, W1
005226  500F81     SUB W0, W1, [W15]
005228  360018     BRA LEU, 0x525A
00522A  AB0808     BTST cycleCounter, #0
00522C  3A0016     BRA NZ, 0x525A
808:                               if (ServoSettings[index].filterStrength > 0) {
00522E  804030     MOV index, W0
005230  B9007A     MUL.SU W0, #26, W0
005232  4000F0     ADD W0, #0x10, W1
005234  209042     MOV #0x904, W2
005236  790061     MOV [W1+W2], W0
005238  E00000     CP0 W0
00523A  340003     BRA LE, 0x5242
809:                                   ServoSettings[index].filterStrength--;
00523C  E90000     DEC W0, W0
00523E  793080     MOV W0, [W1+W2]
005240  370002     BRA 0x5246
810:                               }
811:                               else {
812:                                   UpdateRumbleFeedback(2);
005242  200020     MOV #0x2, W0
005244  071D3C     RCALL UpdateRumbleFeedback
813:                               }
814:                               UART2PrintString("Smoothing: ");
005246  2883D0     MOV #0x883D, W0
005248  07221A     RCALL UART2PrintString
815:                               UART2PutDec(ServoSettings[index].filterStrength);
00524A  804030     MOV index, W0
00524C  B9007A     MUL.SU W0, #26, W0
00524E  400070     ADD W0, #0x10, W0
005250  209042     MOV #0x904, W2
005252  790060     MOV [W0+W2], W0
005254  072228     RCALL UART2PutDec
816:                               UART2PrintString("\n\r");
005256  286F00     MOV #0x86F0, W0
005258  072212     RCALL UART2PrintString
817:                           }
818:               
819:                           //SET TRIGGER LINK
820:                           /*linking the trigger linkes the 2 triggers so that one move the servo in a
821:                            * positive direction and the other moves the servo in a negative direction.*/
822:                           if ((index == L_TRIG || index == R_TRIG) && GetNewPress()->cross) {
00525A  804030     MOV index, W0
00525C  500064     SUB W0, #0x4, W0
00525E  500FE1     SUB W0, #0x1, [W15]
005260  3E0013     BRA GTU, 0x5288
005262  071C53     RCALL GetNewPress
005264  9048C0     MOV.B [W0+12], W1
005266  FB8081     ZE W1, W1
005268  904850     MOV.B [W0+13], W0
00526A  DD0048     SL W0, #8, W0
00526C  700001     IOR W0, W1, W0
00526E  32000C     BRA Z, 0x5288
823:                               triggerLink = !triggerLink;
005270  EE0ACC     NEG triggerLink, WREG
005272  B70ACC     IOR triggerLink, WREG
005274  DE004F     LSR W0, #15, W0
005276  100061     SUBR W0, #0x1, W0
005278  885660     MOV W0, triggerLink
824:                               if (triggerLink == TRUE) {
00527A  500FE1     SUB W0, #0x1, [W15]
00527C  3A0003     BRA NZ, 0x5284
825:                                   UART2PrintString("Trigger Link On.\n\r");
00527E  288490     MOV #0x8849, W0
005280  0721FE     RCALL UART2PrintString
005282  370002     BRA 0x5288
826:                               }
827:                               else {
828:                                   UART2PrintString("Trigger Link Off.\n\r");
005284  2885C0     MOV #0x885C, W0
005286  0721FB     RCALL UART2PrintString
829:                               }
830:                           }
831:               
832:                           //Left Stick only settings
833:                           if (index == L_STICK_X || index == L_STICK_Y)//Left stick settings
005288  804030     MOV index, W0
00528A  500FE1     SUB W0, #0x1, [W15]
00528C  3E0013     BRA GTU, 0x52B4
834:                           {
835:                               if (GetNewPress()->cross) //Left Stick Differential Mix Enable/Disable
00528E  071C3D     RCALL GetNewPress
005290  9048C0     MOV.B [W0+12], W1
005292  FB8081     ZE W1, W1
005294  904850     MOV.B [W0+13], W0
005296  DD0048     SL W0, #8, W0
005298  700001     IOR W0, W1, W0
00529A  32000C     BRA Z, 0x52B4
836:                               {
837:                                   lStickDiffMix = !lStickDiffMix;
00529C  EE0AF8     NEG lStickDiffMix, WREG
00529E  B70AF8     IOR lStickDiffMix, WREG
0052A0  DE004F     LSR W0, #15, W0
0052A2  100061     SUBR W0, #0x1, W0
0052A4  8857C0     MOV W0, lStickDiffMix
838:                                   if (lStickDiffMix == TRUE) {
0052A6  500FE1     SUB W0, #0x1, [W15]
0052A8  3A0003     BRA NZ, 0x52B0
839:                                       UART2PrintString("Left Stick Differential Mix On.\n\r");
0052AA  288700     MOV #0x8870, W0
0052AC  0721E8     RCALL UART2PrintString
0052AE  370002     BRA 0x52B4
840:                                   }
841:                                   else {
842:                                       UART2PrintString("Left Stick Differential Mix Off.\n\r");
0052B0  288920     MOV #0x8892, W0
0052B2  0721E5     RCALL UART2PrintString
843:                                   }
844:                               }
845:                           }
846:                           //Right Stick Settings
847:                           if (index == R_STICK_X || index == R_STICK_Y) {
0052B4  ED8806     DEC2 index, WREG
0052B6  500FE1     SUB W0, #0x1, [W15]
0052B8  3E0013     BRA GTU, 0x52E0
848:                               if (GetNewPress()->cross) //Right Stick Differential Mix Enable/Disable
0052BA  071C27     RCALL GetNewPress
0052BC  9048C0     MOV.B [W0+12], W1
0052BE  FB8081     ZE W1, W1
0052C0  904850     MOV.B [W0+13], W0
0052C2  DD0048     SL W0, #8, W0
0052C4  700001     IOR W0, W1, W0
0052C6  32000C     BRA Z, 0x52E0
849:                               {
850:                                   rStickDiffMix = !rStickDiffMix;
0052C8  EE0AFA     NEG rStickDiffMix, WREG
0052CA  B70AFA     IOR rStickDiffMix, WREG
0052CC  DE004F     LSR W0, #15, W0
0052CE  100061     SUBR W0, #0x1, W0
0052D0  8857D0     MOV W0, rStickDiffMix
851:                                   if (rStickDiffMix == TRUE) {
0052D2  500FE1     SUB W0, #0x1, [W15]
0052D4  3A0003     BRA NZ, 0x52DC
852:                                       UART2PrintString("Right Stick Differential Mix On.\n\r");
0052D6  288B50     MOV #0x88B5, W0
0052D8  0721D2     RCALL UART2PrintString
0052DA  370002     BRA 0x52E0
853:                                   }
854:                                   else {
855:                                       UART2PrintString("Right Stick Differential Mix Off.\n\r");
0052DC  288D80     MOV #0x88D8, W0
0052DE  0721CF     RCALL UART2PrintString
856:                                   }
857:                               }
858:                           }
859:               
860:                           //Configurations valid for both sticks
861:                           if (GetNewPress()->square) //mecanum steering
0052E0  071C14     RCALL GetNewPress
0052E2  9048E0     MOV.B [W0+14], W1
0052E4  FB8081     ZE W1, W1
0052E6  904870     MOV.B [W0+15], W0
0052E8  DD0048     SL W0, #8, W0
0052EA  700001     IOR W0, W1, W0
0052EC  320014     BRA Z, 0x5316
862:                           {
863:                               mecanumSteering++;
864:                               mecanumSteering = mecanumSteering % 11;
0052EE  EC0802     INC mecanumSteering, WREG
0052F0  2000B2     MOV #0xB, W2
0052F2  090011     REPEAT #0x11
0052F4  D88002     DIV.UW W0, W2
0052F6  884011     MOV W1, mecanumSteering
865:               
866:                               switch (mecanumSteering) {
0052F8  E00001     CP0 W1
0052FA  320003     BRA Z, 0x5302
0052FC  508FE1     SUB W1, #0x1, [W15]
0052FE  3A0007     BRA NZ, 0x530E
005300  370003     BRA 0x5308
867:                                   case MECANUM_OFF:
868:                                       UART2PrintString("Mecanum Steering Mix Off.\n\r");
005302  288FC0     MOV #0x88FC, W0
005304  0721BC     RCALL UART2PrintString
005306  370007     BRA 0x5316
869:                                       break;
870:                                   case MECANUM_ON_NO_REMAP:
871:                                       UART2PrintString("Mecanum Steering Mix On.\n\r");
005308  289180     MOV #0x8918, W0
00530A  0721B9     RCALL UART2PrintString
00530C  370004     BRA 0x5316
872:                                       break;
873:                                   default:
874:                                       UART2PrintString("Mecanum Steering Mix On, remap right stick y-axis to ");
00530E  289330     MOV #0x8933, W0
005310  0721B6     RCALL UART2PrintString
875:                                       PrintIndexLabel(mecanumSteering + 2);
005312  EC8802     INC2 mecanumSteering, WREG
005314  0709BD     RCALL PrintIndexLabel
876:                                       break;
877:                               }
878:                           }
879:               
880:                           if (GetNewPress()->circle) {
005316  071BF9     RCALL GetNewPress
005318  9048A0     MOV.B [W0+10], W1
00531A  FB8081     ZE W1, W1
00531C  904830     MOV.B [W0+11], W0
00531E  DD0048     SL W0, #8, W0
005320  700001     IOR W0, W1, W0
005322  32001A     BRA Z, 0x5358
881:                               ServoSettings[index].holdRecall++;
882:                               ServoSettings[index].holdRecall = ServoSettings[index].holdRecall % 3;
005324  804030     MOV index, W0
005326  B9007A     MUL.SU W0, #26, W0
005328  400076     ADD W0, #0x16, W0
00532A  209044     MOV #0x904, W4
00532C  7A0160     MOV [W0+W4], W2
00532E  E80102     INC W2, W2
005330  200033     MOV #0x3, W3
005332  781F80     MOV W0, [W15++]
005334  090011     REPEAT #0x11
005336  D88103     DIV.UW W2, W3
005338  78004F     MOV [--W15], W0
00533A  7A3001     MOV W1, [W0+W4]
883:                               switch (ServoSettings[index].holdRecall) {
00533C  508FE1     SUB W1, #0x1, [W15]
00533E  320007     BRA Z, 0x534E
005340  390003     BRA NC, 0x5348
005342  508FE2     SUB W1, #0x2, [W15]
005344  3A0009     BRA NZ, 0x5358
005346  370006     BRA 0x5354
884:                                   case OFF:
885:                                       UART2PrintString("Stick Hold/Recall disabled.\n\r");
005348  289690     MOV #0x8969, W0
00534A  072199     RCALL UART2PrintString
00534C  370005     BRA 0x5358
886:                                       break;
887:                                   case L_STICK:
888:                                       UART2PrintString("Stick Hold/Recall tied to L-Stick Button.\n\r");
00534E  289870     MOV #0x8987, W0
005350  072196     RCALL UART2PrintString
005352  370002     BRA 0x5358
889:                                       break;
890:                                   case R_STICK:
891:                                       UART2PrintString("Stick Hold/Recall tied to R-Stick Button.\n\r");
005354  289B30     MOV #0x89B3, W0
005356  072193     RCALL UART2PrintString
892:                                       break;
893:                                   default:
894:                                       break;
895:                               }
896:                           }
897:               
898:                           //Set RC Servo/PWM mode
899:                           if (GetNewPress()->lBumper) {
005358  071BD8     RCALL GetNewPress
00535A  370179     BRA 0x564E
900:               
901:                           }
902:                       }//end settings if L-Stick is held down
903:               
904:                           /////////////////////If neither stick is depressed while configuring servos/////////////////////////////////
905:                       else //if LSTick or RStick are not held down
906:                       {
907:                           //Increase offset
908:                           if (GetNewPress()->dPadRight || (GetPressDuration()->dPadRight > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00535C  071BD6     RCALL GetNewPress
00535E  9040A0     MOV.B [W0+2], W1
005360  FB8081     ZE W1, W1
005362  904030     MOV.B [W0+3], W0
005364  DD0048     SL W0, #8, W0
005366  700001     IOR W0, W1, W0
005368  3A000B     BRA NZ, 0x5380
00536A  071BCD     RCALL GetPressDuration
00536C  9040A0     MOV.B [W0+2], W1
00536E  FB8081     ZE W1, W1
005370  904030     MOV.B [W0+3], W0
005372  DD0048     SL W0, #8, W0
005374  700001     IOR W0, W1, W0
005376  200321     MOV #0x32, W1
005378  500F81     SUB W0, W1, [W15]
00537A  360018     BRA LEU, 0x53AC
00537C  AB0808     BTST cycleCounter, #0
00537E  3A0016     BRA NZ, 0x53AC
909:                               if (ServoSettings[index].offset < OFFSET_MAX) {
005380  804030     MOV index, W0
005382  B9007A     MUL.SU W0, #26, W0
005384  780080     MOV W0, W1
005386  209043     MOV #0x904, W3
005388  798160     MOV [W0+W3], W2
00538A  200C70     MOV #0xC7, W0
00538C  510F80     SUB W2, W0, [W15]
00538E  3C0003     BRA GT, 0x5396
910:                                   ServoSettings[index].offset++;
005390  E80002     INC W2, W0
005392  79B080     MOV W0, [W1+W3]
005394  370002     BRA 0x539A
911:                               }
912:                               else {
913:                                   UpdateRumbleFeedback(2);
005396  200020     MOV #0x2, W0
005398  071C92     RCALL UpdateRumbleFeedback
914:                               }
915:                               UART2PrintString("Range Offset = ");
00539A  289DF0     MOV #0x89DF, W0
00539C  072170     RCALL UART2PrintString
916:                               UART2PutDecSInt(ServoSettings[index].offset);
00539E  804030     MOV index, W0
0053A0  B9007A     MUL.SU W0, #26, W0
0053A2  209042     MOV #0x904, W2
0053A4  780062     MOV [W2+W0], W0
0053A6  0721E5     RCALL UART2PutDecSInt
917:                               UART2PrintString("\n\r");
0053A8  286F00     MOV #0x86F0, W0
0053AA  072169     RCALL UART2PrintString
918:                           }
919:               
920:                           //Decrease offset
921:                           if (GetNewPress()->dPadLeft || (GetPressDuration()->dPadLeft > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0053AC  071BAE     RCALL GetNewPress
0053AE  9040E0     MOV.B [W0+6], W1
0053B0  FB8081     ZE W1, W1
0053B2  904070     MOV.B [W0+7], W0
0053B4  DD0048     SL W0, #8, W0
0053B6  700001     IOR W0, W1, W0
0053B8  3A000B     BRA NZ, 0x53D0
0053BA  071BA5     RCALL GetPressDuration
0053BC  9040E0     MOV.B [W0+6], W1
0053BE  FB8081     ZE W1, W1
0053C0  904070     MOV.B [W0+7], W0
0053C2  DD0048     SL W0, #8, W0
0053C4  700001     IOR W0, W1, W0
0053C6  200321     MOV #0x32, W1
0053C8  500F81     SUB W0, W1, [W15]
0053CA  360018     BRA LEU, 0x53FC
0053CC  AB0808     BTST cycleCounter, #0
0053CE  3A0016     BRA NZ, 0x53FC
922:                               if (ServoSettings[index].offset > OFFSET_MIN) {
0053D0  804030     MOV index, W0
0053D2  B9007A     MUL.SU W0, #26, W0
0053D4  780080     MOV W0, W1
0053D6  209043     MOV #0x904, W3
0053D8  798160     MOV [W0+W3], W2
0053DA  2FF380     MOV #0xFF38, W0
0053DC  510F80     SUB W2, W0, [W15]
0053DE  340003     BRA LE, 0x53E6
923:                                   ServoSettings[index].offset--;
0053E0  E90002     DEC W2, W0
0053E2  79B080     MOV W0, [W1+W3]
0053E4  370002     BRA 0x53EA
924:                               }
925:                               else {
926:                                   UpdateRumbleFeedback(2);
0053E6  200020     MOV #0x2, W0
0053E8  071C6A     RCALL UpdateRumbleFeedback
927:                               }
928:                               UART2PrintString("Range Offset = ");
0053EA  289DF0     MOV #0x89DF, W0
0053EC  072148     RCALL UART2PrintString
929:                               UART2PutDecSInt(ServoSettings[index].offset);
0053EE  804030     MOV index, W0
0053F0  B9007A     MUL.SU W0, #26, W0
0053F2  209042     MOV #0x904, W2
0053F4  780062     MOV [W2+W0], W0
0053F6  0721BD     RCALL UART2PutDecSInt
930:                               UART2PrintString("\n\r");
0053F8  286F00     MOV #0x86F0, W0
0053FA  072141     RCALL UART2PrintString
931:                           }
932:               
933:                           //Increase range
934:                           if (GetNewPress()->dPadUp || (GetPressDuration()->dPadUp > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0053FC  071B86     RCALL GetNewPress
0053FE  FB8090     ZE [W0], W1
005400  904010     MOV.B [W0+1], W0
005402  DD0048     SL W0, #8, W0
005404  700001     IOR W0, W1, W0
005406  3A000A     BRA NZ, 0x541C
005408  071B7E     RCALL GetPressDuration
00540A  FB8090     ZE [W0], W1
00540C  904010     MOV.B [W0+1], W0
00540E  DD0048     SL W0, #8, W0
005410  700001     IOR W0, W1, W0
005412  200321     MOV #0x32, W1
005414  500F81     SUB W0, W1, [W15]
005416  360019     BRA LEU, 0x544A
005418  AB0808     BTST cycleCounter, #0
00541A  3A0017     BRA NZ, 0x544A
935:                               if (ServoSettings[index].range < RANGE_MAX) {
00541C  804030     MOV index, W0
00541E  B9007A     MUL.SU W0, #26, W0
005420  E88100     INC2 W0, W2
005422  209043     MOV #0x904, W3
005424  7980E2     MOV [W2+W3], W1
005426  200F90     MOV #0xF9, W0
005428  508F80     SUB W1, W0, [W15]
00542A  3C0003     BRA GT, 0x5432
936:                                   ServoSettings[index].range++;
00542C  E80001     INC W1, W0
00542E  79B100     MOV W0, [W2+W3]
005430  370002     BRA 0x5436
937:                               }
938:                               else {
939:                                   UpdateRumbleFeedback(2);
005432  200020     MOV #0x2, W0
005434  071C44     RCALL UpdateRumbleFeedback
940:                               }
941:                               UART2PrintString("Range = ");
005436  289EF0     MOV #0x89EF, W0
005438  072122     RCALL UART2PrintString
942:                               UART2PutDecSInt(ServoSettings[index].range);
00543A  804030     MOV index, W0
00543C  B9007A     MUL.SU W0, #26, W0
00543E  E88000     INC2 W0, W0
005440  209042     MOV #0x904, W2
005442  790060     MOV [W0+W2], W0
005444  072196     RCALL UART2PutDecSInt
943:                               UART2PrintString("\n\r");
005446  286F00     MOV #0x86F0, W0
005448  07211A     RCALL UART2PrintString
944:                           }
945:               
946:                           //Decrease range
947:                           if (GetNewPress()->dPadDown || (GetPressDuration()->dPadDown > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00544A  071B5F     RCALL GetNewPress
00544C  9040C0     MOV.B [W0+4], W1
00544E  FB8081     ZE W1, W1
005450  904050     MOV.B [W0+5], W0
005452  DD0048     SL W0, #8, W0
005454  700001     IOR W0, W1, W0
005456  3A000B     BRA NZ, 0x546E
005458  071B56     RCALL GetPressDuration
00545A  9040C0     MOV.B [W0+4], W1
00545C  FB8081     ZE W1, W1
00545E  904050     MOV.B [W0+5], W0
005460  DD0048     SL W0, #8, W0
005462  700001     IOR W0, W1, W0
005464  200321     MOV #0x32, W1
005466  500F81     SUB W0, W1, [W15]
005468  360018     BRA LEU, 0x549A
00546A  AB0808     BTST cycleCounter, #0
00546C  3A0016     BRA NZ, 0x549A
948:                               if (ServoSettings[index].range > RANGE_MIN) {
00546E  804030     MOV index, W0
005470  B9007A     MUL.SU W0, #26, W0
005472  E88080     INC2 W0, W1
005474  209042     MOV #0x904, W2
005476  790061     MOV [W1+W2], W0
005478  E00000     CP0 W0
00547A  340003     BRA LE, 0x5482
949:                                   ServoSettings[index].range--;
00547C  E90000     DEC W0, W0
00547E  793080     MOV W0, [W1+W2]
005480  370002     BRA 0x5486
950:                               }
951:                               else {
952:                                   UpdateRumbleFeedback(2);
005482  200020     MOV #0x2, W0
005484  071C1C     RCALL UpdateRumbleFeedback
953:                               }
954:                               UART2PrintString("Range = ");
005486  289EF0     MOV #0x89EF, W0
005488  0720FA     RCALL UART2PrintString
955:                               UART2PutDecSInt(ServoSettings[index].range);
00548A  804030     MOV index, W0
00548C  B9007A     MUL.SU W0, #26, W0
00548E  E88000     INC2 W0, W0
005490  209042     MOV #0x904, W2
005492  790060     MOV [W0+W2], W0
005494  07216E     RCALL UART2PutDecSInt
956:                               UART2PrintString("\n\r");
005496  286F00     MOV #0x86F0, W0
005498  0720F2     RCALL UART2PrintString
957:                           }
958:               
959:                           //Increase deadband
960:                           if (GetNewPress()->circle || (GetPressDuration()->circle > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00549A  071B37     RCALL GetNewPress
00549C  9048A0     MOV.B [W0+10], W1
00549E  FB8081     ZE W1, W1
0054A0  904830     MOV.B [W0+11], W0
0054A2  DD0048     SL W0, #8, W0
0054A4  700001     IOR W0, W1, W0
0054A6  3A000B     BRA NZ, 0x54BE
0054A8  071B2E     RCALL GetPressDuration
0054AA  9048A0     MOV.B [W0+10], W1
0054AC  FB8081     ZE W1, W1
0054AE  904830     MOV.B [W0+11], W0
0054B0  DD0048     SL W0, #8, W0
0054B2  700001     IOR W0, W1, W0
0054B4  200321     MOV #0x32, W1
0054B6  500F81     SUB W0, W1, [W15]
0054B8  360019     BRA LEU, 0x54EC
0054BA  AB0808     BTST cycleCounter, #0
0054BC  3A0017     BRA NZ, 0x54EC
961:                               if (ServoSettings[index].deadband < DEADBAND_MAX) {
0054BE  804030     MOV index, W0
0054C0  B9007A     MUL.SU W0, #26, W0
0054C2  400164     ADD W0, #0x4, W2
0054C4  209043     MOV #0x904, W3
0054C6  7980E2     MOV [W2+W3], W1
0054C8  2007C0     MOV #0x7C, W0
0054CA  508F80     SUB W1, W0, [W15]
0054CC  3C0003     BRA GT, 0x54D4
962:                                   ServoSettings[index].deadband++;
0054CE  E80001     INC W1, W0
0054D0  79B100     MOV W0, [W2+W3]
0054D2  370002     BRA 0x54D8
963:                               }
964:                               else {
965:                                   UpdateRumbleFeedback(2);
0054D4  200020     MOV #0x2, W0
0054D6  071BF3     RCALL UpdateRumbleFeedback
966:                               }
967:                               UART2PrintString("Deadband = ");
0054D8  289F80     MOV #0x89F8, W0
0054DA  0720D1     RCALL UART2PrintString
968:                               UART2PutDecSInt(ServoSettings[index].deadband);
0054DC  804030     MOV index, W0
0054DE  B9007A     MUL.SU W0, #26, W0
0054E0  400064     ADD W0, #0x4, W0
0054E2  209042     MOV #0x904, W2
0054E4  790060     MOV [W0+W2], W0
0054E6  072145     RCALL UART2PutDecSInt
969:                               UART2PrintString("\n\r");
0054E8  286F00     MOV #0x86F0, W0
0054EA  0720C9     RCALL UART2PrintString
970:                           }
971:               
972:                           //Decrease deadband
973:                           if (GetNewPress()->square || (GetPressDuration()->square > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0054EC  071B0E     RCALL GetNewPress
0054EE  9048E0     MOV.B [W0+14], W1
0054F0  FB8081     ZE W1, W1
0054F2  904870     MOV.B [W0+15], W0
0054F4  DD0048     SL W0, #8, W0
0054F6  700001     IOR W0, W1, W0
0054F8  3A000B     BRA NZ, 0x5510
0054FA  071B05     RCALL GetPressDuration
0054FC  9048E0     MOV.B [W0+14], W1
0054FE  FB8081     ZE W1, W1
005500  904870     MOV.B [W0+15], W0
005502  DD0048     SL W0, #8, W0
005504  700001     IOR W0, W1, W0
005506  200321     MOV #0x32, W1
005508  500F81     SUB W0, W1, [W15]
00550A  360018     BRA LEU, 0x553C
00550C  AB0808     BTST cycleCounter, #0
00550E  3A0016     BRA NZ, 0x553C
974:                               if (ServoSettings[index].deadband > DEADBAND_MIN) {
005510  804030     MOV index, W0
005512  B9007A     MUL.SU W0, #26, W0
005514  4000E4     ADD W0, #0x4, W1
005516  209042     MOV #0x904, W2
005518  790061     MOV [W1+W2], W0
00551A  E00000     CP0 W0
00551C  340003     BRA LE, 0x5524
975:                                   ServoSettings[index].deadband--;
00551E  E90000     DEC W0, W0
005520  793080     MOV W0, [W1+W2]
005522  370002     BRA 0x5528
976:                               }
977:                               else {
978:                                   UpdateRumbleFeedback(2);
005524  200020     MOV #0x2, W0
005526  071BCB     RCALL UpdateRumbleFeedback
979:                               }
980:                               UART2PrintString("Deadband = ");
005528  289F80     MOV #0x89F8, W0
00552A  0720A9     RCALL UART2PrintString
981:                               UART2PutDecSInt(ServoSettings[index].deadband);
00552C  804030     MOV index, W0
00552E  B9007A     MUL.SU W0, #26, W0
005530  400064     ADD W0, #0x4, W0
005532  209042     MOV #0x904, W2
005534  790060     MOV [W0+W2], W0
005536  07211D     RCALL UART2PutDecSInt
982:                               UART2PrintString("\n\r");
005538  286F00     MOV #0x86F0, W0
00553A  0720A1     RCALL UART2PrintString
983:                           }
984:                           //Increase sensitivity
985:                           if (GetNewPress()->triangle || (GetPressDuration()->triangle > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00553C  071AE6     RCALL GetNewPress
00553E  904880     MOV.B [W0+8], W1
005540  FB8081     ZE W1, W1
005542  904810     MOV.B [W0+9], W0
005544  DD0048     SL W0, #8, W0
005546  700001     IOR W0, W1, W0
005548  3A000B     BRA NZ, 0x5560
00554A  071ADD     RCALL GetPressDuration
00554C  904880     MOV.B [W0+8], W1
00554E  FB8081     ZE W1, W1
005550  904810     MOV.B [W0+9], W0
005552  DD0048     SL W0, #8, W0
005554  700001     IOR W0, W1, W0
005556  200321     MOV #0x32, W1
005558  500F81     SUB W0, W1, [W15]
00555A  360019     BRA LEU, 0x558E
00555C  AB0808     BTST cycleCounter, #0
00555E  3A0017     BRA NZ, 0x558E
986:                               if (ServoSettings[index].sensitivity < SENSITIVITY_MAX) {
005560  804030     MOV index, W0
005562  B9007A     MUL.SU W0, #26, W0
005564  400166     ADD W0, #0x6, W2
005566  209043     MOV #0x904, W3
005568  7980E2     MOV [W2+W3], W1
00556A  200C70     MOV #0xC7, W0
00556C  508F80     SUB W1, W0, [W15]
00556E  3C0003     BRA GT, 0x5576
987:                                   ServoSettings[index].sensitivity++;
005570  E80001     INC W1, W0
005572  79B100     MOV W0, [W2+W3]
005574  370002     BRA 0x557A
988:                               }
989:                               else {
990:                                   UpdateRumbleFeedback(2);
005576  200020     MOV #0x2, W0
005578  071BA2     RCALL UpdateRumbleFeedback
991:                               }
992:                               UART2PrintString("Sensitivity = ");
00557A  28A040     MOV #0x8A04, W0
00557C  072080     RCALL UART2PrintString
993:                               UART2PutDecSInt(ServoSettings[index].sensitivity);
00557E  804030     MOV index, W0
005580  B9007A     MUL.SU W0, #26, W0
005582  400066     ADD W0, #0x6, W0
005584  209042     MOV #0x904, W2
005586  790060     MOV [W0+W2], W0
005588  0720F4     RCALL UART2PutDecSInt
994:                               UART2PrintString("\n\r");
00558A  286F00     MOV #0x86F0, W0
00558C  072078     RCALL UART2PrintString
995:                           }
996:               
997:                           //Decrease sensitivity
998:                           if (GetNewPress()->cross || (GetPressDuration()->cross > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
00558E  071ABD     RCALL GetNewPress
005590  9048C0     MOV.B [W0+12], W1
005592  FB8081     ZE W1, W1
005594  904850     MOV.B [W0+13], W0
005596  DD0048     SL W0, #8, W0
005598  700001     IOR W0, W1, W0
00559A  3A000B     BRA NZ, 0x55B2
00559C  071AB4     RCALL GetPressDuration
00559E  9048C0     MOV.B [W0+12], W1
0055A0  FB8081     ZE W1, W1
0055A2  904850     MOV.B [W0+13], W0
0055A4  DD0048     SL W0, #8, W0
0055A6  700001     IOR W0, W1, W0
0055A8  200321     MOV #0x32, W1
0055AA  500F81     SUB W0, W1, [W15]
0055AC  360018     BRA LEU, 0x55DE
0055AE  AB0808     BTST cycleCounter, #0
0055B0  3A0016     BRA NZ, 0x55DE
999:                               if (ServoSettings[index].sensitivity > SENSITIVITY_MIN) {
0055B2  804030     MOV index, W0
0055B4  B9007A     MUL.SU W0, #26, W0
0055B6  4000E6     ADD W0, #0x6, W1
0055B8  209042     MOV #0x904, W2
0055BA  790061     MOV [W1+W2], W0
0055BC  500FE1     SUB W0, #0x1, [W15]
0055BE  340003     BRA LE, 0x55C6
1000:                                  ServoSettings[index].sensitivity--;
0055C0  E90000     DEC W0, W0
0055C2  793080     MOV W0, [W1+W2]
0055C4  370002     BRA 0x55CA
1001:                              }
1002:                              else {
1003:                                  UpdateRumbleFeedback(2);
0055C6  200020     MOV #0x2, W0
0055C8  071B7A     RCALL UpdateRumbleFeedback
1004:                              }
1005:                              UART2PrintString("Sensitivity = ");
0055CA  28A040     MOV #0x8A04, W0
0055CC  072058     RCALL UART2PrintString
1006:                              UART2PutDecSInt(ServoSettings[index].sensitivity);
0055CE  804030     MOV index, W0
0055D0  B9007A     MUL.SU W0, #26, W0
0055D2  400066     ADD W0, #0x6, W0
0055D4  209042     MOV #0x904, W2
0055D6  790060     MOV [W0+W2], W0
0055D8  0720CC     RCALL UART2PutDecSInt
1007:                              UART2PrintString("\n\r");
0055DA  286F00     MOV #0x86F0, W0
0055DC  072050     RCALL UART2PrintString
1008:                          }
1009:              
1010:                          //Recalibration
1011:                          if (GetNewPress()->psButton) {
0055DE  071A95     RCALL GetNewPress
0055E0  9060A0     MOV.B [W0+34], W1
0055E2  FB8081     ZE W1, W1
0055E4  906030     MOV.B [W0+35], W0
0055E6  DD0048     SL W0, #8, W0
0055E8  700001     IOR W0, W1, W0
0055EA  320015     BRA Z, 0x5616
1012:                              ServoSettings[index].zeroPosition = GetAnalogs()->array[index];
0055EC  071A90     RCALL GetAnalogs
0055EE  804031     MOV index, W1
0055F0  B9097A     MUL.SU W1, #26, W2
0055F2  410174     ADD W2, #0x14, W2
0055F4  209048     MOV #0x904, W8
0055F6  408081     ADD W1, W1, W1
0055F8  408080     ADD W1, W0, W1
0055FA  FB8211     ZE [W1], W4
0055FC  904011     MOV.B [W1+1], W0
0055FE  DD0048     SL W0, #8, W0
005600  700004     IOR W0, W4, W0
005602  7C3100     MOV W0, [W2+W8]
1013:                              UART2PrintString("Home Position = ");
005604  28A130     MOV #0x8A13, W0
005606  07203B     RCALL UART2PrintString
1014:                              UART2PutDecInt(ServoSettings[index].zeroPosition);
005608  804030     MOV index, W0
00560A  B9007A     MUL.SU W0, #26, W0
00560C  400074     ADD W0, #0x14, W0
00560E  7C0060     MOV [W0+W8], W0
005610  072084     RCALL UART2PutDecInt
1015:                              UART2PrintString("\n\r");
005612  286F00     MOV #0x86F0, W0
005614  072034     RCALL UART2PrintString
1016:                          }
1017:                          if (GetPressDuration()->psButton == 100) {
005616  071A77     RCALL GetPressDuration
005618  9060A0     MOV.B [W0+34], W1
00561A  FB8081     ZE W1, W1
00561C  906030     MOV.B [W0+35], W0
00561E  DD0048     SL W0, #8, W0
005620  700001     IOR W0, W1, W0
005622  200641     MOV #0x64, W1
005624  500F81     SUB W0, W1, [W15]
005626  3A0013     BRA NZ, 0x564E
1018:                              unsigned int i;
1019:                              UART2PrintString("Calibrating All Home Positions...");
005628  28A240     MOV #0x8A24, W0
00562A  072029     RCALL UART2PrintString
00562C  EB0400     CLR W8
00562E  209189     MOV #0x918, W9
1020:                              for (i = 0; i < NUM_SERVOS; i++) {
00563E  E80408     INC W8, W8
005640  4484FA     ADD W9, #0x1A, W9
005642  540FEC     SUB W8, #0xC, [W15]
005644  3AFFF5     BRA NZ, 0x5630
1021:                                  ServoSettings[i].zeroPosition = GetAnalogs()->array[i];
005630  071A6E     RCALL GetAnalogs
005632  440088     ADD W8, W8, W1
005634  408080     ADD W1, W0, W1
005636  FB8111     ZE [W1], W2
005638  904011     MOV.B [W1+1], W0
00563A  DD0048     SL W0, #8, W0
00563C  700C82     IOR W0, W2, [W9]
1022:                              }
1023:                              UART2PrintString("Done.\n\r");
005646  285940     MOV #0x8594, W0
005648  07201A     RCALL UART2PrintString
1024:                              UpdateRumbleFeedback(10);
00564A  2000A0     MOV #0xA, W0
00564C  071B38     RCALL UpdateRumbleFeedback
1025:                          }
1026:                      }//end if rStick is not pressed
1027:                  }// if i<NUM_SERVOS
1028:              
1029:                  ////////////////SET BUTTONS///////////////////////
1030:                  if (index >= NUM_SERVOS && index < (NUM_SERVOS + NUM_BUTTONS)) {
00564E  804030     MOV index, W0
005650  50046C     SUB W0, #0xC, W8
005652  200010     MOV #0x1, W0
005654  540FF1     SUB W8, #0x11, [W15]
005656  3E0157     BRA GTU, 0x5906
1031:                      unsigned int buttonIndex;
1032:                      buttonIndex = index - NUM_SERVOS;
1033:              
1034:                      if (GetButtonPress()->rStickPress && !GetButtonPress()->lStickPress) {
005658  071A54     RCALL GetButtonPress
00565A  9058A0     MOV.B [W0+26], W1
00565C  FB8081     ZE W1, W1
00565E  905830     MOV.B [W0+27], W0
005660  DD0048     SL W0, #8, W0
005662  700001     IOR W0, W1, W0
005664  320007     BRA Z, 0x5674
005666  071A4D     RCALL GetButtonPress
005668  905880     MOV.B [W0+24], W1
00566A  FB8081     ZE W1, W1
00566C  905810     MOV.B [W0+25], W0
00566E  DD0048     SL W0, #8, W0
005670  700001     IOR W0, W1, W0
005672  320145     BRA Z, 0x58FE
1035:                      }//if right stick is held
1036:                      else if (GetButtonPress()->lStickPress && !GetButtonPress()->rStickPress) {
005674  071A46     RCALL GetButtonPress
005676  905880     MOV.B [W0+24], W1
005678  FB8081     ZE W1, W1
00567A  905810     MOV.B [W0+25], W0
00567C  DD0048     SL W0, #8, W0
00567E  700001     IOR W0, W1, W0
005680  320007     BRA Z, 0x5690
005682  071A3F     RCALL GetButtonPress
005684  9058A0     MOV.B [W0+26], W1
005686  FB8081     ZE W1, W1
005688  905830     MOV.B [W0+27], W0
00568A  DD0048     SL W0, #8, W0
00568C  700001     IOR W0, W1, W0
00568E  320137     BRA Z, 0x58FE
1037:                      }//if left stick is held
1038:                      else //if neither stick is held
1039:                      {
1040:                          //set invert
1041:                          if (GetNewPress()->cross) {
005690  071A3C     RCALL GetNewPress
005692  9048C0     MOV.B [W0+12], W1
005694  FB8081     ZE W1, W1
005696  904850     MOV.B [W0+13], W0
005698  DD0048     SL W0, #8, W0
00569A  700001     IOR W0, W1, W0
00569C  320011     BRA Z, 0x56C0
1042:                              ButtonSettings[buttonIndex].invert = !ButtonSettings[buttonIndex].invert;
00569E  EB0100     CLR W2
0056A0  DD4043     SL W8, #3, W0
0056A2  20A3C1     MOV #0xA3C, W1
0056A4  788060     MOV [W0+W1], W0
0056A6  E00000     CP0 W0
0056A8  3A0001     BRA NZ, 0x56AC
0056AA  200012     MOV #0x1, W2
0056AC  DD40C3     SL W8, #3, W1
0056AE  20A3C0     MOV #0xA3C, W0
0056B0  783082     MOV W2, [W1+W0]
1043:                              if (ButtonSettings[buttonIndex].invert == TRUE) {
0056B2  510FE1     SUB W2, #0x1, [W15]
0056B4  3A0003     BRA NZ, 0x56BC
1044:                                  UART2PrintString("Output Inverted.\n\r");
0056B6  28A460     MOV #0x8A46, W0
0056B8  071FE2     RCALL UART2PrintString
0056BA  370002     BRA 0x56C0
1045:                              }
1046:                              else {
1047:                                  UART2PrintString("Output Normal.\n\r");
0056BC  28A590     MOV #0x8A59, W0
0056BE  071FDF     RCALL UART2PrintString
1048:                              }
1049:                          }
1050:              
1051:                          if (GetNewPress()->triangle) {
0056C0  071A24     RCALL GetNewPress
0056C2  904880     MOV.B [W0+8], W1
0056C4  FB8081     ZE W1, W1
0056C6  904810     MOV.B [W0+9], W0
0056C8  DD0048     SL W0, #8, W0
0056CA  700001     IOR W0, W1, W0
0056CC  32003B     BRA Z, 0x5744
1052:                              //set output style
1053:                              switch (ButtonSettings[buttonIndex].outputMode) {
0056CE  DD4043     SL W8, #3, W0
0056D0  E88000     INC2 W0, W0
0056D2  20A3C1     MOV #0xA3C, W1
0056D4  788060     MOV [W0+W1], W0
0056D6  500FE2     SUB W0, #0x2, [W15]
0056D8  32001B     BRA Z, 0x5710
0056DA  3E0005     BRA GTU, 0x56E6
0056DC  E00000     CP0 W0
0056DE  320008     BRA Z, 0x56F0
0056E0  500FE1     SUB W0, #0x1, [W15]
0056E2  3A002E     BRA NZ, 0x5740
0056E4  37000D     BRA 0x5700
0056E6  500FE3     SUB W0, #0x3, [W15]
0056E8  32001B     BRA Z, 0x5720
0056EA  500FE4     SUB W0, #0x4, [W15]
0056EC  3A0029     BRA NZ, 0x5740
0056EE  370020     BRA 0x5730
1054:                                  case PUSHBUTTON:
1055:                                      ButtonSettings[buttonIndex].outputMode = TOGGLE;
0056F0  DD4043     SL W8, #3, W0
0056F2  E88000     INC2 W0, W0
0056F4  200012     MOV #0x1, W2
0056F6  20A3C1     MOV #0xA3C, W1
0056F8  78B002     MOV W2, [W0+W1]
1056:                                      UART2PrintString("Output Toggle.\n\r");
0056FA  28A6A0     MOV #0x8A6A, W0
0056FC  071FC0     RCALL UART2PrintString
0056FE  370022     BRA 0x5744
1057:                                      break;
1058:              
1059:                                  case TOGGLE:
1060:                                      ButtonSettings[buttonIndex].outputMode = SINGLE_SHOT;
005700  DD4043     SL W8, #3, W0
005702  E88000     INC2 W0, W0
005704  200022     MOV #0x2, W2
005706  20A3C1     MOV #0xA3C, W1
005708  78B002     MOV W2, [W0+W1]
1061:                                      UART2PrintString("Output Single Shot.\n\r");
00570A  28A7B0     MOV #0x8A7B, W0
00570C  071FB8     RCALL UART2PrintString
00570E  37001A     BRA 0x5744
1062:                                      break;
1063:              
1064:                                  case SINGLE_SHOT:
1065:                                      ButtonSettings[buttonIndex].outputMode = AUTOFIRE;
005710  DD4043     SL W8, #3, W0
005712  E88000     INC2 W0, W0
005714  200032     MOV #0x3, W2
005716  20A3C1     MOV #0xA3C, W1
005718  78B002     MOV W2, [W0+W1]
1066:                                      UART2PrintString("Output Autofire.\n\r");
00571A  28A910     MOV #0x8A91, W0
00571C  071FB0     RCALL UART2PrintString
00571E  370012     BRA 0x5744
1067:                                      break;
1068:              
1069:                                  case AUTOFIRE:
1070:                                      ButtonSettings[buttonIndex].outputMode = TOGGLE_AUTOFIRE;
005720  DD4043     SL W8, #3, W0
005722  E88000     INC2 W0, W0
005724  200042     MOV #0x4, W2
005726  20A3C1     MOV #0xA3C, W1
005728  78B002     MOV W2, [W0+W1]
1071:                                      UART2PrintString("Output Toggle Autofire.\n\r");
00572A  28AA40     MOV #0x8AA4, W0
00572C  071FA8     RCALL UART2PrintString
00572E  37000A     BRA 0x5744
1072:                                      break;
1073:              
1074:                                  case TOGGLE_AUTOFIRE:
1075:                                      ButtonSettings[buttonIndex].outputMode = PUSHBUTTON;
005730  DD4043     SL W8, #3, W0
005732  E88000     INC2 W0, W0
005734  EB0100     CLR W2
005736  20A3C1     MOV #0xA3C, W1
005738  78B002     MOV W2, [W0+W1]
1076:                                      UART2PrintString("Output Pushbutton.\n\r");
00573A  28ABE0     MOV #0x8ABE, W0
00573C  071FA0     RCALL UART2PrintString
00573E  370002     BRA 0x5744
1077:                                      break;
1078:              
1079:                                  default:
1080:                                      UART2PrintString("ERROR OUTPUT MODE.\n\r");
005740  28AD30     MOV #0x8AD3, W0
005742  071F9D     RCALL UART2PrintString
1081:                                      break;
1082:                              }
1083:                          }
1084:              
1085:                          //Increase pulse width
1086:                          if ((GetPressDuration()->dPadRight > FAST_AUTOCLICK_DELAY)&&\
005744  0719E0     RCALL GetPressDuration
005746  9040A0     MOV.B [W0+2], W1
005748  FB8081     ZE W1, W1
00574A  904030     MOV.B [W0+3], W0
00574C  DD0048     SL W0, #8, W0
00574E  700001     IOR W0, W1, W0
005750  203E81     MOV #0x3E8, W1
005752  500F81     SUB W0, W1, [W15]
005754  360009     BRA LEU, 0x5768
005756  DD4043     SL W8, #3, W0
005758  400164     ADD W0, #0x4, W2
00575A  20A3C3     MOV #0xA3C, W3
00575C  7980E2     MOV [W2+W3], W1
00575E  2EA550     MOV #0xEA55, W0
005760  508F80     SUB W1, W0, [W15]
005762  3E0002     BRA GTU, 0x5768
1087:                              (ButtonSettings[buttonIndex].pulseWidth < (PULSE_WIDTH_MAX - FAST_AUTOCLICK_SIZE))) {
1088:                              ButtonSettings[buttonIndex].pulseWidth += FAST_AUTOCLICK_SIZE;
005764  40806A     ADD W1, #0xA, W0
005766  79B100     MOV W0, [W2+W3]
1089:                          }
1090:                          if (GetNewPress()->dPadRight || (GetPressDuration()->dPadRight > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
005768  0719D0     RCALL GetNewPress
00576A  9040A0     MOV.B [W0+2], W1
00576C  FB8081     ZE W1, W1
00576E  904030     MOV.B [W0+3], W0
005770  DD0048     SL W0, #8, W0
005772  700001     IOR W0, W1, W0
005774  3A000B     BRA NZ, 0x578C
005776  0719C7     RCALL GetPressDuration
005778  9040A0     MOV.B [W0+2], W1
00577A  FB8081     ZE W1, W1
00577C  904030     MOV.B [W0+3], W0
00577E  DD0048     SL W0, #8, W0
005780  700001     IOR W0, W1, W0
005782  200321     MOV #0x32, W1
005784  500F81     SUB W0, W1, [W15]
005786  360017     BRA LEU, 0x57B6
005788  AB0808     BTST cycleCounter, #0
00578A  3A0015     BRA NZ, 0x57B6
1091:                              if (ButtonSettings[buttonIndex].pulseWidth < PULSE_WIDTH_MAX) {
00578C  DD4043     SL W8, #3, W0
00578E  400164     ADD W0, #0x4, W2
005790  20A3C3     MOV #0xA3C, W3
005792  7980E2     MOV [W2+W3], W1
005794  2EA5F0     MOV #0xEA5F, W0
005796  508F80     SUB W1, W0, [W15]
005798  3E0003     BRA GTU, 0x57A0
1092:                                  ButtonSettings[buttonIndex].pulseWidth++;
00579A  E80001     INC W1, W0
00579C  79B100     MOV W0, [W2+W3]
00579E  370002     BRA 0x57A4
1093:                              }
1094:                              else {
1095:                                  UpdateRumbleFeedback(2);
0057A0  200020     MOV #0x2, W0
0057A2  071A8D     RCALL UpdateRumbleFeedback
1096:                              }
1097:                              UART2PrintString("PulseWidth = ");
0057A4  28AE80     MOV #0x8AE8, W0
0057A6  071F6B     RCALL UART2PrintString
1098:                              UART2PutDecInt(ButtonSettings[buttonIndex].pulseWidth);
0057A8  DD4043     SL W8, #3, W0
0057AA  400064     ADD W0, #0x4, W0
0057AC  20A3C1     MOV #0xA3C, W1
0057AE  788060     MOV [W0+W1], W0
0057B0  071FB4     RCALL UART2PutDecInt
1099:                              UART2PrintString("0 ms\n\r");
0057B2  28AF60     MOV #0x8AF6, W0
0057B4  071F64     RCALL UART2PrintString
1100:                          }
1101:              
1102:                          //Decrease pulse width
1103:                          if ((GetPressDuration()->dPadLeft > FAST_AUTOCLICK_DELAY)&&\
0057B6  0719A7     RCALL GetPressDuration
0057B8  9040E0     MOV.B [W0+6], W1
0057BA  FB8081     ZE W1, W1
0057BC  904070     MOV.B [W0+7], W0
0057BE  DD0048     SL W0, #8, W0
0057C0  700001     IOR W0, W1, W0
0057C2  203E81     MOV #0x3E8, W1
0057C4  500F81     SUB W0, W1, [W15]
0057C6  360008     BRA LEU, 0x57D8
0057C8  DD4043     SL W8, #3, W0
0057CA  4000E4     ADD W0, #0x4, W1
0057CC  20A3C2     MOV #0xA3C, W2
0057CE  790061     MOV [W1+W2], W0
0057D0  500FEB     SUB W0, #0xB, [W15]
0057D2  360002     BRA LEU, 0x57D8
1104:                              (ButtonSettings[buttonIndex].pulseWidth > (PULSE_WIDTH_MIN + FAST_AUTOCLICK_SIZE))) {
1105:                              ButtonSettings[buttonIndex].pulseWidth -= FAST_AUTOCLICK_SIZE;
0057D4  50006A     SUB W0, #0xA, W0
0057D6  793080     MOV W0, [W1+W2]
1106:                          }
1107:                          if (GetNewPress()->dPadLeft || (GetPressDuration()->dPadLeft > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0057D8  071998     RCALL GetNewPress
0057DA  9040E0     MOV.B [W0+6], W1
0057DC  FB8081     ZE W1, W1
0057DE  904070     MOV.B [W0+7], W0
0057E0  DD0048     SL W0, #8, W0
0057E2  700001     IOR W0, W1, W0
0057E4  3A000B     BRA NZ, 0x57FC
0057E6  07198F     RCALL GetPressDuration
0057E8  9040E0     MOV.B [W0+6], W1
0057EA  FB8081     ZE W1, W1
0057EC  904070     MOV.B [W0+7], W0
0057EE  DD0048     SL W0, #8, W0
0057F0  700001     IOR W0, W1, W0
0057F2  200321     MOV #0x32, W1
0057F4  500F81     SUB W0, W1, [W15]
0057F6  360016     BRA LEU, 0x5824
0057F8  AB0808     BTST cycleCounter, #0
0057FA  3A0014     BRA NZ, 0x5824
1108:                              if (ButtonSettings[buttonIndex].pulseWidth > PULSE_WIDTH_MIN) {
0057FC  DD4043     SL W8, #3, W0
0057FE  4000E4     ADD W0, #0x4, W1
005800  20A3C2     MOV #0xA3C, W2
005802  790061     MOV [W1+W2], W0
005804  500FE1     SUB W0, #0x1, [W15]
005806  360003     BRA LEU, 0x580E
1109:                                  ButtonSettings[buttonIndex].pulseWidth--;
005808  E90000     DEC W0, W0
00580A  793080     MOV W0, [W1+W2]
00580C  370002     BRA 0x5812
1110:                              }
1111:                              else {
1112:                                  UpdateRumbleFeedback(2);
00580E  200020     MOV #0x2, W0
005810  071A56     RCALL UpdateRumbleFeedback
1113:                              }
1114:                              UART2PrintString("PulseWidth = ");
005812  28AE80     MOV #0x8AE8, W0
005814  071F34     RCALL UART2PrintString
1115:                              UART2PutDecInt(ButtonSettings[buttonIndex].pulseWidth);
005816  DD4043     SL W8, #3, W0
005818  400064     ADD W0, #0x4, W0
00581A  20A3C1     MOV #0xA3C, W1
00581C  788060     MOV [W0+W1], W0
00581E  071F7D     RCALL UART2PutDecInt
1116:                              UART2PrintString("0 ms\n\r");
005820  28AF60     MOV #0x8AF6, W0
005822  071F2D     RCALL UART2PrintString
1117:                          }
1118:              
1119:                          //Increase Autofire Period
1120:                          if ((GetPressDuration()->dPadUp > FAST_AUTOCLICK_DELAY)&&\
005824  071970     RCALL GetPressDuration
005826  FB8090     ZE [W0], W1
005828  904010     MOV.B [W0+1], W0
00582A  DD0048     SL W0, #8, W0
00582C  700001     IOR W0, W1, W0
00582E  203E81     MOV #0x3E8, W1
005830  500F81     SUB W0, W1, [W15]
005832  360009     BRA LEU, 0x5846
005834  DD4043     SL W8, #3, W0
005836  400166     ADD W0, #0x6, W2
005838  20A3C3     MOV #0xA3C, W3
00583A  7980E2     MOV [W2+W3], W1
00583C  2EA550     MOV #0xEA55, W0
00583E  508F80     SUB W1, W0, [W15]
005840  3E0002     BRA GTU, 0x5846
1121:                              (ButtonSettings[buttonIndex].autofirePeriod < (AUTOFIRE_PERIOD_MAX - FAST_AUTOCLICK_SIZE))) {
1122:                              ButtonSettings[buttonIndex].autofirePeriod += FAST_AUTOCLICK_SIZE;
005842  40806A     ADD W1, #0xA, W0
005844  79B100     MOV W0, [W2+W3]
1123:                          }
1124:                          if (GetNewPress()->dPadUp || (GetPressDuration()->dPadUp > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
005846  071961     RCALL GetNewPress
005848  FB8090     ZE [W0], W1
00584A  904010     MOV.B [W0+1], W0
00584C  DD0048     SL W0, #8, W0
00584E  700001     IOR W0, W1, W0
005850  3A000A     BRA NZ, 0x5866
005852  071959     RCALL GetPressDuration
005854  FB8090     ZE [W0], W1
005856  904010     MOV.B [W0+1], W0
005858  DD0048     SL W0, #8, W0
00585A  700001     IOR W0, W1, W0
00585C  200321     MOV #0x32, W1
00585E  500F81     SUB W0, W1, [W15]
005860  360017     BRA LEU, 0x5890
005862  AB0808     BTST cycleCounter, #0
005864  3A0015     BRA NZ, 0x5890
1125:                              if (ButtonSettings[buttonIndex].autofirePeriod < AUTOFIRE_PERIOD_MAX) {
005866  DD4043     SL W8, #3, W0
005868  400166     ADD W0, #0x6, W2
00586A  20A3C3     MOV #0xA3C, W3
00586C  7980E2     MOV [W2+W3], W1
00586E  2EA5F0     MOV #0xEA5F, W0
005870  508F80     SUB W1, W0, [W15]
005872  3E0003     BRA GTU, 0x587A
1126:                                  ButtonSettings[buttonIndex].autofirePeriod++;
005874  E80001     INC W1, W0
005876  79B100     MOV W0, [W2+W3]
005878  370002     BRA 0x587E
1127:                              }
1128:                              else {
1129:                                  UpdateRumbleFeedback(2);
00587A  200020     MOV #0x2, W0
00587C  071A20     RCALL UpdateRumbleFeedback
1130:                              }
1131:                              UART2PrintString("Autofire Period = ");
00587E  28AFD0     MOV #0x8AFD, W0
005880  071EFE     RCALL UART2PrintString
1132:                              UART2PutDecInt(ButtonSettings[buttonIndex].autofirePeriod);
005882  DD4043     SL W8, #3, W0
005884  400066     ADD W0, #0x6, W0
005886  20A3C1     MOV #0xA3C, W1
005888  788060     MOV [W0+W1], W0
00588A  071F47     RCALL UART2PutDecInt
1133:                              UART2PrintString("0 ms\n\r");
00588C  28AF60     MOV #0x8AF6, W0
00588E  071EF7     RCALL UART2PrintString
1134:                          }
1135:              
1136:                          //Decrease Autofire Period
1137:                          if ((GetPressDuration()->dPadDown > FAST_AUTOCLICK_DELAY)&&\
005890  07193A     RCALL GetPressDuration
005892  9040C0     MOV.B [W0+4], W1
005894  FB8081     ZE W1, W1
005896  904050     MOV.B [W0+5], W0
005898  DD0048     SL W0, #8, W0
00589A  700001     IOR W0, W1, W0
00589C  203E81     MOV #0x3E8, W1
00589E  500F81     SUB W0, W1, [W15]
0058A0  360008     BRA LEU, 0x58B2
0058A2  DD4043     SL W8, #3, W0
0058A4  4000E6     ADD W0, #0x6, W1
0058A6  20A3C2     MOV #0xA3C, W2
0058A8  790061     MOV [W1+W2], W0
0058AA  500FEC     SUB W0, #0xC, [W15]
0058AC  360002     BRA LEU, 0x58B2
1138:                              (ButtonSettings[buttonIndex].autofirePeriod > (AUTOFIRE_PERIOD_MIN + FAST_AUTOCLICK_SIZE))) {
1139:                              ButtonSettings[buttonIndex].autofirePeriod -= FAST_AUTOCLICK_SIZE;
0058AE  50006A     SUB W0, #0xA, W0
0058B0  793080     MOV W0, [W1+W2]
1140:                          }
1141:                          if (GetNewPress()->dPadDown || (GetPressDuration()->dPadDown > AUTOCLICK_DELAY && !(cycleCounter % AUTOCLICK_TIMER))) {
0058B2  07192B     RCALL GetNewPress
0058B4  9040C0     MOV.B [W0+4], W1
0058B6  FB8081     ZE W1, W1
0058B8  904050     MOV.B [W0+5], W0
0058BA  DD0048     SL W0, #8, W0
0058BC  700001     IOR W0, W1, W0
0058BE  3A000B     BRA NZ, 0x58D6
0058C0  071922     RCALL GetPressDuration
0058C2  9040C0     MOV.B [W0+4], W1
0058C4  FB8081     ZE W1, W1
0058C6  904050     MOV.B [W0+5], W0
0058C8  DD0048     SL W0, #8, W0
0058CA  700001     IOR W0, W1, W0
0058CC  200321     MOV #0x32, W1
0058CE  500F81     SUB W0, W1, [W15]
0058D0  360016     BRA LEU, 0x58FE
0058D2  AB0808     BTST cycleCounter, #0
0058D4  3A0014     BRA NZ, 0x58FE
1142:                              if (ButtonSettings[buttonIndex].autofirePeriod > AUTOFIRE_PERIOD_MIN) {
0058D6  DD4043     SL W8, #3, W0
0058D8  4000E6     ADD W0, #0x6, W1
0058DA  20A3C2     MOV #0xA3C, W2
0058DC  790061     MOV [W1+W2], W0
0058DE  500FE2     SUB W0, #0x2, [W15]
0058E0  360003     BRA LEU, 0x58E8
1143:                                  ButtonSettings[buttonIndex].autofirePeriod--;
0058E2  E90000     DEC W0, W0
0058E4  793080     MOV W0, [W1+W2]
0058E6  370002     BRA 0x58EC
1144:                              }
1145:                              else {
1146:                                  UpdateRumbleFeedback(2);
0058E8  200020     MOV #0x2, W0
0058EA  0719E9     RCALL UpdateRumbleFeedback
1147:                              }
1148:                              UART2PrintString("Autofire Period = ");
0058EC  28AFD0     MOV #0x8AFD, W0
0058EE  071EC7     RCALL UART2PrintString
1149:                              UART2PutDecInt(ButtonSettings[buttonIndex].autofirePeriod);
0058F0  DD4043     SL W8, #3, W0
0058F2  400066     ADD W0, #0x6, W0
0058F4  20A3C1     MOV #0xA3C, W1
0058F6  788060     MOV [W0+W1], W0
0058F8  071F10     RCALL UART2PutDecInt
1150:                              UART2PrintString("0 ms\n\r");
0058FA  28AF60     MOV #0x8AF6, W0
0058FC  071EC0     RCALL UART2PrintString
1151:                          }
1152:                      }
1153:                      UpdateButtonOutputs(configFlag, buttonIndex);
0058FE  780088     MOV W8, W1
005900  78000A     MOV W10, W0
005902  070004     RCALL UpdateButtonOutputs
005904  200010     MOV #0x1, W0
1154:                  }
1155:                  return TRUE;
1156:              }
005906  78054F     MOV [--W15], W10
005908  BE044F     MOV.D [--W15], W8
00590A  060000     RETURN
1157:              
1158:              /*******************************************************************************
1159:              Function: UpdateButtonOutputs(unsigned int configFlag, unsigned int configIndex)
1160:              
1161:              Precondition:
1162:                  Must have run all the UpdateNewPress() and UpdatePS4ButtonDuration() routines.
1163:              
1164:              Overview:
1165:                  This routine updates the outputs for button presses.
1166:              
1167:              Input: configFlag: informs the routine if configuration mode is active or not.
1168:               * 0: config mode not active
1169:               * 1: config mode active
1170:               * 2: config mode not active, but re-initialize the button toggle states
1171:               *
1172:               If config mode is active, outputs are activated by the right stick
1173:               press button only to avoid conflicts with button functions.
1174:              
1175:              Output: None.
1176:              
1177:               *******************************************************************************/
1178:              void UpdateButtonOutputs(unsigned int configFlag, unsigned int configIndex) {
00590C  B0028F     ADD #0x28, W15
00590E  BE9F88     MOV.D W8, [W15++]
005910  BE9F8A     MOV.D W10, [W15++]
005912  BE9F8C     MOV.D W12, [W15++]
005914  781F8E     MOV W14, [W15++]
005916  780700     MOV W0, W14
005918  9FBF81     MOV W1, [W15-16]
00591A  EB0500     CLR W10
00591C  EB4600     CLR.B W12
00591E  20A3CB     MOV #0xA3C, W11
005920  20830D     MOV #0x830, W13
1179:                  //static unsigned int cycleCounter; //increment each time we enter the function
1180:                  unsigned int i;
1181:                  unsigned int inputIndex;
1182:                  unsigned int buttonIndex;
1183:                  static BUTTONS buttonOutputs;
1184:                  static BUTTONS cycleCounter;
1185:                  BUTTONS buttonOutBuffer;
1186:              
1187:                  //Calculate output high or low
1188:                  for (buttonIndex = 0; buttonIndex < NUM_BUTTONS; buttonIndex++) {
005B38  E8050A     INC W10, W10
005B3A  550FF1     SUB W10, #0x11, [W15]
005B3C  36FEF2     BRA LEU, 0x5922
005B3E  EB0180     CLR W3
005B40  208304     MOV #0x830, W4
1189:                      if (configFlag == 1) {
005922  570FE1     SUB W14, #0x1, [W15]
005924  3A0004     BRA NZ, 0x592E
005926  97BC0F     MOV [W15-16], W8
005928  20012A     MOV #0x12, W10
00592A  2000D9     MOV #0xD, W9
00592C  37000C     BRA 0x5946
1190:                          buttonIndex = NUM_BUTTONS;
1191:                          i = configIndex; //only change the output of the button we're configuring
1192:                          inputIndex = 13; //use rStickPress for testing the outputs to avoid conflicts with configuration commands;
1193:                      }
1194:                      else {
1195:                          i = buttonIndex;
1196:                          inputIndex = buttonIndex;
1197:                      }
1198:                      if (configFlag == 2) {
00592E  570FE2     SUB W14, #0x2, [W15]
005930  320003     BRA Z, 0x5938
005932  78040A     MOV W10, W8
005934  78048A     MOV W10, W9
005936  370007     BRA 0x5946
1199:                          buttonToggles.array[i] = 0; //reset toggle states to power-on configuration.
005938  45000A     ADD W10, W10, W0
00593A  20ACE1     MOV #0xACE, W1
00593C  400001     ADD W0, W1, W0
00593E  EB4800     CLR.B [W0]
005940  98401C     MOV.B W12, [W0+1]
005942  78040A     MOV W10, W8
005944  78048A     MOV W10, W9
1200:                      }
1201:              
1202:                      switch (ButtonSettings[i].outputMode) {
005946  DD4043     SL W8, #3, W0
005948  E88000     INC2 W0, W0
00594A  7D8060     MOV [W0+W11], W0
00594C  500FE2     SUB W0, #0x2, [W15]
00594E  320039     BRA Z, 0x59C2
005950  3E0005     BRA GTU, 0x595C
005952  E00000     CP0 W0
005954  320008     BRA Z, 0x5966
005956  500FE1     SUB W0, #0x1, [W15]
005958  3A00DF     BRA NZ, 0x5B18
00595A  370012     BRA 0x5980
00595C  500FE3     SUB W0, #0x3, [W15]
00595E  320061     BRA Z, 0x5A22
005960  500FE4     SUB W0, #0x4, [W15]
005962  3A00DA     BRA NZ, 0x5B18
005964  370092     BRA 0x5A8A
1203:                          case PUSHBUTTON:
1204:                              buttonOutputs.array[i] = GetButtonPress()->array[inputIndex];
005966  0718CD     RCALL GetButtonPress
005968  440108     ADD W8, W8, W2
00596A  41010D     ADD W2, W13, W2
00596C  448089     ADD W9, W9, W1
00596E  408080     ADD W1, W0, W1
005970  FB8191     ZE [W1], W3
005972  904011     MOV.B [W1+1], W0
005974  DD0048     SL W0, #8, W0
005976  700003     IOR W0, W3, W0
005978  784900     MOV.B W0, [W2]
00597A  DE0048     LSR W0, #8, W0
00597C  984110     MOV.B W0, [W2+1]
00597E  3700CC     BRA 0x5B18
1205:                              break;
1206:              
1207:                          case TOGGLE:
1208:                              if (GetNewPress()->array[inputIndex]) {
005980  0718C4     RCALL GetNewPress
005982  448089     ADD W9, W9, W1
005984  408080     ADD W1, W0, W1
005986  FB8111     ZE [W1], W2
005988  904011     MOV.B [W1+1], W0
00598A  DD0048     SL W0, #8, W0
00598C  700002     IOR W0, W2, W0
00598E  32000D     BRA Z, 0x59AA
1209:                                  buttonToggles.array[i] = !buttonToggles.array[i];
005990  440008     ADD W8, W8, W0
005992  20ACE3     MOV #0xACE, W3
005994  400103     ADD W0, W3, W2
005996  EB0180     CLR W3
005998  FB8092     ZE [W2], W1
00599A  904012     MOV.B [W2+1], W0
00599C  DD0048     SL W0, #8, W0
00599E  700001     IOR W0, W1, W0
0059A0  3A0001     BRA NZ, 0x59A4
0059A2  200013     MOV #0x1, W3
0059A4  784903     MOV.B W3, [W2]
0059A6  DE1848     LSR W3, #8, W0
0059A8  984110     MOV.B W0, [W2+1]
1210:                              }
1211:                              buttonOutputs.array[i] = buttonToggles.array[i];
0059AA  440008     ADD W8, W8, W0
0059AC  40010D     ADD W0, W13, W2
0059AE  20ACE5     MOV #0xACE, W5
0059B0  400005     ADD W0, W5, W0
0059B2  FB8090     ZE [W0], W1
0059B4  904010     MOV.B [W0+1], W0
0059B6  DD0048     SL W0, #8, W0
0059B8  700001     IOR W0, W1, W0
0059BA  784900     MOV.B W0, [W2]
0059BC  DE0048     LSR W0, #8, W0
0059BE  984110     MOV.B W0, [W2+1]
0059C0  3700AB     BRA 0x5B18
1212:                              break;
1213:              
1214:                          case SINGLE_SHOT:
1215:                              if (GetNewPress()->array[inputIndex]) {
0059C2  0718A3     RCALL GetNewPress
0059C4  448089     ADD W9, W9, W1
0059C6  408080     ADD W1, W0, W1
0059C8  FB8111     ZE [W1], W2
0059CA  904011     MOV.B [W1+1], W0
0059CC  DD0048     SL W0, #8, W0
0059CE  700002     IOR W0, W2, W0
0059D0  320009     BRA Z, 0x59E4
1216:                                  cycleCounter.array[i] = 1;
0059D2  440008     ADD W8, W8, W0
0059D4  2080C2     MOV #0x80C, W2
0059D6  400082     ADD W0, W2, W1
0059D8  EB4180     CLR.B W3
0059DA  71C8E1     IOR.B W3, #0x1, [W1]
0059DC  98409C     MOV.B W12, [W1+1]
1217:                                  buttonOutputs.array[i] = 1;
0059DE  40000D     ADD W0, W13, W0
0059E0  784811     MOV.B [W1], [W0]
0059E2  98401C     MOV.B W12, [W0+1]
1218:                              }
1219:                              if (cycleCounter.array[i] > 0 && cycleCounter.array[i] <= ButtonSettings[i].pulseWidth) {
0059E4  440188     ADD W8, W8, W3
0059E6  2080C5     MOV #0x80C, W5
0059E8  418105     ADD W3, W5, W2
0059EA  FB8092     ZE [W2], W1
0059EC  904012     MOV.B [W2+1], W0
0059EE  DD0048     SL W0, #8, W0
0059F0  700081     IOR W0, W1, W1
0059F2  32000E     BRA Z, 0x5A10
0059F4  DD4043     SL W8, #3, W0
0059F6  400064     ADD W0, #0x4, W0
0059F8  7D8060     MOV [W0+W11], W0
0059FA  508F80     SUB W1, W0, [W15]
0059FC  3E0009     BRA GTU, 0x5A10
1220:                                  buttonOutputs.array[i] = 1;
0059FE  41800D     ADD W3, W13, W0
005A00  EB4180     CLR.B W3
005A02  71C861     IOR.B W3, #0x1, [W0]
005A04  98401C     MOV.B W12, [W0+1]
1221:                                  cycleCounter.array[i]++;
005A06  E80001     INC W1, W0
005A08  784900     MOV.B W0, [W2]
005A0A  DE0048     LSR W0, #8, W0
005A0C  984110     MOV.B W0, [W2+1]
005A0E  370084     BRA 0x5B18
1222:                              }
1223:                              else {
1224:                                  cycleCounter.array[i] = 0;
005A10  440008     ADD W8, W8, W0
005A12  2080C5     MOV #0x80C, W5
005A14  400085     ADD W0, W5, W1
005A16  EB4880     CLR.B [W1]
005A18  98409C     MOV.B W12, [W1+1]
1225:                                  buttonOutputs.array[i] = 0;
005A1A  40000D     ADD W0, W13, W0
005A1C  78480C     MOV.B W12, [W0]
005A1E  98401C     MOV.B W12, [W0+1]
005A20  37007B     BRA 0x5B18
1226:                              }
1227:                              break;
1228:              
1229:                          case AUTOFIRE:
1230:                              if (GetButtonPress()->array[inputIndex]) {
005A22  07186F     RCALL GetButtonPress
005A24  448089     ADD W9, W9, W1
005A26  408080     ADD W1, W0, W1
005A28  FB8111     ZE [W1], W2
005A2A  904011     MOV.B [W1+1], W0
005A2C  DD0048     SL W0, #8, W0
005A2E  700002     IOR W0, W2, W0
005A30  320023     BRA Z, 0x5A78
1231:                                  if (cycleCounter.array[i] % ButtonSettings[i].autofirePeriod < ButtonSettings[i].pulseWidth) {
005A32  440208     ADD W8, W8, W4
005A34  2080C1     MOV #0x80C, W1
005A36  420001     ADD W4, W1, W0
005A38  FB8090     ZE [W0], W1
005A3A  904010     MOV.B [W0+1], W0
005A3C  DD0048     SL W0, #8, W0
005A3E  700181     IOR W0, W1, W3
005A40  DD4043     SL W8, #3, W0
005A42  4000E6     ADD W0, #0x6, W1
005A44  7D8161     MOV [W1+W11], W2
005A46  781F80     MOV W0, [W15++]
005A48  090011     REPEAT #0x11
005A4A  D88182     DIV.UW W3, W2
005A4C  78004F     MOV [--W15], W0
005A4E  400064     ADD W0, #0x4, W0
005A50  7D8060     MOV [W0+W11], W0
005A52  508F80     SUB W1, W0, [W15]
005A54  310005     BRA C, 0x5A60
1232:                                      buttonOutputs.array[i] = 1;
005A56  42000D     ADD W4, W13, W0
005A58  EB4100     CLR.B W2
005A5A  714861     IOR.B W2, #0x1, [W0]
005A5C  98401C     MOV.B W12, [W0+1]
005A5E  370004     BRA 0x5A68
1233:                                  }
1234:                                  else {
1235:                                      buttonOutputs.array[i] = 0;
005A60  440008     ADD W8, W8, W0
005A62  40000D     ADD W0, W13, W0
005A64  EB4800     CLR.B [W0]
005A66  98401C     MOV.B W12, [W0+1]
1236:                                  }
1237:                                  cycleCounter.array[i]++;
005A68  440088     ADD W8, W8, W1
005A6A  2080C5     MOV #0x80C, W5
005A6C  408085     ADD W1, W5, W1
005A6E  E80003     INC W3, W0
005A70  784880     MOV.B W0, [W1]
005A72  DE0048     LSR W0, #8, W0
005A74  984090     MOV.B W0, [W1+1]
005A76  370050     BRA 0x5B18
1238:                              }
1239:                              else {
1240:                                  buttonOutputs.array[i] = 0;
005A78  440008     ADD W8, W8, W0
005A7A  40008D     ADD W0, W13, W1
005A7C  EB4880     CLR.B [W1]
005A7E  98409C     MOV.B W12, [W1+1]
1241:                                  cycleCounter.array[i] = 0;
005A80  2080C1     MOV #0x80C, W1
005A82  400001     ADD W0, W1, W0
005A84  78480C     MOV.B W12, [W0]
005A86  98401C     MOV.B W12, [W0+1]
005A88  370047     BRA 0x5B18
1242:                              }
1243:                              break;
1244:              
1245:                          case TOGGLE_AUTOFIRE:
1246:                              if (GetNewPress()->array[inputIndex]) {
005A8A  07183F     RCALL GetNewPress
005A8C  448089     ADD W9, W9, W1
005A8E  408080     ADD W1, W0, W1
005A90  FB8111     ZE [W1], W2
005A92  904011     MOV.B [W1+1], W0
005A94  DD0048     SL W0, #8, W0
005A96  700002     IOR W0, W2, W0
005A98  32000D     BRA Z, 0x5AB4
1247:                                  buttonToggles.array[i] = !buttonToggles.array[i];
005A9A  440008     ADD W8, W8, W0
005A9C  20ACE3     MOV #0xACE, W3
005A9E  400103     ADD W0, W3, W2
005AA0  EB0180     CLR W3
005AA2  FB8092     ZE [W2], W1
005AA4  904012     MOV.B [W2+1], W0
005AA6  DD0048     SL W0, #8, W0
005AA8  700001     IOR W0, W1, W0
005AAA  3A0001     BRA NZ, 0x5AAE
005AAC  200013     MOV #0x1, W3
005AAE  784903     MOV.B W3, [W2]
005AB0  DE1848     LSR W3, #8, W0
005AB2  984110     MOV.B W0, [W2+1]
1248:                              }
1249:                              if (buttonToggles.array[i]) {
005AB4  440188     ADD W8, W8, W3
005AB6  20ACE5     MOV #0xACE, W5
005AB8  418005     ADD W3, W5, W0
005ABA  FB8090     ZE [W0], W1
005ABC  904010     MOV.B [W0+1], W0
005ABE  DD0048     SL W0, #8, W0
005AC0  700001     IOR W0, W1, W0
005AC2  320022     BRA Z, 0x5B08
1250:                                  if (cycleCounter.array[i] % ButtonSettings[i].autofirePeriod < ButtonSettings[i].pulseWidth) {
005AC4  2080C1     MOV #0x80C, W1
005AC6  418001     ADD W3, W1, W0
005AC8  FB8090     ZE [W0], W1
005ACA  904010     MOV.B [W0+1], W0
005ACC  DD0048     SL W0, #8, W0
005ACE  700201     IOR W0, W1, W4
005AD0  DD4043     SL W8, #3, W0
005AD2  4000E6     ADD W0, #0x6, W1
005AD4  7D8161     MOV [W1+W11], W2
005AD6  781F80     MOV W0, [W15++]
005AD8  090011     REPEAT #0x11
005ADA  D88202     DIV.UW W4, W2
005ADC  78004F     MOV [--W15], W0
005ADE  400064     ADD W0, #0x4, W0
005AE0  7D8060     MOV [W0+W11], W0
005AE2  508F80     SUB W1, W0, [W15]
005AE4  310005     BRA C, 0x5AF0
1251:                                      buttonOutputs.array[i] = 1;
005AE6  41800D     ADD W3, W13, W0
005AE8  EB4100     CLR.B W2
005AEA  714861     IOR.B W2, #0x1, [W0]
005AEC  98401C     MOV.B W12, [W0+1]
005AEE  370004     BRA 0x5AF8
1252:                                  }
1253:                                  else {
1254:                                      buttonOutputs.array[i] = 0;
005AF0  440008     ADD W8, W8, W0
005AF2  40000D     ADD W0, W13, W0
005AF4  EB4800     CLR.B [W0]
005AF6  98401C     MOV.B W12, [W0+1]
1255:                                  }
1256:                                  cycleCounter.array[i]++;
005AF8  440088     ADD W8, W8, W1
005AFA  2080C3     MOV #0x80C, W3
005AFC  408083     ADD W1, W3, W1
005AFE  E80004     INC W4, W0
005B00  784880     MOV.B W0, [W1]
005B02  DE0048     LSR W0, #8, W0
005B04  984090     MOV.B W0, [W1+1]
005B06  370008     BRA 0x5B18
1257:                              }
1258:                              else {
1259:                                  buttonOutputs.array[i] = 0;
005B08  440008     ADD W8, W8, W0
005B0A  40008D     ADD W0, W13, W1
005B0C  EB4880     CLR.B [W1]
005B0E  98409C     MOV.B W12, [W1+1]
1260:                                  cycleCounter.array[i] = 0;
005B10  2080C5     MOV #0x80C, W5
005B12  400005     ADD W0, W5, W0
005B14  78480C     MOV.B W12, [W0]
005B16  98401C     MOV.B W12, [W0+1]
1261:                              }
1262:                              break;
1263:              
1264:                          default:
1265:                              break;
1266:                      }//end switch
1267:              
1268:                      //We must explicitly assign a value to the output each time, or else the
1269:                      //following code will keep toggling the output if inversion is on.
1270:                      if (ButtonSettings[i].invert == TRUE) {
005B18  DD4043     SL W8, #3, W0
005B1A  7D81E0     MOV [W0+W11], W3
005B1C  518FE1     SUB W3, #0x1, [W15]
005B1E  3A000C     BRA NZ, 0x5B38
1271:                          buttonOutputs.array[i] = !buttonOutputs.array[i];
005B20  440008     ADD W8, W8, W0
005B22  40010D     ADD W0, W13, W2
005B24  EB0200     CLR W4
005B26  FB8092     ZE [W2], W1
005B28  904012     MOV.B [W2+1], W0
005B2A  DD0048     SL W0, #8, W0
005B2C  700001     IOR W0, W1, W0
005B2E  3A0001     BRA NZ, 0x5B32
005B30  780203     MOV W3, W4
005B32  784904     MOV.B W4, [W2]
005B34  DE2048     LSR W4, #8, W0
005B36  984110     MOV.B W0, [W2+1]
1272:                      }
1273:                  }//end for loop
1274:              
1275:                  for (i=0; i<NUM_BUTTONS; i++)
005B54  E80183     INC W3, W3
005B56  518FF2     SUB W3, #0x12, [W15]
005B58  3AFFF4     BRA NZ, 0x5B42
1276:                  {
1277:                      buttonOutBuffer.array[i] = buttonOutputs.array[i];
005B42  418103     ADD W3, W3, W2
005B44  410004     ADD W2, W4, W0
005B46  FB8090     ZE [W0], W1
005B48  904010     MOV.B [W0+1], W0
005B4A  DD0048     SL W0, #8, W0
005B4C  700001     IOR W0, W1, W0
005B4E  2FFCC1     MOV #0xFFCC, W1
005B50  408082     ADD W1, W2, W1
005B52  7FB080     MOV W0, [W1+W15]
1278:                  }
1279:                  //Update the physical addresses associated with the output pins
1280:                  //make sure this matches the order in BUTTONS struct in PS4_controller.h
1281:              
1282:                  if (GetSpiInputPacket()->overrideDPadUp) buttonOutBuffer.dPadUp = GetSpiInputPacket()->dPadUp;
005B5A  072076     RCALL GetSpiInputPacket
005B5C  904810     MOV.B [W0+9], W0
005B5E  A34800     BTST.Z W0, #4
005B60  320004     BRA Z, 0x5B6A
005B62  072072     RCALL GetSpiInputPacket
005B64  906040     MOV.B [W0+36], W0
005B66  600061     AND W0, #0x1, W0
005B68  9FA7E0     MOV W0, [W15-52]
1283:                  if (GetSpiInputPacket()->overrideDPadRight) buttonOutBuffer.dPadRight = GetSpiInputPacket()->dPadRight;
005B6A  07206E     RCALL GetSpiInputPacket
005B6C  904810     MOV.B [W0+9], W0
005B6E  A35800     BTST.Z W0, #5
005B70  320005     BRA Z, 0x5B7C
005B72  07206A     RCALL GetSpiInputPacket
005B74  906040     MOV.B [W0+36], W0
005B76  D10000     LSR W0, W0
005B78  600061     AND W0, #0x1, W0
005B7A  9FA7F0     MOV W0, [W15-50]
1284:                  if (GetSpiInputPacket()->overrideDPadDown) buttonOutBuffer.dPadDown = GetSpiInputPacket()->dPadDown;
005B7C  072065     RCALL GetSpiInputPacket
005B7E  904810     MOV.B [W0+9], W0
005B80  A36800     BTST.Z W0, #6
005B82  320005     BRA Z, 0x5B8E
005B84  072061     RCALL GetSpiInputPacket
005B86  906040     MOV.B [W0+36], W0
005B88  DE0042     LSR W0, #2, W0
005B8A  600061     AND W0, #0x1, W0
005B8C  9FAF80     MOV W0, [W15-48]
1285:                  if (GetSpiInputPacket()->overrideDPadLeft) buttonOutBuffer.dPadLeft = GetSpiInputPacket()->dPadLeft;
005B8E  07205C     RCALL GetSpiInputPacket
005B90  904810     MOV.B [W0+9], W0
005B92  E00400     CP0.B W0
005B94  3D0005     BRA GE, 0x5BA0
005B96  072058     RCALL GetSpiInputPacket
005B98  906040     MOV.B [W0+36], W0
005B9A  DE0043     LSR W0, #3, W0
005B9C  600061     AND W0, #0x1, W0
005B9E  9FAF90     MOV W0, [W15-46]
1286:                  if (GetSpiInputPacket()->overrideTriangle) buttonOutBuffer.triangle = GetSpiInputPacket()->triangle;
005BA0  072053     RCALL GetSpiInputPacket
005BA2  904820     MOV.B [W0+10], W0
005BA4  A30800     BTST.Z W0, #0
005BA6  320005     BRA Z, 0x5BB2
005BA8  07204F     RCALL GetSpiInputPacket
005BAA  906040     MOV.B [W0+36], W0
005BAC  DE0044     LSR W0, #4, W0
005BAE  600061     AND W0, #0x1, W0
005BB0  9FAFA0     MOV W0, [W15-44]
1287:                  if (GetSpiInputPacket()->overrideCircle) buttonOutBuffer.circle = GetSpiInputPacket()->circle;
005BB2  07204A     RCALL GetSpiInputPacket
005BB4  904820     MOV.B [W0+10], W0
005BB6  A31800     BTST.Z W0, #1
005BB8  320005     BRA Z, 0x5BC4
005BBA  072046     RCALL GetSpiInputPacket
005BBC  906040     MOV.B [W0+36], W0
005BBE  DE0045     LSR W0, #5, W0
005BC0  600061     AND W0, #0x1, W0
005BC2  9FAFB0     MOV W0, [W15-42]
1288:                  if (GetSpiInputPacket()->overrideCross) buttonOutBuffer.cross = GetSpiInputPacket()->cross;
005BC4  072041     RCALL GetSpiInputPacket
005BC6  904820     MOV.B [W0+10], W0
005BC8  A32800     BTST.Z W0, #2
005BCA  320005     BRA Z, 0x5BD6
005BCC  07203D     RCALL GetSpiInputPacket
005BCE  906040     MOV.B [W0+36], W0
005BD0  DE0046     LSR W0, #6, W0
005BD2  600061     AND W0, #0x1, W0
005BD4  9FAFC0     MOV W0, [W15-40]
1289:                  if (GetSpiInputPacket()->overrideSquare) buttonOutBuffer.square = GetSpiInputPacket()->square;
005BD6  072038     RCALL GetSpiInputPacket
005BD8  904820     MOV.B [W0+10], W0
005BDA  A33800     BTST.Z W0, #3
005BDC  320005     BRA Z, 0x5BE8
005BDE  072034     RCALL GetSpiInputPacket
005BE0  906040     MOV.B [W0+36], W0
005BE2  FB8000     ZE W0, W0
005BE4  DE0047     LSR W0, #7, W0
005BE6  9FAFD0     MOV W0, [W15-38]
1290:                  if (GetSpiInputPacket()->overrideLBumper) buttonOutBuffer.lBumper = GetSpiInputPacket()->lBumper;
005BE8  07202F     RCALL GetSpiInputPacket
005BEA  904820     MOV.B [W0+10], W0
005BEC  A34800     BTST.Z W0, #4
005BEE  320004     BRA Z, 0x5BF8
005BF0  07202B     RCALL GetSpiInputPacket
005BF2  906050     MOV.B [W0+37], W0
005BF4  600061     AND W0, #0x1, W0
005BF6  9FAFE0     MOV W0, [W15-36]
1291:                  if (GetSpiInputPacket()->overrideRBumper) buttonOutBuffer.rBumper = GetSpiInputPacket()->rBumper;
005BF8  072027     RCALL GetSpiInputPacket
005BFA  904820     MOV.B [W0+10], W0
005BFC  A35800     BTST.Z W0, #5
005BFE  320005     BRA Z, 0x5C0A
005C00  072023     RCALL GetSpiInputPacket
005C02  906050     MOV.B [W0+37], W0
005C04  D10000     LSR W0, W0
005C06  600061     AND W0, #0x1, W0
005C08  9FAFF0     MOV W0, [W15-34]
1292:                  if (GetSpiInputPacket()->overrideLTriggerPull) buttonOutBuffer.lTriggerPull = GetSpiInputPacket()->lTriggerPull;
005C0A  07201E     RCALL GetSpiInputPacket
005C0C  904820     MOV.B [W0+10], W0
005C0E  A36800     BTST.Z W0, #6
005C10  320005     BRA Z, 0x5C1C
005C12  07201A     RCALL GetSpiInputPacket
005C14  906050     MOV.B [W0+37], W0
005C16  DE0042     LSR W0, #2, W0
005C18  600061     AND W0, #0x1, W0
005C1A  9FB780     MOV W0, [W15-32]
1293:                  if (GetSpiInputPacket()->overrideRTriggerPull) buttonOutBuffer.rTriggerPull = GetSpiInputPacket()->rTriggerPull;
005C1C  072015     RCALL GetSpiInputPacket
005C1E  904820     MOV.B [W0+10], W0
005C20  E00400     CP0.B W0
005C22  3D0005     BRA GE, 0x5C2E
005C24  072011     RCALL GetSpiInputPacket
005C26  906050     MOV.B [W0+37], W0
005C28  DE0043     LSR W0, #3, W0
005C2A  600061     AND W0, #0x1, W0
005C2C  9FB790     MOV W0, [W15-30]
1294:                  if (GetSpiInputPacket()->overrideLStickPress) buttonOutBuffer.lStickPress = GetSpiInputPacket()->lStickPress;
005C2E  07200C     RCALL GetSpiInputPacket
005C30  904830     MOV.B [W0+11], W0
005C32  A30800     BTST.Z W0, #0
005C34  320005     BRA Z, 0x5C40
005C36  072008     RCALL GetSpiInputPacket
005C38  906050     MOV.B [W0+37], W0
005C3A  DE0044     LSR W0, #4, W0
005C3C  600061     AND W0, #0x1, W0
005C3E  9FB7A0     MOV W0, [W15-28]
1295:                  if (GetSpiInputPacket()->overrideRStickPress) buttonOutBuffer.rStickPress = GetSpiInputPacket()->rStickPress;
005C40  072003     RCALL GetSpiInputPacket
005C42  904830     MOV.B [W0+11], W0
005C44  A31800     BTST.Z W0, #1
005C46  320005     BRA Z, 0x5C52
005C48  071FFF     RCALL GetSpiInputPacket
005C4A  906050     MOV.B [W0+37], W0
005C4C  DE0045     LSR W0, #5, W0
005C4E  600061     AND W0, #0x1, W0
005C50  9FB7B0     MOV W0, [W15-26]
1296:                  if (GetSpiInputPacket()->overrideShare) buttonOutBuffer.share = GetSpiInputPacket()->share;
005C52  071FFA     RCALL GetSpiInputPacket
005C54  904830     MOV.B [W0+11], W0
005C56  A32800     BTST.Z W0, #2
005C58  320005     BRA Z, 0x5C64
005C5A  071FF6     RCALL GetSpiInputPacket
005C5C  906050     MOV.B [W0+37], W0
005C5E  DE0046     LSR W0, #6, W0
005C60  600061     AND W0, #0x1, W0
005C62  9FB7D0     MOV W0, [W15-22]
1297:                  if (GetSpiInputPacket()->overrideOptions) buttonOutBuffer.options = GetSpiInputPacket()->options;
005C64  071FF1     RCALL GetSpiInputPacket
005C66  904830     MOV.B [W0+11], W0
005C68  A33800     BTST.Z W0, #3
005C6A  320005     BRA Z, 0x5C76
005C6C  071FED     RCALL GetSpiInputPacket
005C6E  906050     MOV.B [W0+37], W0
005C70  FB8000     ZE W0, W0
005C72  DE0047     LSR W0, #7, W0
005C74  9FB7C0     MOV W0, [W15-24]
1298:                  if (GetSpiInputPacket()->overrideTpadClick) buttonOutBuffer.tpadClick = GetSpiInputPacket()->tpadClick;
005C76  071FE8     RCALL GetSpiInputPacket
005C78  904830     MOV.B [W0+11], W0
005C7A  A34800     BTST.Z W0, #4
005C7C  320004     BRA Z, 0x5C86
005C7E  071FE4     RCALL GetSpiInputPacket
005C80  906060     MOV.B [W0+38], W0
005C82  600061     AND W0, #0x1, W0
005C84  9FB7E0     MOV W0, [W15-20]
1299:                  if (GetSpiInputPacket()->overridePsButton) buttonOutBuffer.psButton = GetSpiInputPacket()->psButton;
005C86  071FE0     RCALL GetSpiInputPacket
005C88  904830     MOV.B [W0+11], W0
005C8A  A35800     BTST.Z W0, #5
005C8C  320005     BRA Z, 0x5C98
005C8E  071FDC     RCALL GetSpiInputPacket
005C90  906060     MOV.B [W0+38], W0
005C92  D10000     LSR W0, W0
005C94  600061     AND W0, #0x1, W0
005C96  9FB7F0     MOV W0, [W15-18]
1300:                          
1301:                  //Must use IF statement and assign explicit values LATx so compiler will use BSET/BCLR atomic operators
1302:                  //Otherwise, compiler wants to use OR/AND masks and you get read-modify-write problems if T3 interrupt interrupts it
1303:                  //Ternary operator doesn't work either!
1304:                  if (buttonOutBuffer.dPadUp){
005C98  97A06F     MOV [W15-52], W0
005C9A  E00000     CP0 W0
005C9C  320003     BRA Z, 0x5CA4
1305:                      DPAD_UP = 1;
005C9E  A842DC     BSET LATD, #2
1306:                      ButtonsFourBitCode[0] |= 0b0001;
005CA0  A80AFE     BSET ButtonsFourBitCode, #0
005CA2  370002     BRA 0x5CA8
1307:                  }else {
1308:                      DPAD_UP = 0;
005CA4  A942DC     BCLR LATD, #2
1309:                      ButtonsFourBitCode[0] &= ~0b0001;
005CA6  A90AFE     BCLR ButtonsFourBitCode, #0
1310:                  }
1311:                  if (buttonOutBuffer.dPadRight){
005CA8  97A07F     MOV [W15-50], W0
005CAA  E00000     CP0 W0
005CAC  320003     BRA Z, 0x5CB4
1312:                      DPAD_RIGHT = 1; 
005CAE  A862DC     BSET LATD, #3
1313:                      ButtonsFourBitCode[0] |= 0b0010;
005CB0  A82AFE     BSET ButtonsFourBitCode, #1
005CB2  370002     BRA 0x5CB8
1314:                  }else {
1315:                      DPAD_RIGHT = 0;
005CB4  A962DC     BCLR LATD, #3
1316:                      ButtonsFourBitCode[0] &= ~0b0010;
005CB6  A92AFE     BCLR ButtonsFourBitCode, #1
1317:                  }
1318:                  if (buttonOutBuffer.dPadDown){
005CB8  97A80F     MOV [W15-48], W0
005CBA  E00000     CP0 W0
005CBC  320003     BRA Z, 0x5CC4
1319:                      DPAD_DOWN  = 1;
005CBE  A882DC     BSET LATD, #4
1320:                      ButtonsFourBitCode[0] |= 0b0100;
005CC0  A84AFE     BSET ButtonsFourBitCode, #2
005CC2  370002     BRA 0x5CC8
1321:                  }else {
1322:                      DPAD_DOWN = 0;
005CC4  A982DC     BCLR LATD, #4
1323:                      ButtonsFourBitCode[0] &= ~0b0100;
005CC6  A94AFE     BCLR ButtonsFourBitCode, #2
1324:                  }
1325:                  if (buttonOutBuffer.dPadLeft){
005CC8  97A81F     MOV [W15-46], W0
005CCA  E00000     CP0 W0
005CCC  320003     BRA Z, 0x5CD4
1326:                      DPAD_LEFT = 1;
005CCE  A8A2DC     BSET LATD, #5
1327:                      ButtonsFourBitCode[0] |= 0b1000;
005CD0  A86AFE     BSET ButtonsFourBitCode, #3
005CD2  370002     BRA 0x5CD8
1328:                  }else {
1329:                      DPAD_LEFT = 0;
005CD4  A9A2DC     BCLR LATD, #5
1330:                      ButtonsFourBitCode[0] &= ~0b1000;
005CD6  A96AFE     BCLR ButtonsFourBitCode, #3
1331:                  }
1332:                  
1333:                  
1334:                  if (buttonOutBuffer.triangle){
005CD8  97A82F     MOV [W15-44], W0
005CDA  E00000     CP0 W0
005CDC  320003     BRA Z, 0x5CE4
1335:                      TRIANGLE = 1; 
005CDE  A802E4     BSET LATE, #0
1336:                      ButtonsFourBitCode[1] |= 0b0001;
005CE0  A80B00     BSET 0xB00, #0
005CE2  370002     BRA 0x5CE8
1337:                  }else {
1338:                      TRIANGLE = 0;
005CE4  A902E4     BCLR LATE, #0
1339:                      ButtonsFourBitCode[1] &= ~0b0001;
005CE6  A90B00     BCLR 0xB00, #0
1340:                  }
1341:                  if (buttonOutBuffer.circle){
005CE8  97A83F     MOV [W15-42], W0
005CEA  E00000     CP0 W0
005CEC  320003     BRA Z, 0x5CF4
1342:                      CIRCLE = 1; 
005CEE  A822E4     BSET LATE, #1
1343:                      ButtonsFourBitCode[1] |= 0b0010;
005CF0  A82B00     BSET 0xB00, #1
005CF2  370002     BRA 0x5CF8
1344:                  }else { 
1345:                      CIRCLE = 0;
005CF4  A922E4     BCLR LATE, #1
1346:                      ButtonsFourBitCode[1] &= ~0b0010;
005CF6  A92B00     BCLR 0xB00, #1
1347:                  }
1348:                  if (buttonOutBuffer.cross) {
005CF8  97A84F     MOV [W15-40], W0
005CFA  E00000     CP0 W0
005CFC  320003     BRA Z, 0x5D04
1349:                      CROSS = 1; 
005CFE  A842E4     BSET LATE, #2
1350:                      ButtonsFourBitCode[1] |= 0b0100;
005D00  A84B00     BSET 0xB00, #2
005D02  370002     BRA 0x5D08
1351:                  }else {
1352:                      CROSS = 0;
005D04  A942E4     BCLR LATE, #2
1353:                      ButtonsFourBitCode[1] &= ~0b0100;
005D06  A94B00     BCLR 0xB00, #2
1354:                  }
1355:                  if (buttonOutBuffer.square) {
005D08  97A85F     MOV [W15-38], W0
005D0A  E00000     CP0 W0
005D0C  320003     BRA Z, 0x5D14
1356:                      SQUARE = 1;
005D0E  A862E4     BSET LATE, #3
1357:                      ButtonsFourBitCode[1] |= 0b1000;
005D10  A86B00     BSET 0xB00, #3
005D12  370002     BRA 0x5D18
1358:                  }else {
1359:                      SQUARE = 0;
005D14  A962E4     BCLR LATE, #3
1360:                      ButtonsFourBitCode[1] &= ~0b1000;
005D16  A96B00     BCLR 0xB00, #3
1361:                  }
1362:                  
1363:                  if (buttonOutBuffer.lBumper) {
005D18  97A86F     MOV [W15-36], W0
005D1A  E00000     CP0 W0
005D1C  320003     BRA Z, 0x5D24
1364:                      LBUMPER = 1; 
005D1E  A802EC     BSET LATF, #0
1365:                      ButtonsFourBitCode[2] |= 0b0001;
005D20  A80B02     BSET 0xB02, #0
005D22  370002     BRA 0x5D28
1366:                  }else {
1367:                      LBUMPER = 0;
005D24  A902EC     BCLR LATF, #0
1368:                      ButtonsFourBitCode[2] &= ~0b0001;
005D26  A90B02     BCLR 0xB02, #0
1369:                  }
1370:                  if (buttonOutBuffer.rBumper) {
005D28  97A87F     MOV [W15-34], W0
005D2A  E00000     CP0 W0
005D2C  320003     BRA Z, 0x5D34
1371:                      RBUMPER = 1; 
005D2E  A822EC     BSET LATF, #1
1372:                      ButtonsFourBitCode[2] |= 0b0010;
005D30  A82B02     BSET 0xB02, #1
005D32  370002     BRA 0x5D38
1373:                  }else {
1374:                      RBUMPER = 0;
005D34  A922EC     BCLR LATF, #1
1375:                      ButtonsFourBitCode[2] &= ~0b0010;
005D36  A92B02     BCLR 0xB02, #1
1376:                  }
1377:                  if (buttonOutBuffer.lStickPress) {
005D38  97B02F     MOV [W15-28], W0
005D3A  E00000     CP0 W0
005D3C  320003     BRA Z, 0x5D44
1378:                      LSTICK_PRESS = 1; 
005D3E  A8A2D5     BSET 0x2D5, #5
1379:                      ButtonsFourBitCode[2] |= 0b0100;
005D40  A84B02     BSET 0xB02, #2
005D42  370002     BRA 0x5D48
1380:                  }else {
1381:                      LSTICK_PRESS = 0;
005D44  A9A2D5     BCLR 0x2D5, #5
1382:                      ButtonsFourBitCode[2] &= ~0b0100;
005D46  A94B02     BCLR 0xB02, #2
1383:                  }
1384:                  if (buttonOutBuffer.rStickPress) {
005D48  97B03F     MOV [W15-26], W0
005D4A  E00000     CP0 W0
005D4C  320003     BRA Z, 0x5D54
1385:                      RSTICK_PRESS = 1; 
005D4E  A8C2D5     BSET 0x2D5, #6
1386:                      ButtonsFourBitCode[2] |= 0b1000;
005D50  A86B02     BSET 0xB02, #3
005D52  370002     BRA 0x5D58
1387:                  }else {
1388:                      RSTICK_PRESS = 0;
005D54  A9C2D5     BCLR 0x2D5, #6
1389:                      ButtonsFourBitCode[2] &= ~0b1000;
005D56  A96B02     BCLR 0xB02, #3
1390:                  }
1391:                  
1392:                  if (buttonOutBuffer.share) {
005D58  97B05F     MOV [W15-22], W0
005D5A  E00000     CP0 W0
005D5C  320003     BRA Z, 0x5D64
1393:                      SHARE = 1; 
005D5E  A862EC     BSET LATF, #3
1394:                      ButtonsFourBitCode[3] |= 0b0001;
005D60  A80B04     BSET 0xB04, #0
005D62  370002     BRA 0x5D68
1395:                  }else {
1396:                      SHARE = 0;
005D64  A962EC     BCLR LATF, #3
1397:                      ButtonsFourBitCode[3] &= ~0b0001;
005D66  A90B04     BCLR 0xB04, #0
1398:                  }
1399:                  if (buttonOutBuffer.options) {
005D68  97B04F     MOV [W15-24], W0
005D6A  E00000     CP0 W0
005D6C  320003     BRA Z, 0x5D74
1400:                      OPTIONS = 1; 
005D6E  A822DC     BSET LATD, #1
1401:                      ButtonsFourBitCode[3] |= 0b0010;
005D70  A82B04     BSET 0xB04, #1
005D72  370002     BRA 0x5D78
1402:                  }else {
1403:                      OPTIONS = 0;
005D74  A922DC     BCLR LATD, #1
1404:                      ButtonsFourBitCode[3] &= ~0b0010;
005D76  A92B04     BCLR 0xB04, #1
1405:                  }
1406:                  if (buttonOutBuffer.tpadClick) {
005D78  97B06F     MOV [W15-20], W0
005D7A  E00000     CP0 W0
005D7C  320003     BRA Z, 0x5D84
1407:                      TPAD_CLICK = 1; 
005D7E  A8A2CD     BSET 0x2CD, #5
1408:                      ButtonsFourBitCode[3] |= 0b0100;
005D80  A84B04     BSET 0xB04, #2
005D82  370002     BRA 0x5D88
1409:                  }else {
1410:                      TPAD_CLICK = 0;
005D84  A9A2CD     BCLR 0x2CD, #5
1411:                      ButtonsFourBitCode[3] &= ~0b0100;
005D86  A94B04     BCLR 0xB04, #2
1412:                  }
1413:                  if (buttonOutBuffer.psButton) {
005D88  97B07F     MOV [W15-18], W0
005D8A  E00000     CP0 W0
005D8C  320003     BRA Z, 0x5D94
1414:                      PS_BUTTON = 1; 
005D8E  A882E4     BSET LATE, #4
1415:                      ButtonsFourBitCode[3] |= 0b1000;
005D90  A86B04     BSET 0xB04, #3
005D92  370002     BRA 0x5D98
1416:                  }else {
1417:                      PS_BUTTON = 0;
005D94  A982E4     BCLR LATE, #4
1418:                      ButtonsFourBitCode[3] &= ~0b1000;
005D96  A96B04     BCLR 0xB04, #3
1419:                  }
1420:                  if (buttonOutBuffer.lTriggerPull) LTRIGGER_PULL = 1; else LTRIGGER_PULL = 0;
005D98  97B00F     MOV [W15-32], W0
005D9A  E00000     CP0 W0
005D9C  320002     BRA Z, 0x5DA2
005D9E  A8C2DC     BSET LATD, #6
005DA0  370001     BRA 0x5DA4
005DA2  A9C2DC     BCLR LATD, #6
1421:                  if (buttonOutBuffer.rTriggerPull) RTRIGGER_PULL = 1; else RTRIGGER_PULL = 0;
005DA4  97B01F     MOV [W15-30], W0
005DA6  E00000     CP0 W0
005DA8  320003     BRA Z, 0x5DB0
005DAA  A8E2DC     BSET LATD, #7
005DAC  EB0100     CLR W2
005DAE  370002     BRA 0x5DB4
005DB0  A9E2DC     BCLR LATD, #7
005DB2  EB0100     CLR W2
1422:                  
1423:                  for (i=0; i<4; i++)
005DC4  510FE8     SUB W2, #0x8, [W15]
005DC6  3AFFF6     BRA NZ, 0x5DB4
1424:                  {
1425:                      ButtonsPPM[i] = ButtonsFourBitCode[i]*64+2000;
005DB4  20AFE0     MOV #0xAFE, W0
005DB6  780062     MOV [W2+W0], W0
005DB8  DD0046     SL W0, #6, W0
005DBA  207D01     MOV #0x7D0, W1
005DBC  400001     ADD W0, W1, W0
005DBE  20B061     MOV #0xB06, W1
005DC0  78B100     MOV W0, [W2+W1]
005DC2  E88102     INC2 W2, W2
1426:                  }
1427:              }
005DC8  78074F     MOV [--W15], W14
005DCA  BE064F     MOV.D [--W15], W12
005DCC  BE054F     MOV.D [--W15], W10
005DCE  BE044F     MOV.D [--W15], W8
005DD0  B1028F     SUB #0x28, W15
005DD2  060000     RETURN
1428:              
1429:              void UpdateServoOutputs(void) {
005DD4  B00AAF     ADD #0xAA, W15
005DD6  BE9F88     MOV.D W8, [W15++]
005DD8  BE9F8A     MOV.D W10, [W15++]
005DDA  BE9F8C     MOV.D W12, [W15++]
005DDC  781F8E     MOV W14, [W15++]
005DDE  EB0400     CLR W8
005DE0  20854B     MOV #0x854, W11
005DE2  2090EA     MOV #0x90E, W10
005DE4  20046C     MOV #0x46, W12
005DF2  78048B     MOV W11, W9
006028  78040D     MOV W13, W8
006084  78050E     MOV W14, W10
006158  78028D     MOV W13, W5
0062E0  78020C     MOV W12, W4
0062E8  78028D     MOV W13, W5
006348  78058E     MOV W14, W11
1430:                  unsigned int i;
1431:                  signed int direction;
1432:                  signed long int range; //use long int to prevent overflow during math calculations
1433:                  signed long int range2;
1434:                  signed int sensorSignal;
1435:                  signed long int scaledSignal[NUM_SERVOS];
1436:                  signed long int scaledSignalOriginal[NUM_SERVOS]; //Make a copy so we don't overwrite the original when we mix signals
1437:                  signed long int output;
1438:                  signed int deadband;
1439:              
1440:                  static unsigned long int y1[NUM_SERVOS] = {0}; //variable for low pass filter
1441:                  static unsigned long int x1[NUM_SERVOS] = {0}; //variable for low pass filter
1442:                  unsigned long int y = 0; //variable for low pass filter
1443:                  unsigned long int x = 0; //variable for low pass filter
1444:              
1445:                  static BOOL stickHoldToggleL = FALSE;
1446:                  static BOOL stickHoldToggleR = FALSE;
1447:                  static unsigned int inputHoldValue[NUM_SERVOS];
1448:                  static unsigned int analogsBuffer[NUM_SERVOS];
1449:                  unsigned int OCxR_REG_PTRS_buffer[NUM_SERVOS];
1450:                  //unsigned int OCxCON1_REG_PTRS_buffer[NUM_SERVOS];
1451:              
1452:              #define TPAD_INCREMENT_SENSITIVITY 70
1453:                  
1454:                  for (i = 0; i < NUM_SERVOS; i++) {
005FBE  E80408     INC W8, W8
005FC0  E8858B     INC2 W11, W11
005FC2  45057A     ADD W10, #0x1A, W10
005FC4  540FEC     SUB W8, #0xC, [W15]
005FC6  3AFF0F     BRA NZ, 0x5DE6
1455:                      analogsBuffer[i] = GetAnalogs()->array[i]; //GetAnalogs() returns a volatile array, make shadow copy just in case
005DE6  071693     RCALL GetAnalogs
005DE8  440088     ADD W8, W8, W1
005DEA  408080     ADD W1, W0, W1
005DEC  FB8111     ZE [W1], W2
005DEE  904011     MOV.B [W1+1], W0
005DF0  DD0048     SL W0, #8, W0
005DF4  700D82     IOR W0, W2, [W11]
1456:                      
1457:                      if (i == TPAD1_X || i == TPAD1_Y || i == TPAD2_X || i == TPAD2_Y){
005DF6  540066     SUB W8, #0x6, W0
005DF8  500FE3     SUB W0, #0x3, [W15]
005DFA  3E00E1     BRA GTU, 0x5FBE
1458:                          if (ServoSettings[i].touchpadSplit == WHOLE) {
005DFC  90002A     MOV [W10+4], W0
005DFE  E00000     CP0 W0
005E00  3A0049     BRA NZ, 0x5E94
1459:                              if (i == TPAD1_X || i == TPAD2_X){
005E02  540FE6     SUB W8, #0x6, [W15]
005E04  320002     BRA Z, 0x5E0A
005E06  540FE8     SUB W8, #0x8, [W15]
005E08  3A0020     BRA NZ, 0x5E4A
1460:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005E0A  90001A     MOV [W10+2], W0
005E0C  E00000     CP0 W0
005E0E  3A0014     BRA NZ, 0x5E38
1461:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005E10  78001A     MOV [W10], W0
005E12  E00000     CP0 W0
005E14  3A0006     BRA NZ, 0x5E22
1462:                                          analogsBuffer[i] = GetTouchpads()->wholePad.absoluteX;
005E16  07167D     RCALL GetTouchpads
005E18  FB8090     ZE [W0], W1
005E1A  904010     MOV.B [W0+1], W0
005E1C  DD0048     SL W0, #8, W0
005E1E  700C81     IOR W0, W1, [W9]
005E20  3700CE     BRA 0x5FBE
1463:                                      }
1464:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005E22  500FE1     SUB W0, #0x1, [W15]
005E24  3A00CC     BRA NZ, 0x5FBE
1465:                                          analogsBuffer[i] = GetTouchpads()->wholePad.incrementX*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005E26  071675     RCALL GetTouchpads
005E28  904950     MOV.B [W0+13], W2
005E2A  FB8102     ZE W2, W2
005E2C  904860     MOV.B [W0+14], W0
005E2E  DD0048     SL W0, #8, W0
005E30  700002     IOR W0, W2, W0
005E32  B9800C     MUL.SS W0, W12, W0
005E34  780C80     MOV W0, [W9]
005E36  3700C3     BRA 0x5FBE
1466:                                      }
1467:                                  }
1468:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005E38  500FE1     SUB W0, #0x1, [W15]
005E3A  3A00C1     BRA NZ, 0x5FBE
1469:                                      analogsBuffer[i] = GetTouchpads()->wholePad.displacementX;
005E3C  07166A     RCALL GetTouchpads
005E3E  9040C0     MOV.B [W0+4], W1
005E40  FB8081     ZE W1, W1
005E42  904050     MOV.B [W0+5], W0
005E44  DD0048     SL W0, #8, W0
005E46  700C81     IOR W0, W1, [W9]
005E48  3700BA     BRA 0x5FBE
1470:                                  }
1471:                              }
1472:                              else if (i == TPAD1_Y || i == TPAD2_Y) {
005E4A  540FE7     SUB W8, #0x7, [W15]
005E4C  320002     BRA Z, 0x5E52
005E4E  540FE9     SUB W8, #0x9, [W15]
005E50  3A00B6     BRA NZ, 0x5FBE
1473:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005E52  90001A     MOV [W10+2], W0
005E54  E00000     CP0 W0
005E56  3A0015     BRA NZ, 0x5E82
1474:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005E58  78001A     MOV [W10], W0
005E5A  E00000     CP0 W0
005E5C  3A0007     BRA NZ, 0x5E6C
1475:                                          analogsBuffer[i] = GetTouchpads()->wholePad.absoluteY;
005E5E  071659     RCALL GetTouchpads
005E60  9040A0     MOV.B [W0+2], W1
005E62  FB8081     ZE W1, W1
005E64  904030     MOV.B [W0+3], W0
005E66  DD0048     SL W0, #8, W0
005E68  700C81     IOR W0, W1, [W9]
005E6A  3700A9     BRA 0x5FBE
1476:                                      }
1477:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005E6C  500FE1     SUB W0, #0x1, [W15]
005E6E  3A00A7     BRA NZ, 0x5FBE
1478:                                          analogsBuffer[i] = GetTouchpads()->wholePad.incrementY*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005E70  071650     RCALL GetTouchpads
005E72  904970     MOV.B [W0+15], W2
005E74  FB8102     ZE W2, W2
005E76  905000     MOV.B [W0+16], W0
005E78  DD0048     SL W0, #8, W0
005E7A  700002     IOR W0, W2, W0
005E7C  B9800C     MUL.SS W0, W12, W0
005E7E  780C80     MOV W0, [W9]
005E80  37009E     BRA 0x5FBE
1479:                                      }
1480:                                  }
1481:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005E82  500FE1     SUB W0, #0x1, [W15]
005E84  3A009C     BRA NZ, 0x5FBE
1482:                                      analogsBuffer[i] = GetTouchpads()->wholePad.displacementY;
005E86  071645     RCALL GetTouchpads
005E88  9040E0     MOV.B [W0+6], W1
005E8A  FB8081     ZE W1, W1
005E8C  904070     MOV.B [W0+7], W0
005E8E  DD0048     SL W0, #8, W0
005E90  700C81     IOR W0, W1, [W9]
005E92  370095     BRA 0x5FBE
1483:                                  }
1484:                              }
1485:                          }
1486:                          else if (ServoSettings[i].touchpadSplit == SPLIT) {
005E94  500FE1     SUB W0, #0x1, [W15]
005E96  3A0093     BRA NZ, 0x5FBE
1487:                              if (i == TPAD1_X){
005E98  540FE6     SUB W8, #0x6, [W15]
005E9A  3A0023     BRA NZ, 0x5EE2
1488:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005E9C  804D60     MOV 0x9AC, W0
005E9E  E00000     CP0 W0
005EA0  3A0016     BRA NZ, 0x5ECE
1489:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005EA2  804D50     MOV 0x9AA, W0
005EA4  E00000     CP0 W0
005EA6  3A0008     BRA NZ, 0x5EB8
1490:                                          analogsBuffer[i] = GetTouchpads()->leftSide.absoluteX;
005EA8  071634     RCALL GetTouchpads
005EAA  9050B0     MOV.B [W0+19], W1
005EAC  FB8081     ZE W1, W1
005EAE  905040     MOV.B [W0+20], W0
005EB0  DD0048     SL W0, #8, W0
005EB2  700001     IOR W0, W1, W0
005EB4  884300     MOV W0, 0x860
005EB6  370083     BRA 0x5FBE
1491:                                      }
1492:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005EB8  500FE1     SUB W0, #0x1, [W15]
005EBA  3A0081     BRA NZ, 0x5FBE
1493:                                          analogsBuffer[i] = GetTouchpads()->leftSide.incrementX*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005EBC  07162A     RCALL GetTouchpads
005EBE  906100     MOV.B [W0+32], W2
005EC0  FB8102     ZE W2, W2
005EC2  906010     MOV.B [W0+33], W0
005EC4  DD0048     SL W0, #8, W0
005EC6  700002     IOR W0, W2, W0
005EC8  B9800C     MUL.SS W0, W12, W0
005ECA  884300     MOV W0, 0x860
005ECC  370078     BRA 0x5FBE
1494:                                      }
1495:                                  }
1496:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005ECE  500FE1     SUB W0, #0x1, [W15]
005ED0  3A0076     BRA NZ, 0x5FBE
1497:                                      analogsBuffer[i] = GetTouchpads()->leftSide.displacementX;
005ED2  07161F     RCALL GetTouchpads
005ED4  9050F0     MOV.B [W0+23], W1
005ED6  FB8081     ZE W1, W1
005ED8  905800     MOV.B [W0+24], W0
005EDA  DD0048     SL W0, #8, W0
005EDC  700001     IOR W0, W1, W0
005EDE  884300     MOV W0, 0x860
005EE0  37006E     BRA 0x5FBE
1498:                                  }
1499:                              }
1500:                              else if (i == TPAD1_Y) {
005EE2  540FE7     SUB W8, #0x7, [W15]
005EE4  3A0023     BRA NZ, 0x5F2C
1501:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005EE6  804E30     MOV 0x9C6, W0
005EE8  E00000     CP0 W0
005EEA  3A0016     BRA NZ, 0x5F18
1502:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005EEC  804E20     MOV 0x9C4, W0
005EEE  E00000     CP0 W0
005EF0  3A0008     BRA NZ, 0x5F02
1503:                                          analogsBuffer[i] = GetTouchpads()->leftSide.absoluteY;
005EF2  07160F     RCALL GetTouchpads
005EF4  9050D0     MOV.B [W0+21], W1
005EF6  FB8081     ZE W1, W1
005EF8  905060     MOV.B [W0+22], W0
005EFA  DD0048     SL W0, #8, W0
005EFC  700001     IOR W0, W1, W0
005EFE  884310     MOV W0, 0x862
005F00  37005E     BRA 0x5FBE
1504:                                      }
1505:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005F02  500FE1     SUB W0, #0x1, [W15]
005F04  3A005C     BRA NZ, 0x5FBE
1506:                                          analogsBuffer[i] = GetTouchpads()->leftSide.incrementY*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005F06  071605     RCALL GetTouchpads
005F08  906120     MOV.B [W0+34], W2
005F0A  FB8102     ZE W2, W2
005F0C  906030     MOV.B [W0+35], W0
005F0E  DD0048     SL W0, #8, W0
005F10  700002     IOR W0, W2, W0
005F12  B9800C     MUL.SS W0, W12, W0
005F14  884310     MOV W0, 0x862
005F16  370053     BRA 0x5FBE
1507:                                      }
1508:                                  }
1509:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005F18  500FE1     SUB W0, #0x1, [W15]
005F1A  3A0051     BRA NZ, 0x5FBE
1510:                                      analogsBuffer[i] = GetTouchpads()->leftSide.displacementY;
005F1C  0715FA     RCALL GetTouchpads
005F1E  905890     MOV.B [W0+25], W1
005F20  FB8081     ZE W1, W1
005F22  905820     MOV.B [W0+26], W0
005F24  DD0048     SL W0, #8, W0
005F26  700001     IOR W0, W1, W0
005F28  884310     MOV W0, 0x862
005F2A  370049     BRA 0x5FBE
1511:                                  }
1512:                              }
1513:                              else if (i == TPAD2_X){
005F2C  540FE8     SUB W8, #0x8, [W15]
005F2E  3A0023     BRA NZ, 0x5F76
1514:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005F30  804F00     MOV 0x9E0, W0
005F32  E00000     CP0 W0
005F34  3A0016     BRA NZ, 0x5F62
1515:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005F36  804EF0     MOV 0x9DE, W0
005F38  E00000     CP0 W0
005F3A  3A0008     BRA NZ, 0x5F4C
1516:                                          analogsBuffer[i] = GetTouchpads()->rightSide.absoluteX;
005F3C  0715EA     RCALL GetTouchpads
005F3E  9060E0     MOV.B [W0+38], W1
005F40  FB8081     ZE W1, W1
005F42  906070     MOV.B [W0+39], W0
005F44  DD0048     SL W0, #8, W0
005F46  700001     IOR W0, W1, W0
005F48  884320     MOV W0, 0x864
005F4A  370039     BRA 0x5FBE
1517:                                      }
1518:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005F4C  500FE1     SUB W0, #0x1, [W15]
005F4E  3A0037     BRA NZ, 0x5FBE
1519:                                          analogsBuffer[i] = GetTouchpads()->rightSide.incrementX*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005F50  0715E0     RCALL GetTouchpads
005F52  907130     MOV.B [W0+51], W2
005F54  FB8102     ZE W2, W2
005F56  907040     MOV.B [W0+52], W0
005F58  DD0048     SL W0, #8, W0
005F5A  700002     IOR W0, W2, W0
005F5C  B9800C     MUL.SS W0, W12, W0
005F5E  884320     MOV W0, 0x864
005F60  37002E     BRA 0x5FBE
1520:                                      }
1521:                                  }
1522:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005F62  500FE1     SUB W0, #0x1, [W15]
005F64  3A002C     BRA NZ, 0x5FBE
1523:                                      analogsBuffer[i] = GetTouchpads()->rightSide.displacementX;
005F66  0715D5     RCALL GetTouchpads
005F68  9068A0     MOV.B [W0+42], W1
005F6A  FB8081     ZE W1, W1
005F6C  906830     MOV.B [W0+43], W0
005F6E  DD0048     SL W0, #8, W0
005F70  700001     IOR W0, W1, W0
005F72  884320     MOV W0, 0x864
005F74  370024     BRA 0x5FBE
1524:                                  }
1525:                              }
1526:                              else if (i == TPAD2_Y) {
005F76  540FE9     SUB W8, #0x9, [W15]
005F78  3A0022     BRA NZ, 0x5FBE
1527:                                  if (ServoSettings[i].touchpadMode == TPAD ){
005F7A  804FD0     MOV 0x9FA, W0
005F7C  E00000     CP0 W0
005F7E  3A0016     BRA NZ, 0x5FAC
1528:                                      if (ServoSettings[i].absOrRel == ABSOLUTE){
005F80  804FC0     MOV 0x9F8, W0
005F82  E00000     CP0 W0
005F84  3A0008     BRA NZ, 0x5F96
1529:                                          analogsBuffer[i] = GetTouchpads()->rightSide.absoluteY;
005F86  0715C5     RCALL GetTouchpads
005F88  906880     MOV.B [W0+40], W1
005F8A  FB8081     ZE W1, W1
005F8C  906810     MOV.B [W0+41], W0
005F8E  DD0048     SL W0, #8, W0
005F90  700001     IOR W0, W1, W0
005F92  884330     MOV W0, 0x866
005F94  370014     BRA 0x5FBE
1530:                                      }
1531:                                      else if (ServoSettings[i].absOrRel == RELATIVE) { //
005F96  500FE1     SUB W0, #0x1, [W15]
005F98  3A0012     BRA NZ, 0x5FBE
1532:                                          analogsBuffer[i] = GetTouchpads()->rightSide.incrementY*TPAD_INCREMENT_SENSITIVITY;//normalize sensitivity
005F9A  0715BB     RCALL GetTouchpads
005F9C  907150     MOV.B [W0+53], W2
005F9E  FB8102     ZE W2, W2
005FA0  907060     MOV.B [W0+54], W0
005FA2  DD0048     SL W0, #8, W0
005FA4  700002     IOR W0, W2, W0
005FA6  B9800C     MUL.SS W0, W12, W0
005FA8  884330     MOV W0, 0x866
005FAA  370009     BRA 0x5FBE
1533:                                      }
1534:                                  }
1535:                                  else if (ServoSettings[i].touchpadMode == JOYSTICK) { //touchpadMode == JOYSTICK
005FAC  500FE1     SUB W0, #0x1, [W15]
005FAE  3A0007     BRA NZ, 0x5FBE
1536:                                      analogsBuffer[i] = GetTouchpads()->rightSide.displacementY;
005FB0  0715B0     RCALL GetTouchpads
005FB2  9068C0     MOV.B [W0+44], W1
005FB4  FB8081     ZE W1, W1
005FB6  906850     MOV.B [W0+45], W0
005FB8  DD0048     SL W0, #8, W0
005FBA  700001     IOR W0, W1, W0
005FBC  884330     MOV W0, 0x866
1537:                                  }
1538:                              }
1539:                          }
1540:                      }
1541:                  }
1542:              
1543:                  if (GetNewPress()->lStickPress == TRUE) {
005FC8  0715A0     RCALL GetNewPress
005FCA  905880     MOV.B [W0+24], W1
005FCC  FB8081     ZE W1, W1
005FCE  905810     MOV.B [W0+25], W0
005FD0  DD0048     SL W0, #8, W0
005FD2  700001     IOR W0, W1, W0
005FD4  500FE1     SUB W0, #0x1, [W15]
005FD6  3A0005     BRA NZ, 0x5FE2
1544:                      stickHoldToggleL = !stickHoldToggleL; //toggle servo hold on/off
005FD8  EB0080     CLR W1
005FDA  E20886     CP0 stickHoldToggleL
005FDC  3A0001     BRA NZ, 0x5FE0
005FDE  780080     MOV W0, W1
005FE0  884431     MOV W1, stickHoldToggleL
1545:                  }
1546:                  if (GetNewPress()->rStickPress == TRUE) {
005FE2  071593     RCALL GetNewPress
005FE4  9058A0     MOV.B [W0+26], W1
005FE6  FB8081     ZE W1, W1
005FE8  905830     MOV.B [W0+27], W0
005FEA  DD0048     SL W0, #8, W0
005FEC  700001     IOR W0, W1, W0
005FEE  500FE1     SUB W0, #0x1, [W15]
005FF0  3A0005     BRA NZ, 0x5FFC
1547:                      stickHoldToggleR = !stickHoldToggleR; //toggle servo hold on/off
005FF2  EB0080     CLR W1
005FF4  E20884     CP0 stickHoldToggleR
005FF6  3A0001     BRA NZ, 0x5FFA
005FF8  780080     MOV W0, W1
005FFA  884421     MOV W1, stickHoldToggleR
1548:                  }
1549:              
1550:                  if (mecanumSteering >= MECANUM_REMAP_4) //override output with R_STICK_Y signal if we're remapping
005FFC  804010     MOV mecanumSteering, W0
005FFE  500FE1     SUB W0, #0x1, [W15]
006000  360005     BRA LEU, 0x600C
1551:                  {
1552:                      analogsBuffer[mecanumSteering + 2] = analogsBuffer[R_STICK_Y];
006002  400000     ADD W0, W0, W0
006004  400064     ADD W0, #0x4, W0
006006  208541     MOV #0x854, W1
006008  8042D2     MOV 0x85A, W2
00600A  78B002     MOV W2, [W0+W1]
00600C  2091AD     MOV #0x91A, W13
00600E  EB0600     CLR W12
006010  20854B     MOV #0x854, W11
006012  209183     MOV #0x918, W3
006014  9FA7C3     MOV W3, [W15-56]
006016  20E444     MOV #0xE44, W4
006018  9FA7B4     MOV W4, [W15-58]
00601A  200045     MOV #0x4, W5
00601C  9FA7A5     MOV W5, [W15-60]
00601E  2086C8     MOV #0x86C, W8
006020  9FA798     MOV W8, [W15-62]
006022  2090EE     MOV #0x90E, W14
006024  97A02F     MOV [W15-60], W0
006026  5004E4     SUB W0, #0x4, W9
1553:                  }
1554:              
1555:                  for (i = 0; i < NUM_SERVOS; i++) {
0061DC  200300     MOV #0x30, W0
0061DE  560F80     SUB W12, W0, [W15]
0061E0  3AFF21     BRA NZ, 0x6024
1556:                      if ((ServoSettings[i].holdRecall == L_STICK && GetButtonPress()->psButton && GetNewPress()->lStickPress) ||
00602A  200011     MOV #0x1, W1
00602C  108F9D     SUBR W1, [W13], [W15]
00602E  3A000E     BRA NZ, 0x604C
006030  071568     RCALL GetButtonPress
006032  9060A0     MOV.B [W0+34], W1
006034  FB8081     ZE W1, W1
006036  906030     MOV.B [W0+35], W0
006038  DD0048     SL W0, #8, W0
00603A  700001     IOR W0, W1, W0
00603C  320007     BRA Z, 0x604C
00603E  071565     RCALL GetNewPress
006040  905880     MOV.B [W0+24], W1
006042  FB8081     ZE W1, W1
006044  905810     MOV.B [W0+25], W0
006046  DD0048     SL W0, #8, W0
006048  700001     IOR W0, W1, W0
00604A  3A0011     BRA NZ, 0x606E
00604C  200022     MOV #0x2, W2
00604E  110F98     SUBR W2, [W8], [W15]
006050  3A0019     BRA NZ, 0x6084
006052  071557     RCALL GetButtonPress
006054  9060A0     MOV.B [W0+34], W1
006056  FB8081     ZE W1, W1
006058  906030     MOV.B [W0+35], W0
00605A  DD0048     SL W0, #8, W0
00605C  700001     IOR W0, W1, W0
00605E  320012     BRA Z, 0x6084
006060  071554     RCALL GetNewPress
006062  9058A0     MOV.B [W0+26], W1
006064  FB8081     ZE W1, W1
006066  905830     MOV.B [W0+27], W0
006068  DD0048     SL W0, #8, W0
00606A  700001     IOR W0, W1, W0
00606C  32000B     BRA Z, 0x6084
1557:                              (ServoSettings[i].holdRecall == R_STICK && GetButtonPress()->psButton && GetNewPress()->rStickPress)) {
1558:                          ServoSettings[i].servoRecallValue = (unsigned int) (servoState[i] / 100); //store home position, divide by 100 to make unsigned long  fit unsigned int
00606E  97A1BF     MOV [W15-58], W3
006070  BE0013     MOV.D [W3], W0
006072  200642     MOV #0x64, W2
006074  200003     MOV #0x0, W3
006076  07D116     RCALL ___divsi3
006078  BE0100     MOV.D W0, W2
00607A  980410     MOV W0, [W8+2]
1559:                          DataEEWrite(ServoSettings[i].servoRecallValue, EEPROM_SERVO_HOME + i);
00607C  97A0AF     MOV [W15-60], W1
00607E  780002     MOV W2, W0
006080  071888     RCALL DataEEWrite
006082  370036     BRA 0x60F0
1560:                      } //if the hold/recall function is on in relative mode, recall stored value to servostate
1561:                      else if ((ServoSettings[i].absOrRel == RELATIVE && ServoSettings[i].holdRecall == L_STICK && GetNewPress()->lStickPress) || //recall home position
006086  200014     MOV #0x1, W4
006088  120F9E     SUBR W4, [W14], [W15]
00608A  3A001F     BRA NZ, 0x60CA
00608C  120F98     SUBR W4, [W8], [W15]
00608E  3A0007     BRA NZ, 0x609E
006090  07153C     RCALL GetNewPress
006092  905880     MOV.B [W0+24], W1
006094  FB8081     ZE W1, W1
006096  905810     MOV.B [W0+25], W0
006098  DD0048     SL W0, #8, W0
00609A  700001     IOR W0, W1, W0
00609C  3A000D     BRA NZ, 0x60B8
00609E  200015     MOV #0x1, W5
0060A0  128F9A     SUBR W5, [W10], [W15]
0060A2  3A0013     BRA NZ, 0x60CA
0060A4  200020     MOV #0x2, W0
0060A6  100F98     SUBR W0, [W8], [W15]
0060A8  3A0010     BRA NZ, 0x60CA
0060AA  07152F     RCALL GetNewPress
0060AC  9058A0     MOV.B [W0+26], W1
0060AE  FB8081     ZE W1, W1
0060B0  905830     MOV.B [W0+27], W0
0060B2  DD0048     SL W0, #8, W0
0060B4  700001     IOR W0, W1, W0
0060B6  320009     BRA Z, 0x60CA
1562:                              (ServoSettings[i].absOrRel == RELATIVE && ServoSettings[i].holdRecall == R_STICK && GetNewPress()->rStickPress)) {
1563:                          ServoSettings[i].servoRecallValue = DataEERead(EEPROM_SERVO_HOME + i);
0060B8  97A02F     MOV [W15-60], W0
0060BA  071820     RCALL DataEERead
0060BC  780080     MOV W0, W1
0060BE  980410     MOV W0, [W8+2]
1564:                          servoState[i] = ((signed long) (ServoSettings[i].servoRecallValue))*100; //recall home position, multiply by 100 cancel out divide when stored
0060C0  200640     MOV #0x64, W0
0060C2  B80800     MUL.UU W1, W0, W0
0060C4  97A13F     MOV [W15-58], W2
0060C6  BE8900     MOV.D W0, [W2]
0060C8  370013     BRA 0x60F0
1565:                      } //if the hold/recall function is on in absolute mode, overwrite the stick value with stored value
1566:                      else if ((ServoSettings[i].absOrRel == ABSOLUTE && ServoSettings[i].holdRecall == R_STICK && stickHoldToggleR == TRUE) ||
0060CA  E0001A     CP0 [W10]
0060CC  3A000F     BRA NZ, 0x60EC
0060CE  200023     MOV #0x2, W3
0060D0  118F98     SUBR W3, [W8], [W15]
0060D2  3A0003     BRA NZ, 0x60DA
0060D4  804420     MOV stickHoldToggleR, W0
0060D6  500FE1     SUB W0, #0x1, [W15]
0060D8  320006     BRA Z, 0x60E6
0060DA  200014     MOV #0x1, W4
0060DC  120F98     SUBR W4, [W8], [W15]
0060DE  3A0006     BRA NZ, 0x60EC
0060E0  804430     MOV stickHoldToggleL, W0
0060E2  500F84     SUB W0, W4, [W15]
0060E4  3A0003     BRA NZ, 0x60EC
1567:                              (ServoSettings[i].absOrRel == ABSOLUTE && ServoSettings[i].holdRecall == L_STICK && stickHoldToggleL == TRUE)) {
1568:                          analogsBuffer[i] = inputHoldValue[i]; //overwrite stick value with hold value
0060E6  97A29F     MOV [W15-62], W5
0060E8  780D95     MOV [W5], [W11]
0060EA  370002     BRA 0x60F0
1569:                      }
1570:                      else {
1571:                          inputHoldValue[i] = analogsBuffer[i]; //update hold value with stick value
0060EC  97A41F     MOV [W15-62], W8
0060EE  780C1B     MOV [W11], [W8]
1572:                      }
1573:                      //Channel-specific signal conditioning.
1574:                      switch (i) {
0060F0  548FE5     SUB W9, #0x5, [W15]
0060F2  3E0003     BRA GTU, 0x60FA
0060F4  548FE4     SUB W9, #0x4, [W15]
0060F6  31000A     BRA C, 0x610C
0060F8  370005     BRA 0x6104
0060FA  548FE9     SUB W9, #0x9, [W15]
0060FC  360017     BRA LEU, 0x612C
0060FE  548FEB     SUB W9, #0xB, [W15]
006100  3E001B     BRA GTU, 0x6138
006102  370016     BRA 0x6130
1575:                          case L_STICK_X:
1576:                          case L_STICK_Y:
1577:                          case R_STICK_X:
1578:                          case R_STICK_Y:
1579:                              sensorSignal = (signed int) analogsBuffer[i] - ServoSettings[i].zeroPosition;
006104  78009B     MOV [W11], W1
006106  97A04F     MOV [W15-56], W0
006108  508410     SUB W1, [W0], W8
00610A  37001B     BRA 0x6142
1580:                              break;
1581:                          case L_TRIG:
1582:                          case R_TRIG:
1583:                              if (triggerLink == TRUE) {
00610C  805660     MOV triggerLink, W0
00610E  500FE1     SUB W0, #0x1, [W15]
006110  3A0007     BRA NZ, 0x6120
1584:                                  sensorSignal = ((signed int) analogsBuffer[R_TRIG]-(signed int) analogsBuffer[L_TRIG]) / 2;
006112  8042E0     MOV 0x85C, W0
006114  B5085E     SUB 0x85E, WREG
006116  200022     MOV #0x2, W2
006118  090011     REPEAT #0x11
00611A  D80002     DIV.SW W0, W2
00611C  780400     MOV W0, W8
00611E  370011     BRA 0x6142
1585:                              }
1586:                              else {
1587:                                  sensorSignal = (signed int) analogsBuffer[i] - ServoSettings[i].zeroPosition - 128;
006120  78019B     MOV [W11], W3
006122  97A14F     MOV [W15-56], W2
006124  518092     SUB W3, [W2], W1
006126  2FF800     MOV #0xFF80, W0
006128  408400     ADD W1, W0, W8
00612A  37000B     BRA 0x6142
1588:                              }
1589:                              break;
1590:                          case TPAD1_X:
1591:                          case TPAD1_Y:
1592:                          case TPAD2_X:
1593:                          case TPAD2_Y:
1594:                              sensorSignal = (signed int) analogsBuffer[i];
00612C  78041B     MOV [W11], W8
00612E  370009     BRA 0x6142
1595:                              break;
1596:                          case TILT_X:
1597:                          case TILT_Y:
1598:              
1599:                              sensorSignal = (signed int) analogsBuffer[i] - ServoSettings[i].zeroPosition;
006130  78029B     MOV [W11], W5
006132  97A24F     MOV [W15-56], W4
006134  528414     SUB W5, [W4], W8
006136  370005     BRA 0x6142
1600:                              break;
1601:                          default:
1602:                              sensorSignal = (signed int) analogsBuffer[i] - ServoSettings[i].zeroPosition;
006138  78009B     MOV [W11], W1
00613A  97A04F     MOV [W15-56], W0
00613C  508410     SUB W1, [W0], W8
1603:                              UART2PrintString("Error:ch\n\r");
00613E  28B100     MOV #0x8B10, W0
006140  071A9E     RCALL UART2PrintString
1604:                              break;
1605:                      }
1606:                      // special case for remapping r-stick y-axis when using mecanum mixing remapping
1607:                      if (mecanumSteering >= MECANUM_REMAP_4 && i == (mecanumSteering + 2)) {
006142  804010     MOV mecanumSteering, W0
006144  500FE1     SUB W0, #0x1, [W15]
006146  360008     BRA LEU, 0x6158
006148  E88000     INC2 W0, W0
00614A  500F89     SUB W0, W9, [W15]
00614C  3A0005     BRA NZ, 0x6158
1608:                          sensorSignal = (signed int) analogsBuffer[i] - ServoSettings[R_STICK_Y].zeroPosition; //use the original home position calibration.
00614E  448089     ADD W9, W9, W1
006150  208540     MOV #0x854, W0
006152  7800E1     MOV [W1+W0], W1
006154  804B30     MOV 0x966, W0
006156  508400     SUB W1, W0, W8
1609:                      }
1610:              
1611:                      //Apply deadband
1612:                      deadband = (signed int) ServoSettings[i].deadband;
00615A  97B0FD     MOV [W13-18], W1
1613:                      if (sensorSignal > deadband) {
00615C  540F81     SUB W8, W1, [W15]
00615E  340002     BRA LE, 0x6164
1614:                          sensorSignal = sensorSignal - deadband;
006160  540181     SUB W8, W1, W3
006162  370005     BRA 0x616E
1615:                      }
1616:                      else if (sensorSignal < -deadband) {
006164  EA0001     NEG W1, W0
006166  EB0180     CLR W3
006168  540F80     SUB W8, W0, [W15]
00616A  3D0001     BRA GE, 0x616E
1617:                          sensorSignal = sensorSignal + deadband;
00616C  440181     ADD W8, W1, W3
1618:                      }
1619:                      else {
1620:                          sensorSignal = 0;
1621:                      }
1622:              
1623:                      switch (i){
00616E  548066     SUB W9, #0x6, W0
006170  500FE3     SUB W0, #0x3, [W15]
006172  3E0012     BRA GTU, 0x6198
1624:                          case TPAD1_X:
1625:                          case TPAD1_Y:
1626:                          case TPAD2_X:
1627:                          case TPAD2_Y:
1628:                              //normalize
1629:                              scaledSignal[i] = (signed long) ServoSettings[i].sensitivity * (signed long) sensorSignal/2 + ServoSettings[i].trim * 10; //beware of overflow
006174  2FF4A2     MOV #0xFF4A, W2
006176  41010F     ADD W2, W15, W2
006178  41020C     ADD W2, W12, W4
00617A  97B805     MOV [W5-16], W0
00617C  B99800     MUL.SS W3, W0, W0
00617E  B90961     MUL.SU W1, #1, W2
006180  DE194F     LSR W3, #15, W2
006182  200003     MOV #0x0, W3
006184  400102     ADD W0, W2, W2
006186  488183     ADDC W1, W3, W3
006188  D18183     ASR W3, W3
00618A  D38102     RRC W2, W2
00618C  97B865     MOV [W5-4], W0
00618E  B9006A     MUL.SU W0, #10, W0
006190  DE80CF     ASR W0, #15, W1
006192  411A00     ADD W2, W0, [W4++]
006194  499201     ADDC W3, W1, [W4--]
006196  37000A     BRA 0x61AC
1630:                              break;
1631:                          default:
1632:                              scaledSignal[i] = (signed long) ServoSettings[i].sensitivity * (signed long) sensorSignal + ServoSettings[i].trim * 10; //beware of overflow
006198  2FF4A8     MOV #0xFF4A, W8
00619A  44040F     ADD W8, W15, W8
00619C  44020C     ADD W8, W12, W4
00619E  97B905     MOV [W5-16], W2
0061A0  B99902     MUL.SS W3, W2, W2
0061A2  97B865     MOV [W5-4], W0
0061A4  B9006A     MUL.SU W0, #10, W0
0061A6  DE80CF     ASR W0, #15, W1
0061A8  411A00     ADD W2, W0, [W4++]
0061AA  499201     ADDC W3, W1, [W4--]
1633:                              break;
1634:                      }
1635:                      scaledSignalOriginal[i] = scaledSignal[i]; //we'll overwrite some signals if we mix, so make a copy
0061AC  2FF7A2     MOV #0xFF7A, W2
0061AE  41010F     ADD W2, W15, W2
0061B0  41000C     ADD W2, W12, W0
0061B2  2FF4A9     MOV #0xFF4A, W9
0061B4  44848F     ADD W9, W15, W9
0061B6  44808C     ADD W9, W12, W1
0061B8  BE0211     MOV.D [W1], W4
0061BA  BE8804     MOV.D W4, [W0]
0061BC  4686FA     ADD W13, #0x1A, W13
0061BE  460664     ADD W12, #0x4, W12
0061C0  E8858B     INC2 W11, W11
0061C2  97A2CF     MOV [W15-56], W5
0061C4  4282FA     ADD W5, #0x1A, W5
0061C6  9FA7C5     MOV W5, [W15-56]
0061C8  97A43F     MOV [W15-58], W8
0061CA  440464     ADD W8, #0x4, W8
0061CC  9FA7B8     MOV W8, [W15-58]
0061CE  97A4AF     MOV [W15-60], W9
0061D0  E80489     INC W9, W9
0061D2  9FA7A9     MOV W9, [W15-60]
0061D4  97A01F     MOV [W15-62], W0
0061D6  E88000     INC2 W0, W0
0061D8  9FA790     MOV W0, [W15-62]
0061DA  47077A     ADD W14, #0x1A, W14
1636:                  }
1637:              
1638:                  //////////////////////////////////////////////////////////
1639:                  //Split the loop to finish applying scalings to all the signals first, so that we can mix the outputs later with the scaled signals.
1640:              
1641:                  for (i = 0; i < NUM_SERVOS; i++) {
0063BA  E8050A     INC W10, W10
0063BC  470764     ADD W14, #0x4, W14
0063BE  4686E4     ADD W13, #0x4, W13
0063C0  46067A     ADD W12, #0x1A, W12
0063C2  550FEC     SUB W10, #0xC, [W15]
0063C4  3AFF44     BRA NZ, 0x624E
1642:                      //mix signals for Mecanum wheels
1643:                      if (mecanumSteering != MECANUM_OFF) {
00624E  97B06F     MOV [W15-20], W0
006250  E00000     CP0 W0
006252  32001C     BRA Z, 0x628C
1644:                          switch (i) {
006254  550FE1     SUB W10, #0x1, [W15]
006256  32000B     BRA Z, 0x626E
006258  390005     BRA NC, 0x6264
00625A  550FE2     SUB W10, #0x2, [W15]
00625C  32000D     BRA Z, 0x6278
00625E  550FE3     SUB W10, #0x3, [W15]
006260  3A0037     BRA NZ, 0x62D0
006262  37000F     BRA 0x6282
1645:                              case L_STICK_X: //left front wheel
1646:                                  scaledSignal[L_STICK_X] = scaledSignalOriginal[L_STICK_Y] - scaledSignalOriginal[R_STICK_X] - scaledSignalOriginal[L_STICK_X];
006230  500002     SUB W0, W2, W0
006232  588083     SUBB W1, W3, W1
006234  9FB7C0     MOV W0, [W15-24]
006236  9FB7D1     MOV W1, [W15-22]
006238  EB0500     CLR W10
00623A  20E44E     MOV #0xE44, W14
00623C  2FF4AD     MOV #0xFF4A, W13
00623E  46868F     ADD W13, W15, W13
006240  20904C     MOV #0x904, W12
006242  804015     MOV mecanumSteering, W5
006244  9FB7E5     MOV W5, [W15-20]
006246  8057C8     MOV lStickDiffMix, W8
006248  9FB7F8     MOV W8, [W15-18]
00624A  8057D9     MOV rStickDiffMix, W9
00624C  9FBF89     MOV W9, [W15-16]
006264  97B14F     MOV [W15-24], W2
006266  97B1DF     MOV [W15-22], W3
006268  9F27D2     MOV W2, [W15-182]
00626A  9F27E3     MOV W3, [W15-180]
00626C  370031     BRA 0x62D0
1647:                                  break;
1648:                              case L_STICK_Y: //left rear wheel
1649:                                  scaledSignal[L_STICK_Y] = scaledSignalOriginal[L_STICK_Y] - scaledSignalOriginal[R_STICK_X] + scaledSignalOriginal[L_STICK_X];
006224  500006     SUB W0, W6, W0
006226  588087     SUBB W1, W7, W1
006228  400202     ADD W0, W2, W4
00622A  488283     ADDC W1, W3, W5
00622C  9FB7A4     MOV W4, [W15-28]
00622E  9FB7B5     MOV W5, [W15-26]
00626E  97B22F     MOV [W15-28], W4
006270  97B2BF     MOV [W15-26], W5
006272  9F27F4     MOV W4, [W15-178]
006274  9F2F85     MOV W5, [W15-176]
006276  37002C     BRA 0x62D0
1650:                                  break;
1651:                              case R_STICK_X: //right front wheel
1652:                                  scaledSignal[R_STICK_X] = scaledSignalOriginal[L_STICK_Y] + scaledSignalOriginal[R_STICK_X] + scaledSignalOriginal[L_STICK_X];
00621C  420202     ADD W4, W2, W4
00621E  4A8283     ADDC W5, W3, W5
006220  9FB784     MOV W4, [W15-32]
006222  9FB795     MOV W5, [W15-30]
006278  97B40F     MOV [W15-32], W8
00627A  97B49F     MOV [W15-30], W9
00627C  9F2F98     MOV W8, [W15-174]
00627E  9F2FA9     MOV W9, [W15-172]
006280  370027     BRA 0x62D0
1653:                                  break;
1654:                              case R_STICK_Y: //right rear wheel
1655:                                  scaledSignal[R_STICK_Y] = scaledSignalOriginal[L_STICK_Y] + scaledSignalOriginal[R_STICK_X] - scaledSignalOriginal[L_STICK_X];
006210  400206     ADD W0, W6, W4
006212  488287     ADDC W1, W7, W5
006214  520402     SUB W4, W2, W8
006216  5A8483     SUBB W5, W3, W9
006218  9FAFE8     MOV W8, [W15-36]
00621A  9FAFF9     MOV W9, [W15-34]
006282  97A86F     MOV [W15-36], W0
006284  97A8FF     MOV [W15-34], W1
006286  9F2FB0     MOV W0, [W15-170]
006288  9F2FC1     MOV W1, [W15-168]
00628A  370022     BRA 0x62D0
1656:                                  break;
1657:                              default:
1658:                                  break;
1659:                          }
1660:                      }
1661:                      else //if mecanum mixer is off
1662:                      {
1663:                          if (lStickDiffMix == TRUE) //check for diff steering
00628C  97B0FF     MOV [W15-18], W1
00628E  508FE1     SUB W1, #0x1, [W15]
006290  3A000E     BRA NZ, 0x62AE
1664:                          {
1665:                              switch (i) {
006292  E0000A     CP0 W10
006294  320003     BRA Z, 0x629C
006296  550FE1     SUB W10, #0x1, [W15]
006298  3A000A     BRA NZ, 0x62AE
00629A  370005     BRA 0x62A6
1666:                                  case L_STICK_X:
1667:                                      scaledSignal[L_STICK_X] = scaledSignalOriginal[L_STICK_Y] - scaledSignalOriginal[L_STICK_X]; //left wheel channel
006208  500202     SUB W0, W2, W4
00620A  588283     SUBB W1, W3, W5
00620C  9FAFC4     MOV W4, [W15-40]
00620E  9FAFD5     MOV W5, [W15-38]
00629C  97A94F     MOV [W15-40], W2
00629E  97A9DF     MOV [W15-38], W3
0062A0  9F27D2     MOV W2, [W15-182]
0062A2  9F27E3     MOV W3, [W15-180]
0062A4  370004     BRA 0x62AE
1668:                                      break;
1669:                                  case L_STICK_Y:
1670:                                      scaledSignal[L_STICK_Y] = scaledSignalOriginal[L_STICK_Y] + scaledSignalOriginal[L_STICK_X]; //right wheel channel
0061FA  97387F     MOV [W15-130], W0
0061FC  97808F     MOV [W15-128], W1
0061FE  BE0112     MOV.D [W2], W2
006200  410400     ADD W2, W0, W8
006202  498481     ADDC W3, W1, W9
006204  9FAFA8     MOV W8, [W15-44]
006206  9FAFB9     MOV W9, [W15-42]
0062A6  97AA2F     MOV [W15-44], W4
0062A8  97AABF     MOV [W15-42], W5
0062AA  9F27F4     MOV W4, [W15-178]
0062AC  9F2F85     MOV W5, [W15-176]
1671:                                      break;
1672:                                  default:
1673:                                      break;
1674:                              }
1675:                          }
1676:                          if (rStickDiffMix == TRUE) //check for diff steering
0062AE  97BA8F     MOV [W15-16], W5
0062B0  528FE1     SUB W5, #0x1, [W15]
0062B2  3A000E     BRA NZ, 0x62D0
1677:                          {
1678:                              switch (i) {
0062B4  550FE2     SUB W10, #0x2, [W15]
0062B6  320003     BRA Z, 0x62BE
0062B8  550FE3     SUB W10, #0x3, [W15]
0062BA  3A000A     BRA NZ, 0x62D0
0062BC  370005     BRA 0x62C8
1679:                                  case R_STICK_X:
1680:                                      scaledSignal[R_STICK_X] = scaledSignalOriginal[R_STICK_Y] - scaledSignalOriginal[R_STICK_X]; //left wheel channel
0061F2  500006     SUB W0, W6, W0
0061F4  588087     SUBB W1, W7, W1
0061F6  9FAF80     MOV W0, [W15-48]
0061F8  9FAF91     MOV W1, [W15-46]
0062BE  97AC0F     MOV [W15-48], W8
0062C0  97AC9F     MOV [W15-46], W9
0062C2  9F2F98     MOV W8, [W15-174]
0062C4  9F2FA9     MOV W9, [W15-172]
0062C6  370004     BRA 0x62D0
1681:                                      break;
1682:                                  case R_STICK_Y:
1683:                                      scaledSignal[R_STICK_Y] = scaledSignalOriginal[R_STICK_Y] + scaledSignalOriginal[R_STICK_X]; //right wheel channel
0061E2  97803F     MOV [W15-122], W0
0061E4  9780CF     MOV [W15-120], W1
0061E6  97831F     MOV [W15-126], W6
0061E8  9783AF     MOV [W15-124], W7
0061EA  430200     ADD W6, W0, W4
0061EC  4B8281     ADDC W7, W1, W5
0061EE  9FA7E4     MOV W4, [W15-52]
0061F0  9FA7F5     MOV W5, [W15-50]
0062C8  97A06F     MOV [W15-52], W0
0062CA  97A0FF     MOV [W15-50], W1
0062CC  9F2FB0     MOV W0, [W15-170]
0062CE  9F2FC1     MOV W1, [W15-168]
1684:                                      break;
1685:                                  default:
1686:                                      break;
1687:                              }
1688:                          }
1689:                      }
1690:              
1691:                      //*******************CHECK BOUNDARIES AND WRITE OUTPUTS*****************************//
1692:                      //Check direction
1693:                      if (ServoSettings[i].direction == FORWARD) {
0062D0  90004C     MOV [W12+8], W0
0062D2  200016     MOV #0x1, W6
0062D4  E00000     CP0 W0
0062D6  320001     BRA Z, 0x62DA
0062D8  EB8300     SETM W6
1694:                          direction = 1;
1695:                      }
1696:                      else {
1697:                          direction = -1;
1698:                      }
1699:              
1700:                      //////////////SERVO OUTPUT////////////////////////////////////
1701:                      //Servo Position Mode
1702:                      if (ServoSettings[i].absOrRel == ABSOLUTE) {
0062DA  90005C     MOV [W12+10], W0
0062DC  E00000     CP0 W0
0062DE  3A0032     BRA NZ, 0x6344
1703:                          //check range of motion
1704:                          range = ServoSettings[i].range * 10;
0062E2  90001C     MOV [W12+2], W0
0062E4  B9006A     MUL.SU W0, #10, W0
0062E6  DE80CF     ASR W0, #15, W1
1705:                          if (scaledSignal[i] > range) {
0062EA  BE011D     MOV.D [W13], W2
0062EC  500F82     SUB W0, W2, [W15]
0062EE  588F83     SUBB W1, W3, [W15]
0062F0  3D0002     BRA GE, 0x62F6
1706:                              scaledSignal[i] = range;
0062F2  BE8E80     MOV.D W0, [W13]
0062F4  370006     BRA 0x6302
1707:                          }
1708:                          else if (scaledSignal[i] < -range) {
0062F6  100060     SUBR W0, #0x0, W0
0062F8  1880E0     SUBBR W1, #0x0, W1
0062FA  510F80     SUB W2, W0, [W15]
0062FC  598F81     SUBB W3, W1, [W15]
0062FE  3D0001     BRA GE, 0x6302
1709:                              scaledSignal[i] = -range;
006300  BE8E80     MOV.D W0, [W13]
1710:                          }
1711:                          //check stops
1712:                          output = 3000 + ServoSettings[i].offset * 10 + direction * scaledSignal[i]; //output, 0.5uS per count
006302  780014     MOV [W4], W0
006304  B9006A     MUL.SU W0, #10, W0
006306  20BB88     MOV #0xBB8, W8
006308  440400     ADD W8, W0, W8
00630A  DEC4CF     ASR W8, #15, W9
00630C  DEB3CF     ASR W6, #15, W7
00630E  780215     MOV [W5], W4
006310  B83104     MUL.UU W6, W4, W2
006312  900015     MOV [W5+2], W0
006314  B9B000     MUL.SS W6, W0, W0
006316  400003     ADD W0, W3, W0
006318  B9A207     MUL.SS W4, W7, W4
00631A  400184     ADD W0, W4, W3
00631C  410108     ADD W2, W8, W2
00631E  498189     ADDC W3, W9, W3
1713:                          if (output > STOP_HIGH) {
006320  2157C0     MOV #0x157C, W0
006322  200001     MOV #0x0, W1
006324  510F80     SUB W2, W0, [W15]
006326  598F81     SUBB W3, W1, [W15]
006328  340002     BRA LE, 0x632E
00632A  BE0100     MOV.D W0, W2
00632C  370006     BRA 0x633A
1714:                              output = STOP_HIGH;
1715:                          }
1716:                          else if (output < STOP_LOW) {
00632E  201F31     MOV #0x1F3, W1
006330  510F81     SUB W2, W1, [W15]
006332  598FE0     SUBB W3, #0x0, [W15]
006334  3C0002     BRA GT, 0x633A
006336  201F42     MOV #0x1F4, W2
006338  200003     MOV #0x0, W3
1717:                              output = STOP_LOW;
1718:                          }
1719:              
1720:                          //write output
1721:                          OCxR_REG_PTRS_buffer[i] = output;
00633A  45000A     ADD W10, W10, W0
00633C  2FFAA4     MOV #0xFFAA, W4
00633E  42020F     ADD W4, W15, W4
006340  783202     MOV W2, [W4+W0]
006342  37003B     BRA 0x63BA
1722:                      }
1723:                          /////////////////SERVO RELATIVE MODE/////////////////
1724:                      else if (ServoSettings[i].absOrRel == RELATIVE) {
006344  500FE1     SUB W0, #0x1, [W15]
006346  3A0039     BRA NZ, 0x63BA
1725:                          //scale to normalize sensitivity.  Multiply everything by 100, then divide by 100 counter discretization noise when scaling.
1726:               
1727:                          servoState[i] = servoState[i] + direction * scaledSignal[i];             
00634A  DEB3CF     ASR W6, #15, W7
00634C  78021D     MOV [W13], W4
00634E  B83104     MUL.UU W6, W4, W2
006350  90001D     MOV [W13+2], W0
006352  B9B000     MUL.SS W6, W0, W0
006354  400003     ADD W0, W3, W0
006356  B9A207     MUL.SS W4, W7, W4
006358  400184     ADD W0, W4, W3
00635A  41043E     ADD W2, [W14++], W8
00635C  4984AE     ADDC W3, [W14--], W9
00635E  BE8F08     MOV.D W8, [W14]
1728:                  
1729:              
1730:                          range = 300000 + 1000 * (signed long) (ServoSettings[i].offset + ServoSettings[i].range); //set stops, beware of overflow!
006360  78011C     MOV [W12], W2
006362  90039C     MOV [W12+2], W7
006364  410007     ADD W2, W7, W0
006366  203E86     MOV #0x3E8, W6
006368  B98006     MUL.SS W0, W6, W0
00636A  293E04     MOV #0x93E0, W4
00636C  200045     MOV #0x4, W5
00636E  420000     ADD W4, W0, W0
006370  4A8081     ADDC W5, W1, W1
1731:                          range2 = 300000 + 1000 * (signed long) (ServoSettings[i].offset - ServoSettings[i].range); //set stops
006372  510107     SUB W2, W7, W2
006374  B99106     MUL.SS W2, W6, W2
006376  420102     ADD W4, W2, W2
006378  4A8183     ADDC W5, W3, W3
1732:              
1733:                          if (servoState[i] > range) {
00637A  540F80     SUB W8, W0, [W15]
00637C  5C8F81     SUBB W9, W1, [W15]
00637E  340002     BRA LE, 0x6384
1734:                              servoState[i] = range;
006380  BE8F00     MOV.D W0, [W14]
006382  370004     BRA 0x638C
1735:                          }
1736:                          else if (servoState[i] < range2) {
006384  540F82     SUB W8, W2, [W15]
006386  5C8F83     SUBB W9, W3, [W15]
006388  3D0001     BRA GE, 0x638C
1737:                              servoState[i] = range2;
00638A  BE8F02     MOV.D W2, [W14]
1738:                          }
1739:                          //write output
1740:                          if (servoState[i] > (signed long) STOP_HIGH * 100) {
00638C  BE001B     MOV.D [W11], W0
00638E  264702     MOV #0x6470, W2
006390  200083     MOV #0x8, W3
006392  500F82     SUB W0, W2, [W15]
006394  588F83     SUBB W1, W3, [W15]
006396  340002     BRA LE, 0x639C
1741:                              servoState[i] = (signed long) STOP_HIGH * 100;
006398  BE8D82     MOV.D W2, [W11]
00639A  370007     BRA 0x63AA
1742:                          }
1743:                          else if (servoState[i] < (signed long) STOP_LOW * 100) {
00639C  2C34F8     MOV #0xC34F, W8
00639E  500F88     SUB W0, W8, [W15]
0063A0  588FE0     SUBB W1, #0x0, [W15]
0063A2  3C0003     BRA GT, 0x63AA
1744:                              servoState[i] = (signed long) STOP_LOW * 100;
0063A4  2C3500     MOV #0xC350, W0
0063A6  200001     MOV #0x0, W1
0063A8  BE8D80     MOV.D W0, [W11]
1745:                          }
1746:                          OCxR_REG_PTRS_buffer[i] = servoState[i] / 100;
0063AA  45040A     ADD W10, W10, W8
0063AC  BE001B     MOV.D [W11], W0
0063AE  200642     MOV #0x64, W2
0063B0  200003     MOV #0x0, W3
0063B2  07CF78     RCALL ___divsi3
0063B4  2FFAA9     MOV #0xFFAA, W9
0063B6  44848F     ADD W9, W15, W9
0063B8  7C3480     MOV W0, [W9+W8]
1747:                      }
1748:                  } //end NUM_SERVO for loop
1749:                  //
1750:                  //SPI Override here.  Incoming value is the pulse width in microseconds, every count = 0.5 uS.
1751:                  
1752:                  if (GetSpiInputPacket()->overrideLStickX) OCxR_REG_PTRS_buffer[L_STICK_X] = GetSpiInputPacket()->lStickX*2;
0063C6  071C40     RCALL GetSpiInputPacket
0063C8  904800     MOV.B [W0+8], W0
0063CA  A30800     BTST.Z W0, #0
0063CC  320008     BRA Z, 0x63DE
0063CE  071C3C     RCALL GetSpiInputPacket
0063D0  9048C0     MOV.B [W0+12], W1
0063D2  FB8081     ZE W1, W1
0063D4  904850     MOV.B [W0+13], W0
0063D6  DD0048     SL W0, #8, W0
0063D8  700001     IOR W0, W1, W0
0063DA  400000     ADD W0, W0, W0
0063DC  9F97D0     MOV W0, [W15-86]
1753:                  if (GetSpiInputPacket()->overrideLStickY) OCxR_REG_PTRS_buffer[L_STICK_Y] = GetSpiInputPacket()->lStickY*2;
0063DE  071C34     RCALL GetSpiInputPacket
0063E0  904800     MOV.B [W0+8], W0
0063E2  A31800     BTST.Z W0, #1
0063E4  320008     BRA Z, 0x63F6
0063E6  071C30     RCALL GetSpiInputPacket
0063E8  9048E0     MOV.B [W0+14], W1
0063EA  FB8081     ZE W1, W1
0063EC  904870     MOV.B [W0+15], W0
0063EE  DD0048     SL W0, #8, W0
0063F0  700001     IOR W0, W1, W0
0063F2  400000     ADD W0, W0, W0
0063F4  9F97E0     MOV W0, [W15-84]
1754:                  if (GetSpiInputPacket()->overrideRStickX) OCxR_REG_PTRS_buffer[R_STICK_X] = GetSpiInputPacket()->rStickY*2;
0063F6  071C28     RCALL GetSpiInputPacket
0063F8  904800     MOV.B [W0+8], W0
0063FA  A32800     BTST.Z W0, #2
0063FC  320008     BRA Z, 0x640E
0063FE  071C24     RCALL GetSpiInputPacket
006400  9050A0     MOV.B [W0+18], W1
006402  FB8081     ZE W1, W1
006404  905030     MOV.B [W0+19], W0
006406  DD0048     SL W0, #8, W0
006408  700001     IOR W0, W1, W0
00640A  400000     ADD W0, W0, W0
00640C  9F97F0     MOV W0, [W15-82]
1755:                  if (GetSpiInputPacket()->overrideRStickY) OCxR_REG_PTRS_buffer[R_STICK_Y] = GetSpiInputPacket()->rStickY*2;
00640E  071C1C     RCALL GetSpiInputPacket
006410  904800     MOV.B [W0+8], W0
006412  A33800     BTST.Z W0, #3
006414  320008     BRA Z, 0x6426
006416  071C18     RCALL GetSpiInputPacket
006418  9050A0     MOV.B [W0+18], W1
00641A  FB8081     ZE W1, W1
00641C  905030     MOV.B [W0+19], W0
00641E  DD0048     SL W0, #8, W0
006420  700001     IOR W0, W1, W0
006422  400000     ADD W0, W0, W0
006424  9F9F80     MOV W0, [W15-80]
1756:                  if (GetSpiInputPacket()->overrideLTriggerAnalog) OCxR_REG_PTRS_buffer[L_TRIG] = GetSpiInputPacket()->lTriggerAnalog*2;
006426  071C10     RCALL GetSpiInputPacket
006428  904800     MOV.B [W0+8], W0
00642A  A34800     BTST.Z W0, #4
00642C  320008     BRA Z, 0x643E
00642E  071C0C     RCALL GetSpiInputPacket
006430  9050C0     MOV.B [W0+20], W1
006432  FB8081     ZE W1, W1
006434  905050     MOV.B [W0+21], W0
006436  DD0048     SL W0, #8, W0
006438  700001     IOR W0, W1, W0
00643A  400000     ADD W0, W0, W0
00643C  9F9F90     MOV W0, [W15-78]
1757:                  if (GetSpiInputPacket()->overrideRTriggerAnalog) OCxR_REG_PTRS_buffer[R_TRIG] = GetSpiInputPacket()->rTriggerAnalog*2;
00643E  071C04     RCALL GetSpiInputPacket
006440  904800     MOV.B [W0+8], W0
006442  A35800     BTST.Z W0, #5
006444  320008     BRA Z, 0x6456
006446  071C00     RCALL GetSpiInputPacket
006448  9050E0     MOV.B [W0+22], W1
00644A  FB8081     ZE W1, W1
00644C  905070     MOV.B [W0+23], W0
00644E  DD0048     SL W0, #8, W0
006450  700001     IOR W0, W1, W0
006452  400000     ADD W0, W0, W0
006454  9F9FA0     MOV W0, [W15-76]
1758:                  if (GetSpiInputPacket()->overrideTpad1X) OCxR_REG_PTRS_buffer[TPAD1_X] = GetSpiInputPacket()->tpad1X*2;
006456  071BF8     RCALL GetSpiInputPacket
006458  904800     MOV.B [W0+8], W0
00645A  A36800     BTST.Z W0, #6
00645C  320008     BRA Z, 0x646E
00645E  071BF4     RCALL GetSpiInputPacket
006460  905880     MOV.B [W0+24], W1
006462  FB8081     ZE W1, W1
006464  905810     MOV.B [W0+25], W0
006466  DD0048     SL W0, #8, W0
006468  700001     IOR W0, W1, W0
00646A  400000     ADD W0, W0, W0
00646C  9F9FB0     MOV W0, [W15-74]
1759:                  if (GetSpiInputPacket()->overrideTpad1Y) OCxR_REG_PTRS_buffer[TPAD1_Y] = GetSpiInputPacket()->tpad1Y*2;
00646E  071BEC     RCALL GetSpiInputPacket
006470  904800     MOV.B [W0+8], W0
006472  E00400     CP0.B W0
006474  3D0008     BRA GE, 0x6486
006476  071BE8     RCALL GetSpiInputPacket
006478  9058A0     MOV.B [W0+26], W1
00647A  FB8081     ZE W1, W1
00647C  905830     MOV.B [W0+27], W0
00647E  DD0048     SL W0, #8, W0
006480  700001     IOR W0, W1, W0
006482  400000     ADD W0, W0, W0
006484  9F9FC0     MOV W0, [W15-72]
1760:                  if (GetSpiInputPacket()->overrideTpad2X) OCxR_REG_PTRS_buffer[TPAD2_X] = GetSpiInputPacket()->tpad2X*2;
006486  071BE0     RCALL GetSpiInputPacket
006488  904810     MOV.B [W0+9], W0
00648A  A30800     BTST.Z W0, #0
00648C  320008     BRA Z, 0x649E
00648E  071BDC     RCALL GetSpiInputPacket
006490  9058C0     MOV.B [W0+28], W1
006492  FB8081     ZE W1, W1
006494  905850     MOV.B [W0+29], W0
006496  DD0048     SL W0, #8, W0
006498  700001     IOR W0, W1, W0
00649A  400000     ADD W0, W0, W0
00649C  9F9FD0     MOV W0, [W15-70]
1761:                  if (GetSpiInputPacket()->overrideTpad2Y) OCxR_REG_PTRS_buffer[TPAD2_Y] = GetSpiInputPacket()->tpad2Y*2;
00649E  071BD4     RCALL GetSpiInputPacket
0064A0  904810     MOV.B [W0+9], W0
0064A2  A31800     BTST.Z W0, #1
0064A4  320008     BRA Z, 0x64B6
0064A6  071BD0     RCALL GetSpiInputPacket
0064A8  9058E0     MOV.B [W0+30], W1
0064AA  FB8081     ZE W1, W1
0064AC  905870     MOV.B [W0+31], W0
0064AE  DD0048     SL W0, #8, W0
0064B0  700001     IOR W0, W1, W0
0064B2  400000     ADD W0, W0, W0
0064B4  9F9FE0     MOV W0, [W15-68]
1762:                  if (GetSpiInputPacket()->overrideAccelX) OCxR_REG_PTRS_buffer[TILT_X] = GetSpiInputPacket()->accelX*2;
0064B6  071BC8     RCALL GetSpiInputPacket
0064B8  904810     MOV.B [W0+9], W0
0064BA  A32800     BTST.Z W0, #2
0064BC  320008     BRA Z, 0x64CE
0064BE  071BC4     RCALL GetSpiInputPacket
0064C0  906080     MOV.B [W0+32], W1
0064C2  FB8081     ZE W1, W1
0064C4  906010     MOV.B [W0+33], W0
0064C6  DD0048     SL W0, #8, W0
0064C8  700001     IOR W0, W1, W0
0064CA  400000     ADD W0, W0, W0
0064CC  9F9FF0     MOV W0, [W15-66]
1763:                  if (GetSpiInputPacket()->overrideAccelZ) OCxR_REG_PTRS_buffer[TILT_Y] = GetSpiInputPacket()->accelZ*2;
0064CE  071BBC     RCALL GetSpiInputPacket
0064D0  904810     MOV.B [W0+9], W0
0064D2  A33800     BTST.Z W0, #3
0064D4  320008     BRA Z, 0x64E6
0064D6  071BB8     RCALL GetSpiInputPacket
0064D8  9060A0     MOV.B [W0+34], W1
0064DA  FB8081     ZE W1, W1
0064DC  906030     MOV.B [W0+35], W0
0064DE  DD0048     SL W0, #8, W0
0064E0  700001     IOR W0, W1, W0
0064E2  400000     ADD W0, W0, W0
0064E4  9FA780     MOV W0, [W15-64]
1764:                   
1765:                      
1766:                  //calculate values for the servo signals generated by T3
1767:                  if (OCxR_REG_PTRS_buffer[10] > 10000) OCxR_REG_PTRS_buffer[10] = 10000;
0064E6  227101     MOV #0x2710, W1
0064E8  97987F     MOV [W15-66], W0
0064EA  500F81     SUB W0, W1, [W15]
0064EC  360001     BRA LEU, 0x64F0
0064EE  9F9FF1     MOV W1, [W15-66]
1768:                  if (OCxR_REG_PTRS_buffer[11] > 10000) OCxR_REG_PTRS_buffer[11] = 10000;
0064F0  227101     MOV #0x2710, W1
0064F2  97A00F     MOV [W15-64], W0
0064F4  500F81     SUB W0, W1, [W15]
0064F6  360001     BRA LEU, 0x64FA
0064F8  9FA781     MOV W1, [W15-64]
1769:                  if (OCxR_REG_PTRS_buffer[12] > 10000) OCxR_REG_PTRS_buffer[12] = 10000;
0064FA  227101     MOV #0x2710, W1
0064FC  97A01F     MOV [W15-62], W0
0064FE  500F81     SUB W0, W1, [W15]
006500  360001     BRA LEU, 0x6504
006502  9FA791     MOV W1, [W15-62]
006504  EB0600     CLR W12
006506  208B8D     MOV #0x8B8, W13
006508  20914E     MOV #0x914, W14
00650A  208883     MOV #0x888, W3
00650C  9FA7D3     MOV W3, [W15-54]
1770:                  
1771:              #define COEFF_A0 1
1772:              
1773:                  for (i = 0; i < NUM_SERVOS; i++) {
006544  560FF8     SUB W12, #0x18, [W15]
006546  3AFFE3     BRA NZ, 0x650E
1774:                      x = (signed long)OCxR_REG_PTRS_buffer[i]; 
00650E  2FFAA0     MOV #0xFFAA, W0
006510  478000     ADD W15, W0, W0
006512  7E0560     MOV [W0+W12], W10
006514  20000B     MOV #0x0, W11
1775:                      y = (x*COEFF_A0 + y1[i]*ServoSettings[i].filterStrength)/(COEFF_A0+ServoSettings[i].filterStrength);
006516  78011E     MOV [W14], W2
006518  B91461     MUL.SU W2, #1, W8
00651A  78031D     MOV [W13], W6
00651C  B84006     MUL.UU W8, W6, W0
00651E  90021D     MOV [W13+2], W4
006520  B9C204     MUL.SS W8, W4, W4
006522  420201     ADD W4, W1, W4
006524  B9B309     MUL.SS W6, W9, W6
006526  420086     ADD W4, W6, W1
006528  40000A     ADD W0, W10, W0
00652A  48808B     ADDC W1, W11, W1
00652C  E80102     INC W2, W2
00652E  DE91CF     ASR W2, #15, W3
006530  07CEC8     RCALL ___udivsi3
1776:                              y1[i] = y;
006532  BE9E80     MOV.D W0, [W13++]
1777:                              x1[i] = x;
006534  97A25F     MOV [W15-54], W4
006536  BE9A0A     MOV.D W10, [W4++]
006538  9FA7D4     MOV W4, [W15-54]
1778:                      *OCxR_REG_PTRS[i] = y;
00653A  284C42     MOV #0x84C4, W2
00653C  79016C     MOV [W12+W2], W2
00653E  780900     MOV W0, [W2]
006540  E8860C     INC2 W12, W12
006542  47077A     ADD W14, #0x1A, W14
1779:                  }  
1780:              }
006548  78074F     MOV [--W15], W14
00654A  BE064F     MOV.D [--W15], W12
00654C  BE054F     MOV.D [--W15], W10
00654E  BE044F     MOV.D [--W15], W8
006550  B10AAF     SUB #0xAA, W15
006552  060000     RETURN
1781:              
1782:              void __attribute__((__interrupt__, auto_psv))_T3Interrupt(void) {
006554  BE9F80     MOV.D W0, [W15++]
006556  781F82     MOV W2, [W15++]
006558  F80034     PUSH PSVPAG
00655A  200000     MOV #0x0, W0
00655C  8801A0     MOV W0, PSVPAG
1783:                  static unsigned char T3ServoIndex = 0;
1784:                  static unsigned int oc10rBuffer; //buffer since these registers can change
1785:                  static unsigned int oc11rBuffer;
1786:                  static unsigned int oc12rBuffer;
1787:                  static unsigned int T3PeriodResidual;
1788:                  static unsigned char PPMHigh = 1;
1789:                  
1790:                  if (PPMOutput == 0)
00655E  E20800     CP0 PPMOutput
006560  3A002D     BRA NZ, 0x65BC
1791:                  {
1792:                      switch (T3ServoIndex){
006562  BFC8F0     MOV.B T3ServoIndex, WREG
006564  504FE1     SUB.B W0, #0x1, [W15]
006566  32000D     BRA Z, 0x6582
006568  390005     BRA NC, 0x6574
00656A  504FE2     SUB.B W0, #0x2, [W15]
00656C  320012     BRA Z, 0x6592
00656E  504FE3     SUB.B W0, #0x3, [W15]
006570  3A0023     BRA NZ, 0x65B8
006572  370017     BRA 0x65A2
1793:                          case 0:
1794:                              PWM10_OUT = 1;
006574  A802CD     BSET 0x2CD, #0
1795:                              oc10rBuffer = oc10r-1; //manually tune to minimize error
006576  ED08F2     DEC oc10r, WREG
006578  884770     MOV W0, oc10rBuffer
1796:                              PR3 = oc10rBuffer;
00657A  880870     MOV W0, PR3
1797:                              T3ServoIndex++;
00657C  B3C010     MOV.B #0x1, W0
00657E  B7E8F0     MOV.B WREG, T3ServoIndex
006580  370044     BRA 0x660A
1798:                              break;
1799:                          case 1:         
1800:                              PWM10_OUT = 0;
006582  A902CD     BCLR 0x2CD, #0
1801:                              PWM11_OUT = 1;
006584  A822CD     BSET 0x2CD, #1
1802:                              oc11rBuffer = oc11r-1;
006586  ED08F8     DEC oc11r, WREG
006588  884760     MOV W0, oc11rBuffer
1803:                              PR3 = oc11rBuffer;
00658A  880870     MOV W0, PR3
1804:                              T3ServoIndex++;
00658C  B3C020     MOV.B #0x2, W0
00658E  B7E8F0     MOV.B WREG, T3ServoIndex
006590  37003C     BRA 0x660A
1805:                              break;
1806:                          case 2:
1807:                              PWM11_OUT = 0;
006592  A922CD     BCLR 0x2CD, #1
1808:                              PWM12_OUT = 1;
006594  A862CC     BSET LATB, #3
1809:                              oc12rBuffer = oc12r-1;
006596  ED08FE     DEC oc12r, WREG
006598  884750     MOV W0, oc12rBuffer
1810:                              PR3 = oc12rBuffer;
00659A  880870     MOV W0, PR3
1811:                              T3ServoIndex++;       
00659C  B3C030     MOV.B #0x3, W0
00659E  B7E8F0     MOV.B WREG, T3ServoIndex
0065A0  370034     BRA 0x660A
1812:                              break;
1813:                          case 3:   
1814:                              PWM12_OUT = 0;
0065A2  A962CC     BCLR LATB, #3
1815:                              T3PeriodResidual = 39996 - (oc10rBuffer + oc11rBuffer + oc12rBuffer); //manually tune for 20ms period
0065A4  804760     MOV oc11rBuffer, W0
0065A6  B408EE     ADD oc10rBuffer, WREG
0065A8  804751     MOV oc12rBuffer, W1
0065AA  400001     ADD W0, W1, W0
0065AC  29C3C1     MOV #0x9C3C, W1
0065AE  508080     SUB W1, W0, W1
0065B0  884741     MOV W1, T3PeriodResidual
1816:                              PR3 = T3PeriodResidual;
0065B2  880871     MOV W1, PR3
1817:                              T3ServoIndex = 0;
0065B4  EF68F0     CLR.B T3ServoIndex
0065B6  370029     BRA 0x660A
1818:                              break;
1819:                          default:
1820:                              T3ServoIndex = 0;
0065B8  EF68F0     CLR.B T3ServoIndex
0065BA  370027     BRA 0x660A
1821:                              break;
1822:                      }
1823:                  }
1824:                  else
1825:                  {
1826:                      if (PPMHigh == 1)
0065BC  20E740     MOV #0xE74, W0
0065BE  B3C011     MOV.B #0x1, W1
0065C0  10CF90     SUBR.B W1, [W0], [W15]
0065C2  3A001E     BRA NZ, 0x6600
1827:                      {
1828:                          PWM12_OUT = 1;
0065C4  A862CC     BSET LATB, #3
1829:                          PPMHigh = 0;
0065C6  EF6E74     CLR.B 0xE74
1830:                          if (T3ServoIndex < 12)
0065C8  208F02     MOV #0x8F0, W2
0065CA  784112     MOV.B [W2], W2
0065CC  514FEB     SUB.B W2, #0xB, [W15]
0065CE  3E000A     BRA GTU, 0x65E4
1831:                          {
1832:                              PR3 = *OCxR_REG_PTRS[T3ServoIndex]-602;
0065D0  FB8002     ZE W2, W0
0065D2  400000     ADD W0, W0, W0
0065D4  284C41     MOV #0x84C4, W1
0065D6  7880E0     MOV [W0+W1], W1
0065D8  2FDA60     MOV #0xFDA6, W0
0065DA  400011     ADD W0, [W1], W0
0065DC  880870     MOV W0, PR3
1833:                              T3ServoIndex++;
0065DE  E84002     INC.B W2, W0
0065E0  B7E8F0     MOV.B WREG, T3ServoIndex
0065E2  370013     BRA 0x660A
1834:                          }
1835:                          else if (T3ServoIndex < 16 )
0065E4  514FEF     SUB.B W2, #0xF, [W15]
0065E6  3E0008     BRA GTU, 0x65F8
1836:                          {
1837:                              PR3 = ButtonsPPM[T3ServoIndex-12];
0065E8  FB8002     ZE W2, W0
0065EA  400000     ADD W0, W0, W0
0065EC  20AEE1     MOV #0xAEE, W1
0065EE  788060     MOV [W0+W1], W0
0065F0  880870     MOV W0, PR3
1838:                              T3ServoIndex++;
0065F2  E84002     INC.B W2, W0
0065F4  B7E8F0     MOV.B WREG, T3ServoIndex
0065F6  370009     BRA 0x660A
1839:                          }
1840:                          else
1841:                          {
1842:                              PR3 = 10000;
0065F8  227100     MOV #0x2710, W0
0065FA  880870     MOV W0, PR3
1843:                              T3ServoIndex = 0;
0065FC  EF68F0     CLR.B T3ServoIndex
0065FE  370005     BRA 0x660A
1844:                          }
1845:                      }
1846:                      else //PPMHigh == 0
1847:                      {
1848:                          PWM12_OUT = 0;
006600  A962CC     BCLR LATB, #3
1849:                          PR3 = 600;       
006602  202580     MOV #0x258, W0
006604  880870     MOV W0, PR3
1850:                          PPMHigh = 1;
006606  B3C010     MOV.B #0x1, W0
006608  B7EE74     MOV.B WREG, 0xE74
1851:                      }
1852:                  }
1853:                  _T3IF = 0; //clear interrupt flag   
00660A  A90085     BCLR 0x85, #0
1854:              }
00660C  F90034     POP PSVPAG
00660E  78014F     MOV [--W15], W2
006610  BE004F     MOV.D [--W15], W0
006612  064000     RETFIE
1855:              
1856:              
1857:              
1858:              void ResetOutputs(CONTROLLER_IN* ControllerIn) {
006614  781F88     MOV W8, [W15++]
006616  780400     MOV W0, W8
1859:              
1860:                  UART2PrintString("***Reset Outputs.***\n\r");
006618  28B1B0     MOV #0x8B1B, W0
00661A  071831     RCALL UART2PrintString
1861:                  ControllerIn->triangle = 0;
1862:                  ControllerIn->circle = 0;
1863:                  ControllerIn->cross = 0;
1864:                  ControllerIn->square = 0;
1865:                  ControllerIn->dPad = 0b1000;
00661C  B3C080     MOV.B #0x8, W0
00661E  984450     MOV.B W0, [W8+5]
1866:                  ControllerIn->rStickPress = 0;
1867:                  ControllerIn->lStickPress = 0;
1868:                  ControllerIn->options = 0;
1869:                  ControllerIn->share = 0;
1870:                  ControllerIn->rTriggerPull = 0;
1871:                  ControllerIn->lTriggerPull = 0;
1872:                  ControllerIn->lBumper = 0;
1873:                  ControllerIn->rBumper = 0;
006620  EB4000     CLR.B W0
006622  984460     MOV.B W0, [W8+6]
1874:                  ControllerIn->tpadClick = 0;
006624  904078     MOV.B [W8+7], W0
1875:                  ControllerIn->psButton = 0;
006626  B3CFC1     MOV.B #0xFC, W1
006628  604001     AND.B W0, W1, W0
00662A  984470     MOV.B W0, [W8+7]
1876:              
1877:                  ControllerIn->lStickX = ServoSettings[L_STICK_X].zeroPosition;
00662C  BFC918     MOV.B 0x918, WREG
00662E  984410     MOV.B W0, [W8+1]
1878:                  ControllerIn->lStickY = ServoSettings[L_STICK_Y].zeroPosition;
006630  BFC932     MOV.B 0x932, WREG
006632  984420     MOV.B W0, [W8+2]
1879:                  ControllerIn->rStickX = ServoSettings[R_STICK_X].zeroPosition;
006634  BFC94C     MOV.B 0x94C, WREG
006636  984430     MOV.B W0, [W8+3]
1880:                  ControllerIn->rStickY = ServoSettings[R_STICK_Y].zeroPosition;
006638  BFC966     MOV.B 0x966, WREG
00663A  984440     MOV.B W0, [W8+4]
1881:                  ControllerIn->lTriggerAnalog = ServoSettings[L_TRIG].zeroPosition;
00663C  BFC980     MOV.B 0x980, WREG
00663E  984C00     MOV.B W0, [W8+8]
1882:                  ControllerIn->rTriggerAnalog = ServoSettings[R_TRIG].zeroPosition;
006640  BFC99A     MOV.B 0x99A, WREG
006642  984C10     MOV.B W0, [W8+9]
1883:                  ControllerIn->accelX = ServoSettings[TILT_X].zeroPosition;
006644  BFCA1C     MOV.B 0xA1C, WREG
006646  985430     MOV.B W0, [W8+19]
006648  BFCA1D     MOV.B 0xA1D, WREG
00664A  985440     MOV.B W0, [W8+20]
1884:                  ControllerIn->accelZ = ServoSettings[TILT_Y].zeroPosition;
00664C  BFCA36     MOV.B 0xA36, WREG
00664E  985470     MOV.B W0, [W8+23]
006650  BFCA37     MOV.B 0xA37, WREG
006652  985C00     MOV.B W0, [W8+24]
1885:                  ControllerIn->tpad[0].finger[0].noFinger = 1;
006654  906038     MOV.B [W8+35], W0
006656  B3C801     MOV.B #0x80, W1
006658  704001     IOR.B W0, W1, W0
00665A  986430     MOV.B W0, [W8+35]
1886:                  ControllerIn->tpad[0].finger[1].noFinger = 1;
00665C  906078     MOV.B [W8+39], W0
00665E  704001     IOR.B W0, W1, W0
006660  986470     MOV.B W0, [W8+39]
1887:              
1888:              
1889:                  CopyPS4Report(ControllerIn);
006662  780008     MOV W8, W0
006664  070CFC     RCALL CopyPS4Report
1890:                  UpdateCurrentStateBuffer((CONTROLLER_IN*)GetPS4Report()); //update controller input fields
006666  071257     RCALL GetPS4Report
006668  070E5A     RCALL UpdateCurrentStateBuffer
1891:                  UpdateNewPress();
00666A  0711F9     RCALL UpdateNewPress
1892:                  if (disconnectToggleReset == 1) {
00666C  8057A0     MOV disconnectToggleReset, W0
00666E  500FE1     SUB W0, #0x1, [W15]
006670  3A0004     BRA NZ, 0x667A
1893:                      UpdateButtonOutputs(2, 0); //2: config mode not active, but re-initialize the button toggle states
006672  EB0080     CLR W1
006674  200020     MOV #0x2, W0
006676  07F94A     RCALL UpdateButtonOutputs
006678  370002     BRA 0x667E
1894:                  }
1895:                  else {
1896:                      UpdateButtonOutputs(0, 0); //0: config mode not active
00667A  B80060     MUL.UU W0, #0, W0
00667C  07F947     RCALL UpdateButtonOutputs
1897:                  }
1898:                  UpdateServoOutputs();
00667E  07FBAA     RCALL UpdateServoOutputs
1899:              }
006680  78044F     MOV [--W15], W8
006682  060000     RETURN
1900:              
1901:              /*******************************************************************************
1902:              Function: GetSpiBusMode()
1903:              
1904:              Precondition:
1905:               None
1906:              
1907:              Overview:
1908:                  This subroutine returns the SPI bus mode
1909:              
1910:              Input:
1911:              
1912:              Output:
1913:              0,1,2,3
1914:              
1915:               *******************************************************************************/
1916:              unsigned int GetSpiBusMode(void) {
006684  805790     MOV spiBusMode, W0
1917:                  return spiBusMode;
1918:              }
006686  060000     RETURN
1919:              
1920:              unsigned int GetLEDBrightness(void)
1921:              {
006688  8057E0     MOV LEDBrightness, W0
1922:                  return LEDBrightness;
1923:              }
00668A  060000     RETURN
1924:              
1925:              unsigned int GetLEDColorSetting(void)
1926:              {
00668C  805870     MOV LEDColorSetting, W0
1927:                  return LEDColorSetting;
1928:              }
00668E  060000     RETURN
1929:              /*******************************************************************************
1930:              Function: PrintIndexLabel(index)
1931:              
1932:              Precondition:
1933:               None
1934:              
1935:              Overview:
1936:                  This subroutine prints the controller input associated with the channel 
1937:              number.
1938:              
1939:              Input: Output
1940:               * //////////////SERVOS///////////////
1941:                  0:L-Stick X-axis
1942:                  1:L-Stick Y-axis
1943:                  2:R-Stick X-axis
1944:                  3:R-Stick Y-axis
1945:                  4:L-Trig analog
1946:                  5:R-Trig analog
1947:                  6:TouchPad1(Left side when split)-X
1948:                  7:TouchPad1(Left side when split)-Y
1949:                  8:TouchPad2(Right side when split)-X
1950:                  9:TouchPad2(Right side when split)-Y
1951:                  10:X-Accelerometer
1952:                  11:Z-Accelerometer
1953:               * //Buttons
1954:                  12:Share button 
1955:                  13:L-Stick button 
1956:                  14:R-Stick button 
1957:                  15:Options button 
1958:                  16:D-Pad Up 
1959:                  17:D-Pad Right 
1960:                  18:D-Pad Down 
1961:                  19:D-Pad Left 
1962:                  20:L-Bumper
1963:                  21:R-Bumper
1964:                  22:L-Trig button
1965:                  23:R-Trig button
1966:                  24:Triangle button
1967:                  25:Circle button
1968:                  26:Cross button
1969:                  27:Square button
1970:                  28:PS button
1971:                  29:Touchpad click
1972:              
1973:               *******************************************************************************/
1974:              
1975:              void PrintIndexLabel(unsigned int index) {
006690  FA003C     LNK #0x3C
006692  781F88     MOV W8, [W15++]
006694  780400     MOV W0, W8
1976:                  char* indexLabels[] = {\
1977:                  "L-Stick X-axis",\
1978:                  "L-Stick Y-axis",\
1979:                  "R-Stick X-axis",\
1980:                  "R-Stick Y-axis",\
1981:                  "L-Trig analog",\
1982:                  "R-Trig analog",\
1983:                  "TouchPad1(Left side when split)-X",\
1984:                  "TouchPad1(Left side when split)-Y",\
1985:                  "TouchPad2(Right side when split)-X",\
1986:                  "TouchPad2(Right side when split)-Y",\
1987:                  "X-Tilt",\
1988:                  "Y-Tilt",\
1989:                  "Share button",\
1990:                  "L-Stick button",\
1991:                  "R-Stick button",\
1992:                  "Options button",\
1993:                  "D-Pad Up",\
1994:                  "D-Pad Right",\
1995:                  "D-Pad Down",\
1996:                  "D-Pad Left",\
1997:                  "L-Trig button",\
1998:                  "R-Trig button",\
1999:                  "L-Bumper",\
2000:                  "R-Bumper",\
2001:                  "Triangle button",\
2002:                  "Circle button",\
2003:                  "Cross button",\
2004:                  "Square button",\
2005:                  "PS button",\
2006:                  "Touchpad button"
2007:                  };
006696  2FFC20     MOV #0xFFC2, W0
006698  40000F     ADD W0, W15, W0
00669A  28D081     MOV #0x8D08, W1
00669C  09001D     REPEAT #0x1D
00669E  781831     MOV [W1++], [W0++]
0066A0  B103C0     SUB #0x3C, W0
2008:              
2009:                  if (index > 29) {
0066A2  540FFD     SUB W8, #0x1D, [W15]
0066A4  360003     BRA LEU, 0x66AC
2010:                      UART2PrintString("Error: Index out of range. \n\r");
0066A6  28D440     MOV #0x8D44, W0
0066A8  0717EA     RCALL UART2PrintString
0066AA  37000F     BRA 0x66CA
2011:                  }
2012:                  else {
2013:                      UART2PrintString("Channel ");
0066AC  28D620     MOV #0x8D62, W0
0066AE  0717E7     RCALL UART2PrintString
2014:                      UART2PutDecInt(index);
0066B0  780008     MOV W8, W0
0066B2  071833     RCALL UART2PutDecInt
2015:                      UART2PutChar(':');
0066B4  B3C3A0     MOV.B #0x3A, W0
0066B6  0717F0     RCALL UART2PutChar
2016:                      UART2PutChar(' ');
0066B8  B3C200     MOV.B #0x20, W0
0066BA  0717EE     RCALL UART2PutChar
2017:                      UART2PrintString(indexLabels[index]); //Careful, don't try to call a label that doesn't exist!
0066BC  440008     ADD W8, W8, W0
0066BE  2FFC21     MOV #0xFFC2, W1
0066C0  408080     ADD W1, W0, W1
0066C2  7F8061     MOV [W1+W15], W0
0066C4  0717DC     RCALL UART2PrintString
2018:                      UART2PrintString("\n\r");
0066C6  286F00     MOV #0x86F0, W0
0066C8  0717DA     RCALL UART2PrintString
2019:                  }
2020:              }
0066CA  78044F     MOV [--W15], W8
0066CC  FA8000     ULNK
0066CE  060000     RETURN
2021:              
2022:              void PrintMenu(void)
2023:              {
2024:              
2025:                  UART2PrintString("\n\r===General Settings===\n\r");
0066D0  28D6B0     MOV #0x8D6B, W0
0066D2  0717D5     RCALL UART2PrintString
2026:                  UART2PrintString("Enter config mode: Hold PS Button + Share 3 seconds\n\r");
0066D4  28D860     MOV #0x8D86, W0
0066D6  0717D3     RCALL UART2PrintString
2027:                  UART2PrintString("Save and exit: Hold Start\n\r");
0066D8  28DBC0     MOV #0x8DBC, W0
0066DA  0717D1     RCALL UART2PrintString
2028:                  UART2PrintString("Load defaults: Hold Select 1 second (current channel)/3 seconds (all channels)\n\r");
0066DC  28DD80     MOV #0x8DD8, W0
0066DE  0717CF     RCALL UART2PrintString
2029:                  UART2PrintString("Cycle to next/previous channel : R/L Bumper\n\r");
0066E0  28E290     MOV #0x8E29, W0
0066E2  0717CD     RCALL UART2PrintString
2030:                  UART2PrintString("Cycle SPI bus modes: R-Stick + Triangle\n\r");
0066E4  28E570     MOV #0x8E57, W0
0066E6  0717CB     RCALL UART2PrintString
2031:                  UART2PrintString("Enable/Disable idle auto-disconnect: R-Stick + Cross\r\n");
0066E8  28E810     MOV #0x8E81, W0
0066EA  0717C9     RCALL UART2PrintString
2032:                  UART2PrintString("Preserve/Reset outputs on controller disconnect: R-Stick + PS Button\n\r");
0066EC  28EB80     MOV #0x8EB8, W0
0066EE  0717C7     RCALL UART2PrintString
2033:                  UART2PrintString("Change lightbar brightness: L-Stick + D-Pad Left/Right\n\r");
0066F0  28EFF0     MOV #0x8EFF, W0
0066F2  0717C5     RCALL UART2PrintString
2034:                  
2035:                  UART2PrintString("\n\r===Servo Adjustments===\n\r");
0066F4  28F380     MOV #0x8F38, W0
0066F6  0717C3     RCALL UART2PrintString
2036:                  UART2PrintString("Toggle absolute position/incremental mode: R-Stick + R-Bumper\n\r");
0066F8  28F540     MOV #0x8F54, W0
0066FA  0717C1     RCALL UART2PrintString
2037:                  UART2PrintString("Invert direction: R-Stick + L-Bumper\n\r");
0066FC  28F940     MOV #0x8F94, W0
0066FE  0717BF     RCALL UART2PrintString
2038:                  UART2PrintString("Sensitivity: Triangle/Cross\n\r");
006700  28FBB0     MOV #0x8FBB, W0
006702  0717BD     RCALL UART2PrintString
2039:                  UART2PrintString("Deadband: Square/Circle\n\r");
006704  28FD90     MOV #0x8FD9, W0
006706  0717BB     RCALL UART2PrintString
2040:                  UART2PrintString("Range of motion: D-Pad Up/Down\n\r");
006708  28FF30     MOV #0x8FF3, W0
00670A  0717B9     RCALL UART2PrintString
2041:                  UART2PrintString("Trim (range of motion limits move with trim): D-Pad Left/Right\n\r");
00670C  290140     MOV #0x9014, W0
00670E  0717B7     RCALL UART2PrintString
2042:                  UART2PrintString("Center offset trim (range of motion limits do not move): R-Stick + D-Pad Left/Right\n\r");
006710  290550     MOV #0x9055, W0
006712  0717B5     RCALL UART2PrintString
2043:                  UART2PrintString("Joystick zero calibration: Hold PS Button 1 second (current channel)/3 seconds (all channels)\n\r");
006714  290AB0     MOV #0x90AB, W0
006716  0717B3     RCALL UART2PrintString
2044:                  UART2PrintString("Servo hold/recall position mode enable: L-Stick + Circle\n\r");
006718  2910B0     MOV #0x910B, W0
00671A  0717B1     RCALL UART2PrintString
2045:                  UART2PrintString("Trigger link: L-Stick + Cross\n\r");
00671C  291460     MOV #0x9146, W0
00671E  0717AF     RCALL UART2PrintString
2046:                  UART2PrintString("Touchpad mode (absolute position vs virtual joystick): R-Stick + D-Pad Up\n\r");
006720  291660     MOV #0x9166, W0
006722  0717AD     RCALL UART2PrintString
2047:                  UART2PrintString("Touchpad split vs whole: R-Stick + D-Pad Down\n\r");
006724  291B20     MOV #0x91B2, W0
006726  0717AB     RCALL UART2PrintString
2048:                  UART2PrintString("Servo smoothing strength: L-Stick + D-Pad Up/Down\n\r");
006728  291E20     MOV #0x91E2, W0
00672A  0717A9     RCALL UART2PrintString
2049:                  UART2PrintString("Joystick differential drive mixer : L-Stick + Cross\n\r");
00672C  292160     MOV #0x9216, W0
00672E  0717A7     RCALL UART2PrintString
2050:                  UART2PrintString("Joystick mecanum wheel mixer: L-Stick + Square\n\r");
006730  2924C0     MOV #0x924C, W0
006732  0717A5     RCALL UART2PrintString
2051:                  
2052:                  UART2PrintString("\n\r===Button Adjustments===\n\r");
006734  2927D0     MOV #0x927D, W0
006736  0717A3     RCALL UART2PrintString
2053:                  UART2PrintString("Test output while configuring: R-Stick\n\r");
006738  2929A0     MOV #0x929A, W0
00673A  0717A1     RCALL UART2PrintString
2054:                  UART2PrintString("Invert Output: Cross\n\r");
00673C  292C30     MOV #0x92C3, W0
00673E  07179F     RCALL UART2PrintString
2055:                  UART2PrintString("Change button mode (pushbutton, toggle, etc.): Triangle\n\r");
006740  292DA0     MOV #0x92DA, W0
006742  07179D     RCALL UART2PrintString
2056:                  UART2PrintString("Single-Shot/Autofire pulse width: D-Pad Left/Right\n\r");
006744  293140     MOV #0x9314, W0
006746  07179B     RCALL UART2PrintString
2057:                  UART2PrintString("Adjust autofire period: D-Pad Up/Down\n\r\n\r");
006748  293490     MOV #0x9349, W0
00674A  071799     RCALL UART2PrintString
2058:                 
2059:              }
00674C  060000     RETURN
2060:              /*******************************************************************************
2061:              Function: _T3Interrupt
2062:              
2063:              Precondition:
2064:               Triggers when T3 timer elapses
2065:              
2066:              Overview:
2067:               This ISR is used to generate a PWM signal for PWM10
2068:              
2069:              Input:
2070:               configFlag == TRUE will continue to run the routine.
2071:               configFlag == FALSE will exit the routine.
2072:              
2073:              Output:
2074:                0 = save and exited;
2075:                1 = stay in config mode;
2076:              
2077:               *******************************************************************************/
2078:              ////////////////////ISR for T3 INTERRUPT (PWM10 channel, for gyro)////////////////////
2079:              
2080:              
---  D:/PIC/PIC_PS4_Host/trunk/main.c  ------------------------------------------------------------------
1:                 //#define PRINT_ACL_PACKET
2:                 //#define PRINT_HCI_PACKET
3:                 //#define DEBUG_MODE
4:                 
5:                 /******************************************************************************
6:                             Acknowledgements
7:                 
8:                  * This project was  possible thanks to previous work from many people:
9:                  * 
10:                 * The Microchip PIC USB Bluetooth dongle driver framework was based off of work by
11:                 * "yts" on the Microchip forums.
12:                 *  http://www.microchip.com/forums/m489233.aspx
13:                 *
14:                 * A lot of Bluetooth and Sony DualShock driver work was done by the following:
15:                 * Oleg
16:                 * http://www.circuitsathome.com/mcu/PS3-and-wiimote-game-controllers-on-the-arduino-host-shield-part-1
17:                 *
18:                 * Kristian Lauszus 
19:                 * http://blog.tkjelectronics.dk/2011/09/fez-panda-PS3-controller-via-bluetooth/
20:                 *
21:                 * Guillem Vials Gangolells
22:                 * http://www.guillem.co.uk/projects
23:                 *
24:                 * "Acxie"
25:                 * http://www.motioninjoy.com/
26:                 *
27:                 * The bootloader is Mikael Gustafsson's excellent ds30 bootloader.
28:                 * http://mrmackey.no-ip.org/elektronik/ds30loader/
29:                 *
30:                 * Lots of protocol decoding was done with WireShark:
31:                 * http://www.wireshark.org/
32:                 ******************************************************************************/
33:                
34:                /******************************************************************************
35:                            USB Custom Demo, Host
36:                
37:                This file provides the main entry point to the Microchip USB Custom
38:                Host demo.  This demo shows how a PIC24F system could be used to
39:                act as the host, controlling a USB device running the Microchip Custom
40:                Device demo.
41:                
42:                 ******************************************************************************/
43:                
44:                /******************************************************************************
45:                 * Filename:        main.c
46:                 * Dependancies:    USB Host Driver with Generic Client Driver
47:                 * Processor:       PIC24F256GB1xx
48:                 * Hardware:        Explorer 16 with USB PICtail Plus
49:                 * Compiler:        C30 v2.01/C32 v0.00.18
50:                 * Company:         Microchip Technology, Inc.
51:                
52:                Software License Agreement
53:                
54:                The software supplied herewith by Microchip Technology Incorporated
55:                (the CompanyE for its PICmicro Microcontroller is intended and
56:                supplied to you, the Companys customer, for use solely and
57:                exclusively on Microchip PICmicro Microcontroller products. The
58:                software is owned by the Company and/or its supplier, and is
59:                protected under applicable copyright laws. All rights are reserved.
60:                Any use in violation of the foregoing restrictions may subject the
61:                user to criminal sanctions under applicable laws, as well as to
62:                civil liability for the breach of the terms and conditions of this
63:                license.
64:                
65:                THIS SOFTWARE IS PROVIDED IN AN AS ISECONDITION. NO WARRANTIES,
66:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
67:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
68:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
69:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
70:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
71:                
72:                
73:                 *******************************************************************************/
74:                /***********************************************************************
75:                    PS4 USB Host
76:                    Copyright (C) 2013 Cross Product Creations
77:                    The GNU Public License applies to code NOT from Microchip.
78:                
79:                    This program is free software: you can redistribute it and/or modify
80:                    it under the terms of the GNU General Public License as published by
81:                    the Free Software Foundation, either version 3 of the License, or
82:                    (at your option) any later version.
83:                
84:                    This program is distributed in the hope that it will be useful,
85:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
86:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
87:                    GNU General Public License for more details.
88:                
89:                    You should have received a copy of the GNU General Public License
90:                    along with this program.  If not, see <http://www.gnu.org/licenses/>.
91:                 *************************************************************************/
92:                
93:                /*********************TODO LIST******************************************
94:                 * find a way to flush the SPI output buffer instead of filling it up so we know where the first byte is
95:                 *
96:                 * *********************************************************************/
97:                
98:                
99:                #include "main.h"
100:               #include <p24Fxxxx.h>
101:               #include <stdlib.h>
102:               
103:               #include "GenericTypeDefs.h"
104:               #include "HardwareProfile.h"
105:               #include "usb_config.h"
106:               #include "USB/usb.h"
107:               #include "USB/usb_host_generic_PS4.h"
108:               #include "DEE Emulation 16-bit/DEE Emulation 16-bit.h"
109:               
110:               #include "PS4_controller.h"
111:               #include "outputs.h"
112:               #include "PS4_SPI.h"
113:               
114:               #include "functional_test.h"
115:               //firmware revision
116:               #define FIRMWARE_REV "1.0"
117:               
118:               /////////////////Library configuration//////////////
119:               #define USE_AND_OR
120:               // *****************************************************************************
121:               // *****************************************************************************
122:               // Configuration Bits
123:               // *****************************************************************************
124:               // *****************************************************************************
125:               #define STOP_TIMER_IN_IDLE_MODE     0x2000
126:               #define TIMER_SOURCE_INTERNAL       0x0000
127:               #define TIMER_ON                    0x8000
128:               #define GATED_TIME_DISABLED         0x0000
129:               #define TIMER_16BIT_MODE            0x0000
130:               
131:               #define TIMER_PRESCALER_1           0x0000
132:               #define TIMER_PRESCALER_8           0x0010
133:               #define TIMER_PRESCALER_64          0x0020
134:               #define TIMER_PRESCALER_256         0x0030
135:               #define TIMER_INTERRUPT_PRIORITY    0x0001
136:               
137:               _CONFIG2(IESO_OFF & PLL_96MHZ_ON & PLLDIV_DIV5 & FNOSC_PRIPLL & POSCMOD_HS) // Primary HS OSC with PLL, USBPLL /5
138:               _CONFIG1(JTAGEN_OFF & ICS_PGx2 & FWDTEN_OFF) // JTAG off, watchdog timer off
139:               
140:               // *****************************************************************************
141:               
142:               
143:               // Application States
144:               
145:               typedef enum {
146:                   BT_INITIALIZE = 0, // Initialize the app when a device is attached
147:                   BT_STATE_PROCESS,
148:                   BT_STATE_READ_DATA
149:               } BT_STATE;
150:               
151:               
152:               // Hci States
153:               
154:               typedef enum {
155:                   HCI_CMD_RESET = 0, // Initialize the hci when a device is attached
156:                   HCI_CMD_READ_BD_ADDR,
157:                   HCI_CMD_LOCAL_NAME,
158:                   HCI_CMD_CLASS_DEVICE,
159:                   HCI_CMD_SCAN_ENABLE,
160:                   HCI_CMD_INQUIRY,
161:                   HCI_CMD_SCAN_ENABLE_WAIT,
162:                   HCI_CMD_CREATE_CONNECTION,
163:                   HCI_CMD_INCOMING_ACCEPT,
164:                   HCI_ROLE_CHANGE_WAIT,
165:                   HCI_CMD_CONNECTION_ACCEPTED,
166:                   HCI_CMD_SCAN_DISABLE,
167:                   LINK_KEY_REPLY,
168:               
169:                   //L2CAP_CONNECT_REQ01,
170:                   L2CAP_CONNECT_RESP01,
171:                   L2CAP_CONFIG_REQ01,
172:                   L2CAP_CONFIG_RESP01,
173:                   L2CAP_DISCONNECT_SDP,
174:                   L2CAP_DISCONNECT_RESP01,
175:               
176:                   L2CAP_CONNECT_RESP11,
177:                   L2CAP_CONNECT_REQ11,
178:                   L2CAP_CONFIG_REQ11,
179:                   L2CAP_CONFIG_RESP11,
180:                   L2CAP_CONNECT_RESP13,
181:                   L2CAP_CONFIG_REQ13,
182:                   L2CAP_CONFIG_RESP13,
183:               
184:                   PS4_BT_INIT,
185:                   PS4_BT_RUNNING,
186:               
187:                   L2CAP_DISCONNECT_DATA_RESP,
188:                   L2CAP_DISCONNECT_CTRL_RESP,
189:                   L2CAP_DISCONNECT_DATA,
190:                   L2CAP_DISCONNECT_CTRL,
191:                   HCI_DISCONNECT,
192:               
193:                   HCI_READ,
194:               
195:               } HCI_STATE;
196:               
197:               typedef enum {
198:                   PS4_WIRE_READ_BD_ADDR1,
199:                   PS4_WIRE_WRITE_BD_ADDR,
200:                   SET_0x14,
201:                   PS4_WIRE_READ_BD_ADDR2,
202:                   PS4_WIRE_CONTROLLER_INIT,
203:                   PS4_WIRE_RUNNING
204:               } PS4_WIRE_STATE;
205:               
206:               typedef enum {
207:                   SPACE_NAV_INIT,
208:                   SPACE_NAV_RUNNING
209:               } SPACE_NAV_STATE;
210:               
211:               // *****************************************************************************
212:               // *****************************************************************************
213:               // Global Variables
214:               // *****************************************************************************
215:               // *****************************************************************************
216:               
217:               BYTE deviceAddress; // Address of the device on the USB
218:               BT_STATE DemoState; // Current state of the demo application
219:               HCI_STATE HciState; // Current state of the demo application
220:               PS4_WIRE_STATE PS4WireState; //state machine when usb controller is attached.
221:               SPACE_NAV_STATE SpaceNavState;
222:               
223:               int data_num;
224:               
225:               union __PACKED {
226:                   unsigned char bytes[6]; //
227:                   unsigned int ints[3];
228:               } localBdAddr;
229:               
230:               BYTE remote_bd_addr[6]; //
231:               BYTE acl_buf[DATA_PACKET_LENGTH];
232:               BYTE hci_buf[DATA_PACKET_LENGTH];
233:               
234:               BYTE handle[2]; //a handle for ACL
235:               BYTE cid_dev_ctrl[2];
236:               const BYTE cid_host_ctrl[2] = {0x70, 0x00}; //assign this channel id
237:               BYTE cid_dev_data[2];
238:               const BYTE cid_host_data[2] = {0x71, 0x00};
239:               BYTE cid_dev_sdp[2];
240:               const BYTE cid_host_sdp[2] = {0x72, 0x00};
241:               BYTE packet_id;
242:               
243:               char message[64];
244:               static volatile int spi_index = 0;
245:               
246:               //variables to access PS4 packets
247:               CONTROLLER_IN *BTControllerInPtr = (CONTROLLER_IN*) (acl_buf + 11); //the actual data starts on byte 11, the header is 10 bytes long
248:               
249:               
250:               unsigned int i; //general purpose index counter
251:               static volatile unsigned int loopCounter; //counts the numerber of times the loop is executed, used for scheduling output packets
252:               static volatile unsigned int timeoutCounter = 0; //counter for idle disconnect
253:               static volatile BOOL configFlag = 0; //TRUE if we're in configuration mode
254:               
255:               unsigned char vibeL;
256:               unsigned char vibeH;
257:               unsigned char LedAdc = 0;
258:               
259:               
260:               char temp; //general purpose temp char
261:               //******************************************************************************
262:               //******************************************************************************
263:               // Local Routines
264:               //******************************************************************************
265:               //******************************************************************************
266:               
267:               /*************************************************************************
268:                * Function:        ResetStates
269:                *
270:                * Preconditions:   None
271:                *
272:                * Input:           None
273:                *
274:                * Output:          None
275:                *
276:                * Returns:         None
277:                *
278:                * Side Effects:    None
279:                *
280:                * Overview:        This routine will reset the internal states to the
281:                *                  power-on state.
282:                *************************************************************************/
283:               void ResetStates(void) {
284:                   UART2PrintString("***Reset States.***\n\r");
00674E  2937A0     MOV #0x937A, W0
006750  071796     RCALL UART2PrintString
285:                   DemoState = BT_INITIALIZE;
006752  EB0000     CLR W0
006754  886430     MOV W0, DemoState
286:                   HciState = HCI_CMD_RESET;
006756  886440     MOV W0, HciState
287:                   PS4WireState = PS4_WIRE_CONTROLLER_INIT;
006758  200041     MOV #0x4, W1
00675A  886451     MOV W1, PS4WireState
288:                   SpaceNavState = SPACE_NAV_INIT;
00675C  886460     MOV W0, SpaceNavState
289:                   ResetOutputs(BTControllerInPtr);
00675E  807910     MOV 0xF22, W0
006760  07FF59     RCALL ResetOutputs
290:               }
006762  060000     RETURN
291:               
292:               /*************************************************************************
293:                * Function:        InitializeSystem
294:                *
295:                * Preconditions:   None
296:                *
297:                * Input:           None
298:                *
299:                * Output:          None
300:                *
301:                * Returns:         TRUE if successful, FALSE if not.
302:                *
303:                * Side Effects:    See below
304:                *
305:                * Overview:        This routine initializes the processor and peripheral,
306:                *                  setting clock speeds and enabling any required
307:                *                  features.
308:                *************************************************************************/
309:               BOOL InitializeSystem(void) {
310:                   OSCCON = 0b1111001100000000; // Enable secondary oscillator
006764  2F3000     MOV #0xF300, W0
006766  883A10     MOV W0, OSCCON
311:                   CLKDIV = 0x0000; // Set PLL prescaler (1:1)
006768  EB0180     CLR W3
00676A  883A23     MOV W3, CLKDIV
312:               
313:                   //Initialize Output pins to 0 to prevent floating outputs:
314:                   PORTB = 0;
00676C  881653     MOV W3, PORTB
315:                   PORTC = 0;
00676E  881693     MOV W3, PORTC
316:                   PORTD = 0;
006770  8816D3     MOV W3, PORTD
317:                   PORTE = 0;
006772  881713     MOV W3, PORTE
318:                   PORTF = 0;
006774  881753     MOV W3, PORTF
319:                   PORTG = 0;
006776  881793     MOV W3, PORTG
320:               
321:                   TRISB = 0b1101110011000000;
006778  2DCC00     MOV #0xDCC0, W0
00677A  881640     MOV W0, TRISB
322:                   TRISC = 0b1001111111111111;
00677C  29FFF0     MOV #0x9FFF, W0
00677E  881680     MOV W0, TRISC
323:                   TRISD = 0b1111111100000001;
006780  2FF010     MOV #0xFF01, W0
006782  8816C0     MOV W0, TRISD
324:                   TRISE = 0b1111111111000000;
006784  2FFC02     MOV #0xFFC0, W2
006786  881702     MOV W2, TRISE
325:                   TRISF = 0b1111111111110100;
006788  2FFF40     MOV #0xFFF4, W0
00678A  881740     MOV W0, TRISF
326:                   TRISG = 0b1111110000111111;
00678C  2FC3F0     MOV #0xFC3F, W0
00678E  881780     MOV W0, TRISG
327:               
328:                   //Make PGC and PGD inputs
329:                   _TRISB6 = 1; //PGC
006790  A8C2C8     BSET TRISB, #6
330:                   _TRISB7 = 1; //PGD
006792  A8E2C8     BSET TRISB, #7
331:                   ////////////////Map SPI Bus///////////////////////////////
332:               
333:                   RPINR20bits.SCK1R = 2; //map SCK1IN to RP2
006794  BFC6A9     MOV.B 0x6A9, WREG
006796  604002     AND.B W0, W2, W0
006798  A01400     BSET.B W0, #1
00679A  B7E6A9     MOV.B WREG, 0x6A9
334:                   RPINR20bits.SDI1R = 4; //map SDI1 to RP4
00679C  BFC6A8     MOV.B RPINR20, WREG
00679E  604002     AND.B W0, W2, W0
0067A0  A02400     BSET.B W0, #2
0067A2  B7E6A8     MOV.B WREG, RPINR20
335:                   RPINR21bits.SS1R = 12; //map SS1R to RP12
0067A4  BFC6AA     MOV.B RPINR21, WREG
0067A6  604002     AND.B W0, W2, W0
0067A8  B340C0     IOR.B #0xC, W0
0067AA  B7E6AA     MOV.B WREG, RPINR21
336:                   RPOR1bits.RP3R = 7; //map RP3 to SDO1
0067AC  BFC6C3     MOV.B 0x6C3, WREG
0067AE  604002     AND.B W0, W2, W0
0067B0  B34070     IOR.B #0x7, W0
0067B2  B7E6C3     MOV.B WREG, 0x6C3
337:               
338:                   //Map interrupt for /SS line
339:                   _TRISD0 = 1;
0067B4  A802D8     BSET TRISD, #0
340:                   RPINR0bits.INT1R = 11;
0067B6  BFC681     MOV.B 0x681, WREG
0067B8  604002     AND.B W0, W2, W0
0067BA  B340B0     IOR.B #0xB, W0
0067BC  B7E681     MOV.B WREG, 0x681
341:                   IPC5bits.INT1IP = 5; //set slave select interrupt priority
0067BE  BFC0AE     MOV.B IPC5, WREG
0067C0  B3CF81     MOV.B #0xF8, W1
0067C2  604001     AND.B W0, W1, W0
0067C4  B34050     IOR.B #0x5, W0
0067C6  B7E0AE     MOV.B WREG, IPC5
342:                   INTCON2bits.INT1EP = 0; //interrupt on positive edge
0067C8  A92082     BCLR INTCON2, #1
343:                   IFS1bits.INT1IF = 0;
0067CA  A98086     BCLR IFS1, #4
344:               
345:                   ////////////////Set internal pull-up/pull-down resistors//////////////
346:                   //Pull down programming lines
347:                   CNPD2bits.CN24PDE = 1;
0067CC  A80057     BSET 0x57, #0
348:                   CNPD2bits.CN25PDE = 1;
0067CE  A82057     BSET 0x57, #1
349:               
350:                   //Pull down LED0, LED1
351:                   CNPD2bits.CN30PDE = 1; //use resistors now in final rev
0067D0  A8C057     BSET 0x57, #6
352:                   CNPD2bits.CN31PDE = 1;
0067D2  A8E057     BSET 0x57, #7
353:                   
354:                   //Pull Down rumble lines
355:                   CNPD2bits.CN28PDE = 1;
0067D4  A88057     BSET 0x57, #4
356:                   CNPD2bits.CN29PDE = 1;
0067D6  A8A057     BSET 0x57, #5
357:               
358:               
359:                   //Pull up Slave Select line
360:                   CNPU4bits.CN56PUE = 1;
0067D8  A80073     BSET 0x73, #0
361:               
362:               
363:                   /////////////Use Timer4 for output poll period
364:                   T4CON = 0; //clear state
0067DA  8808F3     MOV W3, T4CON
365:                   T4CONbits.TSIDL = 0; //Continue in Idle
0067DC  A9A11F     BCLR 0x11F, #5
366:                   T4CONbits.TGATE = 0; //No gate accumulation
0067DE  A9C11E     BCLR T4CON, #6
367:                   T4CONbits.TCKPS = 0b10; //Prescale 1:64
0067E0  BFC11E     MOV.B T4CON, WREG
0067E2  A14400     BCLR.B W0, #4
0067E4  A05400     BSET.B W0, #5
0067E6  B7E11E     MOV.B WREG, T4CON
368:                   T4CONbits.T32 = 0; //16-bit mode
0067E8  A9611E     BCLR T4CON, #3
369:                   T4CONbits.TCS = 0; //Clock Source: Internal Clock (Fosc/2 = 16MHz)
0067EA  A9211E     BCLR T4CON, #1
370:                   TMR4 = 0;
0067EC  8808A3     MOV W3, TMR4
371:                   PR4 = 2500; //2500 with presacle 64 is 10ms
0067EE  209C40     MOV #0x9C4, W0
0067F0  8808D0     MOV W0, PR4
372:                   T4CONbits.TON = 1;
0067F2  A8E11F     BSET 0x11F, #7
373:                   //////////////////////////////////
374:               
375:                   // Configure UART2 Functions
376:                   //Assign U2RX To Pin RP10,RF4
377:                   RPINR19bits.U2RXR = 10;
0067F4  BFC6A6     MOV.B RPINR19, WREG
0067F6  604002     AND.B W0, W2, W0
0067F8  B340A0     IOR.B #0xA, W0
0067FA  B7E6A6     MOV.B WREG, RPINR19
378:                   //Assign U2TX To Pin RP17,RF5
379:                   RPOR8bits.RP17R = 5;
0067FC  BFC6D1     MOV.B 0x6D1, WREG
0067FE  604002     AND.B W0, W2, W0
006800  B34050     IOR.B #0x5, W0
006802  B7E6D1     MOV.B WREG, 0x6D1
380:               
381:                   UART2Init();
006804  071728     RCALL UART2Init
382:                   UART2PrintString("UART Initialized/.\n\r");
006806  293900     MOV #0x9390, W0
006808  07173A     RCALL UART2PrintString
383:               
384:                   ///////////////SETUP ADC////////////////////
385:                   AD1PCFGL = 0b1110001111111111; // Configure AN10  AN11 AN12 as analog
00680A  2E3FF0     MOV #0xE3FF, W0
00680C  881960     MOV W0, AD1PCFGL
386:                   AD1CSSL = ~AD1PCFGL; // Include AN10 AN11 AN12 in scan
00680E  801960     MOV AD1PCFGL, W0
006810  EA8000     COM W0, W0
006812  881980     MOV W0, AD1CSSL
387:                   AD1CON1bits.FORM = 0b00; // Fractional
006814  BFC321     MOV.B 0x321, WREG
006816  B3CFC1     MOV.B #0xFC, W1
006818  604001     AND.B W0, W1, W0
00681A  B7E321     MOV.B WREG, 0x321
388:                   AD1CON1bits.SSRC = 0b111; //Internal counter triggers conversion
00681C  B3CE00     MOV.B #0xE0, W0
00681E  B76320     IOR.B AD1CON1
389:                   AD1CON1bits.ASAM = 0; //manual sampling start
006820  A94320     BCLR AD1CON1, #2
390:                   AD1CON1bits.SAMP = 1;
006822  A82320     BSET AD1CON1, #1
391:               
392:               
393:                   AD1CON2bits.CSCNA = 1; //scan channels in AD1CSSL
006824  A84323     BSET 0x323, #2
394:                   AD1CON2bits.VCFG = 0; //Use AVdd and AVss as references
006826  BFC323     MOV.B 0x323, WREG
006828  60407F     AND.B W0, #0x1F, W0
00682A  B7E323     MOV.B WREG, 0x323
395:                   AD1CON2bits.CSCNA = 1; //scan inputs from AD1CSSL
00682C  A84323     BSET 0x323, #2
396:                   AD1CON2bits.SMPI = 0b0011; //interrupts after 2nd sample
00682E  BFC322     MOV.B AD1CON2, WREG
006830  B3CC31     MOV.B #0xC3, W1
006832  604001     AND.B W0, W1, W0
006834  B340C0     IOR.B #0xC, W0
006836  B7E322     MOV.B WREG, AD1CON2
397:                   AD1CON2bits.BUFM = 0; //16bit buffer
006838  A92322     BCLR AD1CON2, #1
398:                   AD1CON2bits.ALTS = 0; //only use MUX A
00683A  A90322     BCLR AD1CON2, #0
399:               
400:                   AD1CON3 = 0b0001111100111111; // Sample time = 15Tad, Tad = Tcy
00683C  21F3F0     MOV #0x1F3F, W0
00683E  881920     MOV W0, AD1CON3
401:                   AD1CON1bits.ADON = 1; // turn ADC ON
006840  A8E321     BSET 0x321, #7
402:               
403:               
404:                   // Set Default demo state
405:               #ifdef DEBUG_MODE
406:                   UART2PrintString("Reset States on Init.\n\r");
407:               #endif
408:                   ResetStates();
006842  07FF85     RCALL ResetStates
409:                   return TRUE;
410:               } // InitializeSystem
006844  200010     MOV #0x1, W0
006846  060000     RETURN
411:               
412:               /*************************************************************************
413:                * Function:        CheckForNewAttach
414:                *
415:                * Preconditions:   None
416:                *
417:                * Input:           None
418:                *
419:                * Output:          deviceAddress (global)
420:                *                  Updates the device address when an attach is found.
421:                *
422:                * Returns:         TRUE if a new device has been attached.  FALSE,
423:                *                  otherwise.
424:                *
425:                * Side Effects:    Prints attach message
426:                *
427:                * Overview:        This routine checks to see if a new device has been
428:                *                  attached.  If it has, it records the address.
429:                *************************************************************************/
430:               /*
431:               BOOL CheckForNewAttach ( void )
432:               {
433:                   // Try to get the device address, if we don't have one.
434:                   if (deviceAddress == 0)
435:                   {
436:                       GENERIC_DEVICE_ID DevID;
437:               
438:                       #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
439:                           DevID.serialNumberLength = 0;
440:                           DevID.serialNumber = NULL;
441:                       #endif
442:               
443:                       if (USBHostGenericGetDeviceAddress(&DevID))
444:                       {
445:                           deviceAddress = DevID.deviceAddress;
446:                           UART2PrintString( "Generic demo device attached - polled, deviceAddress=" );
447:                           UART2PutDec( deviceAddress );
448:                           UART2PrintString( "\r\n" );
449:                           return TRUE;
450:                       }
451:                   }
452:               
453:                   return FALSE;
454:               
455:               } // CheckForNewAttach
456:                */
457:               
458:               //Parse HCI packets
459:               
460:               void ParseRx1PS4BT(void) {
006848  BE9F88     MOV.D W8, [W15++]
461:                   unsigned int opCode;
462:               
463:               #ifdef PRINT_HCI_PACKET
464:                   unsigned int data_num;
465:                   UART2PrintString("HCI_RX: ");
466:                   for (data_num = 0; data_num < USBHostGenericGetRx1Length(deviceAddress); data_num++) {
467:                       UART2PutHex(hci_buf[data_num]);
468:                       UART2PutChar(' ');
469:                   }
470:                   UART2PrintString("-- ");
471:               #endif
472:                   DemoState = BT_STATE_PROCESS; //send program back to BT_STATE_PROCESS by default
00684A  200010     MOV #0x1, W0
00684C  886430     MOV W0, DemoState
473:                   opCode = ((unsigned int) hci_buf[3])*256 + hci_buf[4];
00684E  20CF63     MOV #0xCF6, W3
006850  784193     MOV.B [W3], W3
006852  20CF72     MOV #0xCF7, W2
006854  784112     MOV.B [W2], W2
006856  DD18C8     SL W3, #8, W1
006858  FB8002     ZE W2, W0
00685A  408400     ADD W1, W0, W8
474:                   switch (hci_buf[0]) { //Switch by event code
00685C  BFCCF3     MOV.B hci_buf, WREG
00685E  FB8000     ZE W0, W0
006860  200001     MOV #0x0, W1
006862  500061     SUB W0, #0x1, W0
006864  5880E0     SUBB W1, #0x0, W1
006866  500FFA     SUB W0, #0x1A, [W15]
006868  588FE0     SUBB W1, #0x0, [W15]
00686A  3E013D     BRA GTU, 0x6AE6
00686C  016000     BRA W0
00686E  370085     BRA 0x697A
006870  370087     BRA 0x6980
006872  3700A5     BRA 0x69BE
006874  3700C0     BRA 0x69F6
006876  3700E1     BRA 0x6A3A
006878  370136     BRA 0x6AE6
00687A  370135     BRA 0x6AE6
00687C  3700EC     BRA 0x6A56
00687E  370133     BRA 0x6AE6
006880  370132     BRA 0x6AE6
006882  370131     BRA 0x6AE6
006884  370130     BRA 0x6AE6
006886  37012F     BRA 0x6AE6
006888  37000D     BRA 0x68A4
00688A  3700FB     BRA 0x6A82
00688C  37012C     BRA 0x6AE6
00688E  37012B     BRA 0x6AE6
006890  370064     BRA 0x695A
006892  37012B     BRA 0x6AEA
006894  370128     BRA 0x6AE6
006896  370127     BRA 0x6AE6
006898  370126     BRA 0x6AE6
00689A  37010C     BRA 0x6AB4
00689C  370124     BRA 0x6AE6
00689E  370123     BRA 0x6AE6
0068A0  370122     BRA 0x6AE6
0068A2  37011C     BRA 0x6ADC
475:                       case 0x0E: //command complete event
476:                           DemoState = BT_STATE_PROCESS;
0068A4  200010     MOV #0x1, W0
0068A6  886430     MOV W0, DemoState
477:                           UART2PrintString("CMD complete: ");
0068A8  293A50     MOV #0x93A5, W0
0068AA  0716E9     RCALL UART2PrintString
478:                           switch (opCode) {
0068AC  20B040     MOV #0xB04, W0
0068AE  540F80     SUB W8, W0, [W15]
0068B0  32004E     BRA Z, 0x694E
0068B2  3E0007     BRA GTU, 0x68C2
0068B4  2030C0     MOV #0x30C, W0
0068B6  540F80     SUB W8, W0, [W15]
0068B8  32000E     BRA Z, 0x68D6
0068BA  209100     MOV #0x910, W0
0068BC  540F80     SUB W8, W0, [W15]
0068BE  3A004A     BRA NZ, 0x6954
0068C0  37000F     BRA 0x68E0
0068C2  21A0C0     MOV #0x1A0C, W0
0068C4  540F80     SUB W8, W0, [W15]
0068C6  320040     BRA Z, 0x6948
0068C8  2240C0     MOV #0x240C, W0
0068CA  540F80     SUB W8, W0, [W15]
0068CC  32003A     BRA Z, 0x6942
0068CE  2130C0     MOV #0x130C, W0
0068D0  540F80     SUB W8, W0, [W15]
0068D2  3A0040     BRA NZ, 0x6954
0068D4  370033     BRA 0x693C
479:                               case 0x030c: //if (hci_buf[3] == 0x03 && hci_buf[4]==0x0c) //Reset complete code.  Assumes success/.
480:                                   UART2PrintString("Reset.\n\r");
0068D6  293B40     MOV #0x93B4, W0
0068D8  0716D2     RCALL UART2PrintString
481:                                   HciState = HCI_CMD_READ_BD_ADDR;
0068DA  200010     MOV #0x1, W0
0068DC  886440     MOV W0, HciState
0068DE  370105     BRA 0x6AEA
482:                                   break;
483:               
484:                               case 0x0910:
485:                                   UART2PrintString("Read Address. Local BD_ADDR: ");
0068E0  293BD0     MOV #0x93BD, W0
0068E2  0716CD     RCALL UART2PrintString
486:                                   //save address
487:                                   for (data_num = 0; data_num < 6; data_num++) {
0068E4  EB0000     CLR W0
0068E6  886470     MOV W0, data_num
0068E8  780080     MOV W0, W1
0068EA  20CF39     MOV #0xCF3, W9
0068EC  20C908     MOV #0xC90, W8
0068FC  806471     MOV data_num, W1
0068FE  E80081     INC W1, W1
006900  886471     MOV W1, data_num
006902  508FE5     SUB W1, #0x5, [W15]
006904  34FFF4     BRA LE, 0x68EE
488:                                       localBdAddr.bytes[data_num] = hci_buf[6 + data_num];
0068EE  408066     ADD W1, #0x6, W0
0068F0  7CC060     MOV.B [W0+W9], W0
0068F2  7C7080     MOV.B W0, [W1+W8]
489:                                       UART2PutHex(localBdAddr.bytes[data_num]);
0068F4  FB8000     ZE W0, W0
0068F6  07178F     RCALL UART2PutHex
490:                                       UART2PutChar(' ');
0068F8  B3C200     MOV.B #0x20, W0
0068FA  0716CE     RCALL UART2PutChar
491:                                   }
492:                                   UART2PrintString(". Storing address.\n\r");
006906  293DB0     MOV #0x93DB, W0
006908  0716BA     RCALL UART2PrintString
493:                                   DataEEWrite(localBdAddr.ints[0], EEPROM_BT_ADDR_0);
00690A  20C901     MOV #0xC90, W1
00690C  784091     MOV.B [W1], W1
00690E  FB8081     ZE W1, W1
006910  BFCC91     MOV.B 0xC91, WREG
006912  DD0048     SL W0, #8, W0
006914  700001     IOR W0, W1, W0
006916  EB0080     CLR W1
006918  07143C     RCALL DataEEWrite
494:                                   DataEEWrite(localBdAddr.ints[1], EEPROM_BT_ADDR_1);
00691A  20C921     MOV #0xC92, W1
00691C  784091     MOV.B [W1], W1
00691E  FB8081     ZE W1, W1
006920  BFCC93     MOV.B 0xC93, WREG
006922  DD0048     SL W0, #8, W0
006924  700001     IOR W0, W1, W0
006926  200011     MOV #0x1, W1
006928  071434     RCALL DataEEWrite
495:                                   DataEEWrite(localBdAddr.ints[2], EEPROM_BT_ADDR_2);
00692A  20C941     MOV #0xC94, W1
00692C  784091     MOV.B [W1], W1
00692E  FB8081     ZE W1, W1
006930  BFCC95     MOV.B 0xC95, WREG
006932  DD0048     SL W0, #8, W0
006934  700001     IOR W0, W1, W0
006936  200021     MOV #0x2, W1
006938  07142C     RCALL DataEEWrite
00693A  3700D7     BRA 0x6AEA
496:               
497:                                   break;
498:                               case 0x130c:
499:                                   UART2PrintString("Local Name.\n\r");
00693C  293F00     MOV #0x93F0, W0
00693E  07169F     RCALL UART2PrintString
006940  3700D4     BRA 0x6AEA
500:                                   break;
501:               
502:                               case 0x240c:
503:                                   UART2PrintString("Write Class.\n\r");
006942  293FE0     MOV #0x93FE, W0
006944  07169C     RCALL UART2PrintString
006946  3700D1     BRA 0x6AEA
504:                                   break;
505:               
506:                               case 0x1a0c:
507:                                   UART2PrintString("Write Scan Enable/Disable.\n\r");
006948  2940D0     MOV #0x940D, W0
00694A  071699     RCALL UART2PrintString
00694C  3700CE     BRA 0x6AEA
508:                                   break;
509:                               case 0x0B04:
510:                                   UART2PrintString("Link Key Reply.\n\r");
00694E  2942A0     MOV #0x942A, W0
006950  071696     RCALL UART2PrintString
006952  3700CB     BRA 0x6AEA
511:                                   break;
512:                               default:
513:                                   UART2PrintString("Other.\n\r");
006954  2943C0     MOV #0x943C, W0
006956  071693     RCALL UART2PrintString
006958  3700C8     BRA 0x6AEA
514:                                   break;
515:                           }
516:                           break;
517:               
518:                       case 0x12: //Event: Role Change Status
519:                           if (hci_buf[2] == 0x00) {
00695A  E24CF5     CP0.B 0xCF5
00695C  3A0005     BRA NZ, 0x6968
520:                               UART2PrintString("Role Change Successful.\n\r");
00695E  294450     MOV #0x9445, W0
006960  07168E     RCALL UART2PrintString
521:                               HciState = HCI_CMD_CONNECTION_ACCEPTED;
006962  2000A0     MOV #0xA, W0
006964  886440     MOV W0, HciState
006966  3700C1     BRA 0x6AEA
522:                           } else {
523:                               UART2PrintString("Role Change Failed.  Error: ");
006968  2945F0     MOV #0x945F, W0
00696A  071689     RCALL UART2PrintString
524:                               UART2PutHex(hci_buf[2]);
00696C  BFCCF5     MOV.B 0xCF5, WREG
00696E  FB8000     ZE W0, W0
006970  071752     RCALL UART2PutHex
525:                               UART2PrintString("\n\r");
006972  2947C0     MOV #0x947C, W0
006974  071684     RCALL UART2PrintString
526:                               HciState = HCI_CMD_RESET;
006976  EF2C88     CLR HciState
006978  3700B8     BRA 0x6AEA
527:                           }
528:                           break;
529:               
530:                       case 0x01:
531:                           UART2PrintString("Inquiry Complete\n\r");
00697A  2947F0     MOV #0x947F, W0
00697C  071680     RCALL UART2PrintString
00697E  3700B5     BRA 0x6AEA
532:                           break;
533:               
534:                       case 0x02:
535:                           remote_bd_addr[0] = hci_buf[3];
006980  780003     MOV W3, W0
006982  B7EC96     MOV.B WREG, remote_bd_addr
536:                           remote_bd_addr[1] = hci_buf[4];
006984  780002     MOV W2, W0
006986  B7EC97     MOV.B WREG, 0xC97
537:                           remote_bd_addr[2] = hci_buf[5];
006988  BFCCF8     MOV.B 0xCF8, WREG
00698A  B7EC98     MOV.B WREG, 0xC98
538:                           remote_bd_addr[3] = hci_buf[6];
00698C  BFCCF9     MOV.B 0xCF9, WREG
00698E  B7EC99     MOV.B WREG, 0xC99
539:                           remote_bd_addr[4] = hci_buf[7];
006990  BFCCFA     MOV.B 0xCFA, WREG
006992  B7EC9A     MOV.B WREG, 0xC9A
540:                           remote_bd_addr[5] = hci_buf[8];
006994  BFCCFB     MOV.B 0xCFB, WREG
006996  B7EC9B     MOV.B WREG, 0xC9B
541:               
542:                           UART2PrintString("Inquiry Result, remote BD_ADDR: ");
006998  294920     MOV #0x9492, W0
00699A  071671     RCALL UART2PrintString
543:                           for (data_num = 0; data_num < 6; data_num++) {
00699C  EB0000     CLR W0
00699E  886470     MOV W0, data_num
0069A0  20C968     MOV #0xC96, W8
0069AC  EC0C8E     INC data_num, WREG
0069AE  886470     MOV W0, data_num
0069B0  500FE5     SUB W0, #0x5, [W15]
0069B2  34FFF7     BRA LE, 0x69A2
544:                               UART2PutHex(remote_bd_addr[data_num]);
0069A2  7C4060     MOV.B [W0+W8], W0
0069A4  FB8000     ZE W0, W0
0069A6  071737     RCALL UART2PutHex
545:                               UART2PutChar(' ');
0069A8  B3C200     MOV.B #0x20, W0
0069AA  071676     RCALL UART2PutChar
546:                           }
547:                           UART2PrintString("\n\r");
0069B4  2947C0     MOV #0x947C, W0
0069B6  071663     RCALL UART2PrintString
548:                           HciState = HCI_CMD_CREATE_CONNECTION;
0069B8  200070     MOV #0x7, W0
0069BA  886440     MOV W0, HciState
0069BC  370096     BRA 0x6AEA
549:                           break;
550:               
551:                       case 0x03: //connection complete
552:                           UART2PrintString("Connection Accepted Event: ");
0069BE  294B30     MOV #0x94B3, W0
0069C0  07165E     RCALL UART2PrintString
553:                           if (hci_buf[2] == 0) {
0069C2  E24CF5     CP0.B 0xCF5
0069C4  3A000F     BRA NZ, 0x69E4
554:                               handle[0] = hci_buf[3];
0069C6  BFCCF6     MOV.B 0xCF6, WREG
0069C8  B7ED4A     MOV.B WREG, handle
555:                               handle[1] = hci_buf[4]; //save connection handle and add (PB flag + BC flag)
0069CA  BFCCF7     MOV.B 0xCF7, WREG
0069CC  B7ED4B     MOV.B WREG, 0xD4B
556:                               UART2PrintString("Success. Handle = ");
0069CE  294CF0     MOV #0x94CF, W0
0069D0  071656     RCALL UART2PrintString
557:                               UART2PutHex(hci_buf[4]);
0069D2  BFCCF7     MOV.B 0xCF7, WREG
0069D4  FB8000     ZE W0, W0
0069D6  07171F     RCALL UART2PutHex
558:                               UART2PutHex(hci_buf[3]);
0069D8  BFCCF6     MOV.B 0xCF6, WREG
0069DA  FB8000     ZE W0, W0
0069DC  07171C     RCALL UART2PutHex
559:                               HciState = HCI_READ; //wait for incoming request from controller
0069DE  200200     MOV #0x20, W0
0069E0  886440     MOV W0, HciState
0069E2  370006     BRA 0x69F0
560:                           } else {
561:                               UART2PrintString("Error: ");
0069E4  294E20     MOV #0x94E2, W0
0069E6  07164B     RCALL UART2PrintString
562:                               UART2PutHex(hci_buf[2]);
0069E8  BFCCF5     MOV.B 0xCF5, WREG
0069EA  FB8000     ZE W0, W0
0069EC  071714     RCALL UART2PutHex
563:                               HciState = HCI_CMD_RESET;
0069EE  EF2C88     CLR HciState
564:                           }
565:                           UART2PrintString("\n\r");
0069F0  2947C0     MOV #0x947C, W0
0069F2  071645     RCALL UART2PrintString
0069F4  37007A     BRA 0x6AEA
566:                           break;
567:               
568:                       case 0x04: //incoming connection attempt
569:                           if (HciState == HCI_CMD_SCAN_ENABLE_WAIT) {
0069F6  806440     MOV HciState, W0
0069F8  500FE6     SUB W0, #0x6, [W15]
0069FA  3A0077     BRA NZ, 0x6AEA
570:                               UART2PrintString("Incoming Connection: Remote_Bd_Addr = ");
0069FC  294EA0     MOV #0x94EA, W0
0069FE  07163F     RCALL UART2PrintString
571:                               remote_bd_addr[0] = hci_buf[2];
006A00  BFCCF5     MOV.B 0xCF5, WREG
006A02  B7EC96     MOV.B WREG, remote_bd_addr
572:                               remote_bd_addr[1] = hci_buf[3];
006A04  BFCCF6     MOV.B 0xCF6, WREG
006A06  B7EC97     MOV.B WREG, 0xC97
573:                               remote_bd_addr[2] = hci_buf[4];
006A08  BFCCF7     MOV.B 0xCF7, WREG
006A0A  B7EC98     MOV.B WREG, 0xC98
574:                               remote_bd_addr[3] = hci_buf[5];
006A0C  BFCCF8     MOV.B 0xCF8, WREG
006A0E  B7EC99     MOV.B WREG, 0xC99
575:                               remote_bd_addr[4] = hci_buf[6];
006A10  BFCCF9     MOV.B 0xCF9, WREG
006A12  B7EC9A     MOV.B WREG, 0xC9A
576:                               remote_bd_addr[5] = hci_buf[7];
006A14  BFCCFA     MOV.B 0xCFA, WREG
006A16  B7EC9B     MOV.B WREG, 0xC9B
577:               
578:                               for (data_num = 0; data_num < 6; data_num++) {
006A18  EB0000     CLR W0
006A1A  886470     MOV W0, data_num
006A1C  20C968     MOV #0xC96, W8
006A28  EC0C8E     INC data_num, WREG
006A2A  886470     MOV W0, data_num
006A2C  500FE5     SUB W0, #0x5, [W15]
006A2E  34FFF7     BRA LE, 0x6A1E
579:                                   UART2PutHex(remote_bd_addr[data_num]);
006A1E  7C4060     MOV.B [W0+W8], W0
006A20  FB8000     ZE W0, W0
006A22  0716F9     RCALL UART2PutHex
580:                                   UART2PutChar(' ');
006A24  B3C200     MOV.B #0x20, W0
006A26  071638     RCALL UART2PutChar
581:                               }
582:                               UART2PrintString("\n\r");
006A30  2947C0     MOV #0x947C, W0
006A32  071625     RCALL UART2PrintString
583:                               HciState = HCI_CMD_INCOMING_ACCEPT;
006A34  200080     MOV #0x8, W0
006A36  886440     MOV W0, HciState
006A38  370058     BRA 0x6AEA
584:                           }
585:                           break;
586:               
587:                       case 0x05:
588:                           UART2PrintString("Disconnect Event: ");
006A3A  295110     MOV #0x9511, W0
006A3C  071620     RCALL UART2PrintString
589:                           if (hci_buf[2] == 0) {
006A3E  E24CF5     CP0.B 0xCF5
006A40  3A0004     BRA NZ, 0x6A4A
590:                               UART2PrintString("Success.");
006A42  295240     MOV #0x9524, W0
006A44  07161C     RCALL UART2PrintString
591:                               HciState = HCI_CMD_RESET;
006A46  EF2C88     CLR HciState
006A48  370002     BRA 0x6A4E
592:                           } else {
593:                               UART2PrintString("Error.");
006A4A  2952D0     MOV #0x952D, W0
006A4C  071618     RCALL UART2PrintString
594:                           }
595:                           UART2PrintString("\n\r");
006A4E  2947C0     MOV #0x947C, W0
006A50  071616     RCALL UART2PrintString
596:                           ResetStates();
006A52  07FE7D     RCALL ResetStates
006A54  37004A     BRA 0x6AEA
597:                           break;
598:               
599:                       case 0x08:
600:                           UART2PrintString("Encryption change:");
006A56  295340     MOV #0x9534, W0
006A58  071612     RCALL UART2PrintString
601:                           if (hci_buf[2] == 0 && hci_buf[5] == 1) {
006A5A  E24CF5     CP0.B 0xCF5
006A5C  3A000D     BRA NZ, 0x6A78
006A5E  20CF80     MOV #0xCF8, W0
006A60  B3C011     MOV.B #0x1, W1
006A62  10CF90     SUBR.B W1, [W0], [W15]
006A64  3A0009     BRA NZ, 0x6A78
602:                               UART2PrintString("Channel Encryption On. Handle=");
006A66  295470     MOV #0x9547, W0
006A68  07160A     RCALL UART2PrintString
603:                               UART2PutHex(hci_buf[3]);
006A6A  BFCCF6     MOV.B 0xCF6, WREG
006A6C  FB8000     ZE W0, W0
006A6E  0716D3     RCALL UART2PutHex
604:                               UART2PutHex(hci_buf[4]);
006A70  BFCCF7     MOV.B 0xCF7, WREG
006A72  FB8000     ZE W0, W0
006A74  0716D0     RCALL UART2PutHex
006A76  370002     BRA 0x6A7C
605:                           } else {
606:                               UART2PrintString("Error.");
006A78  2952D0     MOV #0x952D, W0
006A7A  071601     RCALL UART2PrintString
607:                           }
608:                           UART2PrintString("\n\r");
006A7C  2947C0     MOV #0x947C, W0
006A7E  0715FF     RCALL UART2PrintString
006A80  370034     BRA 0x6AEA
609:                           break;
610:               
611:                       case 0x0F:
612:                           UART2PrintString("Command Status Event: ");
006A82  295660     MOV #0x9566, W0
006A84  0715FC     RCALL UART2PrintString
613:                           switch (hci_buf[2]) {
006A86  BFCCF5     MOV.B 0xCF5, WREG
006A88  320003     BRA Z, 0x6A90
006A8A  504FE2     SUB.B W0, #0x2, [W15]
006A8C  3A000A     BRA NZ, 0x6AA2
006A8E  370005     BRA 0x6A9A
614:                               case 0x00:
615:                                   UART2PrintString("Pending.");
006A90  2957D0     MOV #0x957D, W0
006A92  0715F5     RCALL UART2PrintString
616:                                   DemoState = BT_STATE_READ_DATA;
006A94  200020     MOV #0x2, W0
006A96  886430     MOV W0, DemoState
006A98  37000A     BRA 0x6AAE
617:                                   break;
618:               
619:                               case 0x02:
620:                                   UART2PrintString("Error 0x02: Unknown Connection ID.");
006A9A  295860     MOV #0x9586, W0
006A9C  0715F0     RCALL UART2PrintString
621:                                   HciState = HCI_CMD_RESET;
006A9E  EF2C88     CLR HciState
006AA0  370006     BRA 0x6AAE
622:                                   break;
623:               
624:                               default:
625:                                   UART2PrintString("Error Code:");
006AA2  295A90     MOV #0x95A9, W0
006AA4  0715EC     RCALL UART2PrintString
626:                                   UART2PutHex(hci_buf[2]);
006AA6  BFCCF5     MOV.B 0xCF5, WREG
006AA8  FB8000     ZE W0, W0
006AAA  0716B5     RCALL UART2PutHex
627:                                   HciState = HCI_CMD_RESET;
006AAC  EF2C88     CLR HciState
628:                                   break;
629:                           }
630:               
631:                           UART2PrintString("\n\r");
006AAE  2947C0     MOV #0x947C, W0
006AB0  0715E6     RCALL UART2PrintString
006AB2  37001B     BRA 0x6AEA
632:                           break;
633:               
634:                       case 0x13:
635:               #ifdef PRINT_HCI_PACKET
636:                           UART2PrintString("Completed Packets.\n\r");
637:                           DemoState = BT_STATE_READ_DATA;
638:               #endif
639:                           break;
640:               
641:                       case 0x17:
642:                           UART2PrintString("Link Key Request.  BD_ADDR:");
006AB4  295B50     MOV #0x95B5, W0
006AB6  0715E3     RCALL UART2PrintString
643:                           for (data_num = 0; data_num < 6; data_num++) {
006AB8  EB0000     CLR W0
006ABA  886470     MOV W0, data_num
006ABC  20CF38     MOV #0xCF3, W8
006ACA  EC0C8E     INC data_num, WREG
006ACC  886470     MOV W0, data_num
006ACE  500FE5     SUB W0, #0x5, [W15]
006AD0  34FFF6     BRA LE, 0x6ABE
644:                               UART2PutHex(hci_buf[data_num + 1]);
006ABE  E80000     INC W0, W0
006AC0  7C4060     MOV.B [W0+W8], W0
006AC2  FB8000     ZE W0, W0
006AC4  0716A8     RCALL UART2PutHex
645:                               UART2PutChar(' ');
006AC6  B3C200     MOV.B #0x20, W0
006AC8  0715E7     RCALL UART2PutChar
646:                           }
647:                           UART2PrintString("\n\r");
006AD2  2947C0     MOV #0x947C, W0
006AD4  0715D4     RCALL UART2PrintString
648:                           HciState = LINK_KEY_REPLY;
006AD6  2000C0     MOV #0xC, W0
006AD8  886440     MOV W0, HciState
006ADA  370007     BRA 0x6AEA
649:                           break;
650:               
651:                       case 0x1B:
652:                           UART2PrintString("Max Slots Change.\n\r");
006ADC  295D10     MOV #0x95D1, W0
006ADE  0715CF     RCALL UART2PrintString
653:                           HciState = HCI_READ;
006AE0  200200     MOV #0x20, W0
006AE2  886440     MOV W0, HciState
006AE4  370002     BRA 0x6AEA
654:                           break;
655:                           
656:               #ifdef DEBUG_MODE
657:                       case 0x20:
658:                           UART2PrintString("Page Scan Repetition Mode Change.\n\r");
659:                           break;
660:               #endif
661:               
662:                       default:
663:               #ifdef PRINT_HCI_PACKET
664:                           UART2PrintString("Unknown.\n\r");
665:               #endif
666:               
667:                           DemoState = BT_STATE_READ_DATA;
006AE6  200020     MOV #0x2, W0
006AE8  886430     MOV W0, DemoState
668:                           break;
669:                   }
670:               
671:               }
006AEA  BE044F     MOV.D [--W15], W8
006AEC  060000     RETURN
672:               
673:               
674:               //Parse ACL Packet
675:               
676:               void ParseRx2PS4BT(void) {
677:               #ifdef PRINT_ACL_PACKET
678:                   UART2PrintString("ACL_RX: ");
679:                   for (data_num = 0; data_num < USBHostGenericGetRx2Length(deviceAddress); data_num++) {
680:                       UART2PutHex(acl_buf[data_num]);
681:                       UART2PutChar(' ');
682:                   }
683:                   UART2PrintString("-- ");
684:                   UART2PrintString("CID=0x");
685:                   UART2PutHex(acl_buf[7]);
686:                   UART2PutHex(acl_buf[6]);
687:                   UART2PrintString(". ");
688:               #endif
689:               
690:                   DemoState = BT_STATE_PROCESS; //send program back to BT_STATE_PROCESS
006AEE  200010     MOV #0x1, W0
006AF0  886430     MOV W0, DemoState
691:               
692:                   packet_id = acl_buf[9];
006AF2  20CA52     MOV #0xCA5, W2
006AF4  784112     MOV.B [W2], W2
006AF6  780002     MOV W2, W0
006AF8  B7ED52     MOV.B WREG, packet_id
693:               
694:                   if (acl_buf[6] == 1) //control channel
006AFA  20CA21     MOV #0xCA2, W1
006AFC  784091     MOV.B [W1], W1
006AFE  50CFE1     SUB.B W1, #0x1, [W15]
006B00  3A0114     BRA NZ, 0x6D2A
695:                   {
696:                       switch (acl_buf[8]) {
006B02  BFCCA4     MOV.B 0xCA4, WREG
006B04  504FE4     SUB.B W0, #0x4, [W15]
006B06  320089     BRA Z, 0x6C1A
006B08  3E0006     BRA GTU, 0x6B16
006B0A  504FE2     SUB.B W0, #0x2, [W15]
006B0C  32000D     BRA Z, 0x6B28
006B0E  3E0051     BRA GTU, 0x6BB2
006B10  504FE1     SUB.B W0, #0x1, [W15]
006B12  3A0108     BRA NZ, 0x6D24
006B14  370006     BRA 0x6B22
006B16  504FE6     SUB.B W0, #0x6, [W15]
006B18  3200AF     BRA Z, 0x6C78
006B1A  3900A4     BRA NC, 0x6C64
006B1C  504FE7     SUB.B W0, #0x7, [W15]
006B1E  3A0102     BRA NZ, 0x6D24
006B20  3700D6     BRA 0x6CCE
697:                           case 0x01:
698:                               UART2PrintString("Code=0x01. Command Rejected.\n\r");
006B22  295E50     MOV #0x95E5, W0
006B24  0715AC     RCALL UART2PrintString
006B26  370118     BRA 0x6D58
699:                               break;
700:               
701:                           case 0x02:
702:                               UART2PrintString("Code=0x02.(Connection Req).");
006B28  296040     MOV #0x9604, W0
006B2A  0715A9     RCALL UART2PrintString
703:                               if (acl_buf[12] == 0x01 && acl_buf[13] == 0x00) {
006B2C  BFCCA8     MOV.B 0xCA8, WREG
006B2E  504FE1     SUB.B W0, #0x1, [W15]
006B30  3A0013     BRA NZ, 0x6B58
006B32  E24CA9     CP0.B 0xCA9
006B34  3A003B     BRA NZ, 0x6BAC
704:                                   UART2PrintString("PSM=0x0001 (SDP). SCID=");
006B36  296200     MOV #0x9620, W0
006B38  0715A2     RCALL UART2PrintString
705:                                   UART2PutHex(acl_buf[15]);
006B3A  BFCCAB     MOV.B 0xCAB, WREG
006B3C  FB8000     ZE W0, W0
006B3E  07166B     RCALL UART2PutHex
706:                                   UART2PutHex(acl_buf[14]);
006B40  BFCCAA     MOV.B 0xCAA, WREG
006B42  FB8000     ZE W0, W0
006B44  071668     RCALL UART2PutHex
707:                                   UART2PrintString("\n\r");
006B46  2947C0     MOV #0x947C, W0
006B48  07159A     RCALL UART2PrintString
708:                                   cid_dev_sdp[0] = acl_buf[14];
006B4A  BFCCAA     MOV.B 0xCAA, WREG
006B4C  B7ED50     MOV.B WREG, cid_dev_sdp
709:                                   cid_dev_sdp[1] = acl_buf[15];
006B4E  BFCCAB     MOV.B 0xCAB, WREG
006B50  B7ED51     MOV.B WREG, 0xD51
710:                                   HciState = L2CAP_CONNECT_RESP01;
006B52  2000D0     MOV #0xD, W0
006B54  886440     MOV W0, HciState
006B56  370100     BRA 0x6D58
711:                               } else if (acl_buf[12] == 0x11 && acl_buf[13] == 0x00) {
006B58  504FF1     SUB.B W0, #0x11, [W15]
006B5A  3A0013     BRA NZ, 0x6B82
006B5C  E24CA9     CP0.B 0xCA9
006B5E  3A0026     BRA NZ, 0x6BAC
712:                                   UART2PrintString("PSM=0x0011 (HID_CTRL). SCID=");
006B60  296380     MOV #0x9638, W0
006B62  07158D     RCALL UART2PrintString
713:                                   UART2PutHex(acl_buf[15]);
006B64  BFCCAB     MOV.B 0xCAB, WREG
006B66  FB8000     ZE W0, W0
006B68  071656     RCALL UART2PutHex
714:                                   UART2PutHex(acl_buf[14]);
006B6A  BFCCAA     MOV.B 0xCAA, WREG
006B6C  FB8000     ZE W0, W0
006B6E  071653     RCALL UART2PutHex
715:                                   UART2PrintString("\n\r");
006B70  2947C0     MOV #0x947C, W0
006B72  071585     RCALL UART2PrintString
716:                                   cid_dev_ctrl[0] = acl_buf[14];
006B74  BFCCAA     MOV.B 0xCAA, WREG
006B76  B7ED4C     MOV.B WREG, cid_dev_ctrl
717:                                   cid_dev_ctrl[1] = acl_buf[15];
006B78  BFCCAB     MOV.B 0xCAB, WREG
006B7A  B7ED4D     MOV.B WREG, 0xD4D
718:                                   HciState = L2CAP_CONNECT_RESP11;
006B7C  200120     MOV #0x12, W0
006B7E  886440     MOV W0, HciState
006B80  3700EB     BRA 0x6D58
719:                               } else if (acl_buf[12] == 0x13 && acl_buf[13] == 0x00) {
006B82  504FF3     SUB.B W0, #0x13, [W15]
006B84  3A0013     BRA NZ, 0x6BAC
006B86  E24CA9     CP0.B 0xCA9
006B88  3A0011     BRA NZ, 0x6BAC
720:                                   UART2PrintString("PSM=0x0013. SCID=");
006B8A  296550     MOV #0x9655, W0
006B8C  071578     RCALL UART2PrintString
721:                                   UART2PutHex(acl_buf[15]);
006B8E  BFCCAB     MOV.B 0xCAB, WREG
006B90  FB8000     ZE W0, W0
006B92  071641     RCALL UART2PutHex
722:                                   UART2PutHex(acl_buf[14]);
006B94  BFCCAA     MOV.B 0xCAA, WREG
006B96  FB8000     ZE W0, W0
006B98  07163E     RCALL UART2PutHex
723:                                   UART2PrintString("\n\r");
006B9A  2947C0     MOV #0x947C, W0
006B9C  071570     RCALL UART2PrintString
724:                                   cid_dev_data[0] = acl_buf[14];
006B9E  BFCCAA     MOV.B 0xCAA, WREG
006BA0  B7ED4E     MOV.B WREG, cid_dev_data
725:                                   cid_dev_data[1] = acl_buf[15];
006BA2  BFCCAB     MOV.B 0xCAB, WREG
006BA4  B7ED4F     MOV.B WREG, 0xD4F
726:                                   HciState = L2CAP_CONNECT_RESP13;
006BA6  200160     MOV #0x16, W0
006BA8  886440     MOV W0, HciState
006BAA  3700D6     BRA 0x6D58
727:                               }
728:                               else {
729:                                   UART2PrintString("!!!Error: PSM not supported.\n\r");
006BAC  296670     MOV #0x9667, W0
006BAE  071567     RCALL UART2PrintString
006BB0  3700D3     BRA 0x6D58
730:                               }
731:                               break;
732:               
733:                           case 0x03:
734:                               UART2PrintString("Connection Complete:");
006BB2  296860     MOV #0x9686, W0
006BB4  071564     RCALL UART2PrintString
735:                               if (acl_buf[16] == 0) {
006BB6  BFCCAC     MOV.B 0xCAC, WREG
006BB8  3A0023     BRA NZ, 0x6C00
736:                                   UART2PrintString("Success. ");
006BBA  2969B0     MOV #0x969B, W0
006BBC  071560     RCALL UART2PrintString
737:                                   if (acl_buf[14] == cid_host_ctrl[0] && acl_buf[15] == cid_host_ctrl[1]) {
006BBE  20CAA1     MOV #0xCAA, W1
006BC0  784091     MOV.B [W1], W1
006BC2  B3C700     MOV.B #0x70, W0
006BC4  50CF80     SUB.B W1, W0, [W15]
006BC6  3A000B     BRA NZ, 0x6BDE
006BC8  E24CAB     CP0.B 0xCAB
006BCA  3A0009     BRA NZ, 0x6BDE
738:                                       UART2PrintString("HID CTRL (PSM 0x11)\n\r");
006BCC  296A50     MOV #0x96A5, W0
006BCE  071557     RCALL UART2PrintString
739:                                       cid_dev_ctrl[0] = acl_buf[12];
006BD0  BFCCA8     MOV.B 0xCA8, WREG
006BD2  B7ED4C     MOV.B WREG, cid_dev_ctrl
740:                                       cid_dev_ctrl[1] = acl_buf[13];
006BD4  BFCCA9     MOV.B 0xCA9, WREG
006BD6  B7ED4D     MOV.B WREG, 0xD4D
741:                                       HciState = L2CAP_CONNECT_RESP11;
006BD8  200120     MOV #0x12, W0
006BDA  886440     MOV W0, HciState
006BDC  3700BD     BRA 0x6D58
742:                                   } else if (acl_buf[14] == cid_host_data[0] && acl_buf[15] == cid_host_data[1]) {
006BDE  B3C710     MOV.B #0x71, W0
006BE0  50CF80     SUB.B W1, W0, [W15]
006BE2  3A000B     BRA NZ, 0x6BFA
006BE4  E24CAB     CP0.B 0xCAB
006BE6  3A0009     BRA NZ, 0x6BFA
743:                                       UART2PrintString("HID DATA (PSM 0x13)\n\r");
006BE8  296BB0     MOV #0x96BB, W0
006BEA  071549     RCALL UART2PrintString
744:                                       cid_dev_data[0] = acl_buf[12];
006BEC  BFCCA8     MOV.B 0xCA8, WREG
006BEE  B7ED4E     MOV.B WREG, cid_dev_data
745:                                       cid_dev_data[1] = acl_buf[13];
006BF0  BFCCA9     MOV.B 0xCA9, WREG
006BF2  B7ED4F     MOV.B WREG, 0xD4F
746:                                       HciState = L2CAP_CONNECT_RESP13;
006BF4  200160     MOV #0x16, W0
006BF6  886440     MOV W0, HciState
006BF8  3700AF     BRA 0x6D58
747:                                   } else {
748:                                       UART2PrintString("Unknown\n\r");
006BFA  296D10     MOV #0x96D1, W0
006BFC  071540     RCALL UART2PrintString
006BFE  3700AC     BRA 0x6D58
749:                                   }
750:                               } else if (acl_buf[16] == 1) {
006C00  504FE1     SUB.B W0, #0x1, [W15]
006C02  3A0003     BRA NZ, 0x6C0A
751:                                   UART2PrintString("Pending...\n\r");
006C04  296DB0     MOV #0x96DB, W0
006C06  07153B     RCALL UART2PrintString
006C08  3700A7     BRA 0x6D58
752:                               } else {
753:                                   UART2PrintString("Failure. Error:");
006C0A  296E80     MOV #0x96E8, W0
006C0C  071538     RCALL UART2PrintString
754:                                   UART2PutHex(acl_buf[16]);
006C0E  BFCCAC     MOV.B 0xCAC, WREG
006C10  FB8000     ZE W0, W0
006C12  071601     RCALL UART2PutHex
755:                                   UART2PrintString("\n\r");
006C14  2947C0     MOV #0x947C, W0
006C16  071533     RCALL UART2PrintString
006C18  37009F     BRA 0x6D58
756:                               }
757:                               break;
758:               
759:                           case 0x04:
760:                               UART2PrintString("Code=0x04(Config Req):");
006C1A  296F80     MOV #0x96F8, W0
006C1C  071530     RCALL UART2PrintString
761:                               if (acl_buf[12] == cid_host_ctrl[0] && acl_buf[13] == cid_host_ctrl[1]) {
006C1E  20CA81     MOV #0xCA8, W1
006C20  784091     MOV.B [W1], W1
006C22  B3C700     MOV.B #0x70, W0
006C24  50CF80     SUB.B W1, W0, [W15]
006C26  3A0007     BRA NZ, 0x6C36
006C28  E24CA9     CP0.B 0xCA9
006C2A  3A0005     BRA NZ, 0x6C36
762:                                   UART2PrintString("HID Control Channel.\n\r");
006C2C  2970F0     MOV #0x970F, W0
006C2E  071527     RCALL UART2PrintString
763:                                   HciState = L2CAP_CONFIG_RESP11;
006C30  200150     MOV #0x15, W0
006C32  886440     MOV W0, HciState
006C34  370091     BRA 0x6D58
764:                               } else if (acl_buf[12] == cid_host_data[0] && acl_buf[13] == cid_host_data[1]) {
006C36  B3C710     MOV.B #0x71, W0
006C38  50CF80     SUB.B W1, W0, [W15]
006C3A  3A0007     BRA NZ, 0x6C4A
006C3C  E24CA9     CP0.B 0xCA9
006C3E  3A0005     BRA NZ, 0x6C4A
765:                                   UART2PrintString("HID Data Channel.\n\r");
006C40  297260     MOV #0x9726, W0
006C42  07151D     RCALL UART2PrintString
766:                                   HciState = L2CAP_CONFIG_RESP13;
006C44  200180     MOV #0x18, W0
006C46  886440     MOV W0, HciState
006C48  370087     BRA 0x6D58
767:                               } else if (acl_buf[12] == cid_host_sdp[0] && acl_buf[13] == cid_host_sdp[1]) {
006C4A  B3C720     MOV.B #0x72, W0
006C4C  50CF80     SUB.B W1, W0, [W15]
006C4E  3A0007     BRA NZ, 0x6C5E
006C50  E24CA9     CP0.B 0xCA9
006C52  3A0005     BRA NZ, 0x6C5E
768:                                   UART2PrintString("SDP Channel.\n\r");
006C54  2973A0     MOV #0x973A, W0
006C56  071513     RCALL UART2PrintString
769:                                   HciState = L2CAP_CONFIG_RESP01;
006C58  2000F0     MOV #0xF, W0
006C5A  886440     MOV W0, HciState
006C5C  37007D     BRA 0x6D58
770:                               }
771:                               else {
772:                                   UART2PrintString("!!!Error: Unknown Channel ID.\n\r");
006C5E  297490     MOV #0x9749, W0
006C60  07150E     RCALL UART2PrintString
006C62  37007A     BRA 0x6D58
773:                               }
774:                               break;
775:               
776:                           case 0x05:
777:                               UART2PrintString("Code=0x05(Config Resp). ");
006C64  297690     MOV #0x9769, W0
006C66  07150B     RCALL UART2PrintString
778:                               if (acl_buf[16] == 0) {
006C68  E24CAC     CP0.B 0xCAC
006C6A  3A0003     BRA NZ, 0x6C72
779:                                   UART2PrintString("Success\n\r");
006C6C  297820     MOV #0x9782, W0
006C6E  071507     RCALL UART2PrintString
006C70  370073     BRA 0x6D58
780:                               } else {
781:                                   UART2PrintString("Fail.\n\r");
006C72  2978C0     MOV #0x978C, W0
006C74  071504     RCALL UART2PrintString
006C76  370070     BRA 0x6D58
782:                               }
783:                               break;
784:               
785:                           case 0x06:
786:                               UART2PrintString("Disconnect request:");
006C78  297940     MOV #0x9794, W0
006C7A  071501     RCALL UART2PrintString
787:                               if (acl_buf[12] == cid_host_data[0] && acl_buf[13] == cid_host_data[1]) {
006C7C  20CA81     MOV #0xCA8, W1
006C7E  784091     MOV.B [W1], W1
006C80  B3C710     MOV.B #0x71, W0
006C82  50CF80     SUB.B W1, W0, [W15]
006C84  3A0009     BRA NZ, 0x6C98
006C86  E24CA9     CP0.B 0xCA9
006C88  3A0007     BRA NZ, 0x6C98
788:                                   UART2PutHex(cid_host_data[0]);
006C8A  200710     MOV #0x71, W0
006C8C  0715C4     RCALL UART2PutHex
789:                                   UART2PrintString(" DATA.\n\r");
006C8E  297A80     MOV #0x97A8, W0
006C90  0714F6     RCALL UART2PrintString
790:                                   HciState = L2CAP_DISCONNECT_DATA_RESP;
006C92  2001B0     MOV #0x1B, W0
006C94  886440     MOV W0, HciState
006C96  370060     BRA 0x6D58
791:                               } else if (acl_buf[12] == cid_host_ctrl[0] && acl_buf[13] == cid_host_ctrl[1]) {
006C98  B3C700     MOV.B #0x70, W0
006C9A  50CF80     SUB.B W1, W0, [W15]
006C9C  3A0009     BRA NZ, 0x6CB0
006C9E  E24CA9     CP0.B 0xCA9
006CA0  3A0007     BRA NZ, 0x6CB0
792:                                   UART2PutHex(cid_host_ctrl[0]);
006CA2  200700     MOV #0x70, W0
006CA4  0715B8     RCALL UART2PutHex
793:                                   UART2PrintString(" CTRL.\n\r");
006CA6  297B10     MOV #0x97B1, W0
006CA8  0714EA     RCALL UART2PrintString
794:                                   HciState = L2CAP_DISCONNECT_CTRL_RESP;
006CAA  2001C0     MOV #0x1C, W0
006CAC  886440     MOV W0, HciState
006CAE  370054     BRA 0x6D58
795:                               } else if (acl_buf[12] == cid_host_sdp[0] && acl_buf[13] == cid_host_sdp[1]) {
006CB0  B3C720     MOV.B #0x72, W0
006CB2  50CF80     SUB.B W1, W0, [W15]
006CB4  3A0009     BRA NZ, 0x6CC8
006CB6  E24CA9     CP0.B 0xCA9
006CB8  3A0007     BRA NZ, 0x6CC8
796:                                   UART2PutHex(cid_host_sdp[0]);
006CBA  200720     MOV #0x72, W0
006CBC  0715AC     RCALL UART2PutHex
797:                                   UART2PrintString(" SDP.\n\r");
006CBE  297BA0     MOV #0x97BA, W0
006CC0  0714DE     RCALL UART2PrintString
798:                                   HciState = L2CAP_DISCONNECT_RESP01;
006CC2  200110     MOV #0x11, W0
006CC4  886440     MOV W0, HciState
006CC6  370048     BRA 0x6D58
799:                               }
800:                               else {
801:                                   UART2PrintString(" Unknown Channel.\n\r");
006CC8  297C20     MOV #0x97C2, W0
006CCA  0714D9     RCALL UART2PrintString
006CCC  370045     BRA 0x6D58
802:                               }
803:                               break;
804:               
805:                           case 0x07:
806:                               UART2PrintString("Disconnect Response:");
006CCE  297D60     MOV #0x97D6, W0
006CD0  0714D6     RCALL UART2PrintString
807:                               if (acl_buf[12] == cid_dev_data[0] && acl_buf[13] == cid_dev_data[1]) {
006CD2  20CA81     MOV #0xCA8, W1
006CD4  784091     MOV.B [W1], W1
006CD6  BFCD4E     MOV.B cid_dev_data, WREG
006CD8  E10C00     CP.B W1, W0
006CDA  3A000A     BRA NZ, 0x6CF0
006CDC  BFCD4F     MOV.B 0xD4F, WREG
006CDE  E34CA9     CP.B 0xCA9
006CE0  3A0007     BRA NZ, 0x6CF0
808:                                   UART2PutHex(cid_dev_data[0]);
006CE2  FB8001     ZE W1, W0
006CE4  071598     RCALL UART2PutHex
809:                                   UART2PrintString(" DATA.\n\r");
006CE6  297A80     MOV #0x97A8, W0
006CE8  0714CA     RCALL UART2PrintString
810:                                   HciState = L2CAP_DISCONNECT_CTRL;
006CEA  2001E0     MOV #0x1E, W0
006CEC  886440     MOV W0, HciState
006CEE  370034     BRA 0x6D58
811:                               } else if (acl_buf[12] == cid_dev_ctrl[0] && acl_buf[13] == cid_dev_ctrl[1]) {
006CF0  BFCD4C     MOV.B cid_dev_ctrl, WREG
006CF2  E10C00     CP.B W1, W0
006CF4  3A000A     BRA NZ, 0x6D0A
006CF6  BFCD4D     MOV.B 0xD4D, WREG
006CF8  E34CA9     CP.B 0xCA9
006CFA  3A0007     BRA NZ, 0x6D0A
812:                                   UART2PutHex(cid_dev_ctrl[0]);
006CFC  FB8001     ZE W1, W0
006CFE  07158B     RCALL UART2PutHex
813:                                   UART2PrintString(" CTRL.\n\r");
006D00  297B10     MOV #0x97B1, W0
006D02  0714BD     RCALL UART2PrintString
814:                                   HciState = HCI_DISCONNECT;
006D04  2001F0     MOV #0x1F, W0
006D06  886440     MOV W0, HciState
006D08  370027     BRA 0x6D58
815:                               } else if (acl_buf[12] == cid_dev_sdp[0] && acl_buf[13] == cid_dev_sdp[1]) {
006D0A  BFCD50     MOV.B cid_dev_sdp, WREG
006D0C  E10C00     CP.B W1, W0
006D0E  3A0024     BRA NZ, 0x6D58
006D10  BFCD51     MOV.B 0xD51, WREG
006D12  E34CA9     CP.B 0xCA9
006D14  3A0021     BRA NZ, 0x6D58
816:                                   UART2PutHex(cid_dev_sdp[0]);
006D16  FB8001     ZE W1, W0
006D18  07157E     RCALL UART2PutHex
817:                                   UART2PrintString(" SDP.\n\r");
006D1A  297BA0     MOV #0x97BA, W0
006D1C  0714B0     RCALL UART2PrintString
818:                                   HciState = HCI_READ;
006D1E  200200     MOV #0x20, W0
006D20  886440     MOV W0, HciState
006D22  37001A     BRA 0x6D58
819:                               }
820:                               break;
821:                           default:
822:                               UART2PrintString("\n\r");
006D24  2947C0     MOV #0x947C, W0
006D26  0714AB     RCALL UART2PrintString
006D28  370017     BRA 0x6D58
823:                               break;
824:               
825:                       }
826:                   } 
827:               
828:                   else if (acl_buf[6] == cid_host_sdp[0]) {
006D2A  B3C720     MOV.B #0x72, W0
006D2C  50CF80     SUB.B W1, W0, [W15]
006D2E  3A0008     BRA NZ, 0x6D40
829:                       UART2PrintString("Ch:SDP.\n\r");
006D30  297EB0     MOV #0x97EB, W0
006D32  0714A5     RCALL UART2PrintString
830:                       switch (acl_buf[8]) {
006D34  BFCCA4     MOV.B 0xCA4, WREG
006D36  504FE6     SUB.B W0, #0x6, [W15]
006D38  3A000F     BRA NZ, 0x6D58
831:                           case 0x06:
832:                               UART2PrintString("SDP Attribute Request.\n\r");
006D3A  297F50     MOV #0x97F5, W0
006D3C  0714A0     RCALL UART2PrintString
006D3E  37000C     BRA 0x6D58
833:                               break;
834:                       }
835:                       
836:                   } else if (acl_buf[6] == cid_host_data[0]) {
006D40  B3C710     MOV.B #0x71, W0
006D42  50CF80     SUB.B W1, W0, [W15]
006D44  3A0009     BRA NZ, 0x6D58
837:               #ifdef PRINT_ACL_PACKET
838:                       UART2PrintString("Ch:HID_DATA.\n\r");
839:               #endif
840:                       switch (acl_buf[8]) {
006D46  20CA41     MOV #0xCA4, W1
006D48  784091     MOV.B [W1], W1
006D4A  B3CA10     MOV.B #0xA1, W0
006D4C  50CF80     SUB.B W1, W0, [W15]
006D4E  3A0004     BRA NZ, 0x6D58
841:                           case 0xA1: //Data from controller
842:                               if (acl_buf[9] == 0x11) //Input Report
006D50  514FF1     SUB.B W2, #0x11, [W15]
006D52  3A0002     BRA NZ, 0x6D58
843:                               {
844:                                   CopyPS4Report(BTControllerInPtr);
006D54  807910     MOV 0xF22, W0
006D56  070983     RCALL CopyPS4Report
845:                               }
846:                               break;
847:                       }
848:                   } else if (acl_buf[6] == cid_host_ctrl[0]) {
849:               #ifdef PRINT_ACL_PACKET
850:                       UART2PrintString("Ch:HID_CTRL.\n\r");
851:               #endif
852:                       switch (acl_buf[8]) {
853:                       }
854:                   } else {
855:               #ifdef PRINT_ACL_PACKET
856:                       UART2PrintString("Ch:Other.\n\r");
857:               #endif
858:                   }
859:               }
006D58  060000     RETURN
860:               
861:               void ParseRx1PS4Wire(void) {
862:               #ifdef PRINT_HCI_PACKET
863:                   unsigned int data_num;
864:                   UART2PrintString("HCI_RX: ");
865:                   for (data_num = 0; data_num < 64; data_num++) {
866:                       UART2PutHex(hci_buf[data_num]);
867:                       UART2PutChar(' ');
868:                   }
869:                   UART2PrintString("-- ");
870:               #endif
871:                   if (hci_buf[0] == 0x01) {
006D5A  20CF30     MOV #0xCF3, W0
006D5C  B3C011     MOV.B #0x1, W1
006D5E  10CF90     SUBR.B W1, [W0], [W15]
006D60  3A0001     BRA NZ, 0x6D64
872:               #ifdef PRINT_HCI_PACKET
873:                       UART2PrintString("Input Report.");
874:               #endif
875:                       CopyPS4Report((CONTROLLER_IN*) hci_buf);
006D62  07097D     RCALL CopyPS4Report
876:                   }
877:               
878:               #ifdef PRINT_HCI_PACKET
879:                   UART2PrintString("\n\r");
880:               #endif
881:               }
006D64  060000     RETURN
882:               void ParseRx1SpaceNavigator(void)
883:               {
884:               
885:               #ifdef PRINT_HCI_PACKET
886:                   unsigned int data_num;
887:                   UART2PrintString("HCI_RX: ");
888:                   for (data_num = 0; data_num < USBHostGenericGetRx1Length(deviceAddress); data_num++) {
889:                       UART2PutHex(hci_buf[data_num]);
890:                       UART2PutChar(' ');
891:                   }
892:                   UART2PrintString("\n\r");
893:               #endif
894:                   CopySpaceNavigatorReport(hci_buf, USBHostGenericGetRx1Length(deviceAddress) );
006D66  BFCC84     MOV.B deviceAddress, WREG
006D68  E34EAE     CP.B 0xEAE
006D6A  3A0005     BRA NZ, 0x6D76
006D6C  AB0EB9     BTST 0xEB9, #0
006D6E  320003     BRA Z, 0x6D76
006D70  20EB01     MOV #0xEB0, W1
006D72  784091     MOV.B [W1], W1
006D74  370001     BRA 0x6D78
006D76  EB4080     CLR.B W1
006D78  20CF30     MOV #0xCF3, W0
006D7A  070979     RCALL CopySpaceNavigatorReport
895:               }
006D7C  060000     RETURN
896:               /*Write functions for USB*/
897:               BYTE Write_HCI_Command(char *message, BYTE *hci_buf, unsigned int data_size1) {
006D7E  781F88     MOV W8, [W15++]
898:                   BYTE returnVal;
899:               
900:                   returnVal = USBHostGenericClassRequest(deviceAddress, hci_buf, data_size1);
006D80  BFCC84     MOV.B deviceAddress, WREG
006D82  0713D6     RCALL USBHostGenericClassRequest
006D84  784400     MOV.B W0, W8
901:                   if (returnVal == USB_SUCCESS) {
006D86  E00400     CP0.B W0
006D88  320006     BRA Z, 0x6D96
902:               #ifdef DEBUG_MODE
903:                       unsigned int data_num;
904:                       UART2PrintString(message);
905:                       for (data_num = 0; data_num < data_size1; data_num++) {
906:                           UART2PutHex(hci_buf[data_num]);
907:                           UART2PutChar(' ');
908:                       }
909:                       UART2PrintString("\r\n");
910:               #endif
911:                       //UART2PrintString( "HCI COMMAND SENT\r\n" );
912:                   } else {
913:                       UART2PrintString("Write Class Error: ");
006D8A  2980E0     MOV #0x980E, W0
006D8C  071478     RCALL UART2PrintString
914:                       UART2PutHex(returnVal);
006D8E  FB8008     ZE W8, W0
006D90  071542     RCALL UART2PutHex
915:                       UART2PrintString("\n\r");
006D92  2947C0     MOV #0x947C, W0
006D94  071474     RCALL UART2PrintString
006D96  FB8008     ZE W8, W0
916:                   }
917:               
918:                   return returnVal;
919:               }
006D98  78044F     MOV [--W15], W8
006D9A  060000     RETURN
920:               
921:               BYTE Write_ACL_Command(char *message, BYTE *acl_buf, int data_size2) {
006D9C  781F88     MOV W8, [W15++]
922:                   BYTE retVal = USB_BUSY;
923:                   retVal = USBHostGenericAclWrite(deviceAddress, acl_buf, data_size2);
006D9E  DE91CF     ASR W2, #15, W3
006DA0  BFCC84     MOV.B deviceAddress, WREG
006DA2  0713EF     RCALL USBHostGenericAclWrite
006DA4  784400     MOV.B W0, W8
924:                   if (retVal == USB_SUCCESS) {
006DA6  E00400     CP0.B W0
006DA8  320004     BRA Z, 0x6DB2
925:               #ifdef DEBUG_MODE
926:                       unsigned int data_num;
927:                       UART2PrintString(message);
928:                       for (data_num = 0; data_num < data_size2; data_num++) {
929:                           UART2PutHex(acl_buf[data_num]);
930:                           UART2PutChar(' ');
931:                       }
932:                       UART2PrintString("\r\n");
933:               #endif
934:                       // UART2PrintString( "ACL_DATA_SENT!\n\r" );
935:                   } 
936:                   else {
937:                       UART2PutHex(retVal);
006DAA  FB8000     ZE W0, W0
006DAC  071534     RCALL UART2PutHex
938:                       UART2PrintString(" - ACL cannot be written ");
006DAE  298220     MOV #0x9822, W0
006DB0  071466     RCALL UART2PrintString
939:               #ifdef DEBUG_MODE 
940:                       UART2PrintString("DemoState:");
941:                       UART2PutDec(DemoState);
942:                       UART2PrintString("HciState:");
943:                       UART2PutDec(HciState);
944:                       UART2PrintString("\r\n");
945:                       for (data_num = 0; data_num < data_size2; data_num++) {
946:                           UART2PutHex(acl_buf[data_num]);
947:                           UART2PutChar(' ');
948:                       }
949:                       UART2PrintString("end debug\n\r");
950:               #endif
951:                   }
952:                   DelayMs(1);
006DB2  23E800     MOV #0x3E80, W0
006DB4  200001     MOV #0x0, W1
006DB6  07D8EE     RCALL ___delay32
006DB8  FB8008     ZE W8, W0
953:                   return retVal;
954:               }
006DBA  78044F     MOV [--W15], W8
006DBC  060000     RETURN
955:               
956:               BYTE WriteOutputReport(void) {
957:                   static unsigned char brightness = 0;
958:                   BYTE retVal;
959:                   brightness++;
006DBE  EC6C80     INC.B brightness
960:                   switch (GetConnectedDeviceType()) {
006DC0  07143B     RCALL GetConnectedDeviceType
006DC2  500FE1     SUB W0, #0x1, [W15]
006DC4  320003     BRA Z, 0x6DCC
006DC6  500FE2     SUB W0, #0x2, [W15]
006DC8  3A0012     BRA NZ, 0x6DEE
006DCA  37000A     BRA 0x6DE0
961:                       case BLUETOOTH:
962:                           strcpy(message, "BT Output: ");
006DCC  20D530     MOV #0xD53, W0
006DCE  2983C1     MOV #0x983C, W1
006DD0  09000B     REPEAT #0xB
006DD2  785831     MOV.B [W1++], [W0++]
963:                           retVal = Write_ACL_Command(message, GetOutputReportBT(), 87);
006DD4  070EA6     RCALL GetOutputReportBT
006DD6  780080     MOV W0, W1
006DD8  200572     MOV #0x57, W2
006DDA  20D530     MOV #0xD53, W0
006DDC  07FFDF     RCALL Write_ACL_Command
006DDE  37000A     BRA 0x6DF4
964:                           break;
965:               
966:                       case CONTROLLER:
967:                           retVal = USBHostGenericWrite(deviceAddress, GetOutputReportWire(), 32);
006DE0  070E9E     RCALL GetOutputReportWire
006DE2  780080     MOV W0, W1
006DE4  BFCC84     MOV.B deviceAddress, WREG
006DE6  200202     MOV #0x20, W2
006DE8  200003     MOV #0x0, W3
006DEA  071380     RCALL USBHostGenericWrite
006DEC  370003     BRA 0x6DF4
968:                           break;
969:               
970:                       default:
971:                           UART2PrintString("Error: Cannot find correct type.\n\r");
006DEE  298480     MOV #0x9848, W0
006DF0  071446     RCALL UART2PrintString
006DF2  B3C030     MOV.B #0x3, W0
006DF4  FB8000     ZE W0, W0
972:                           retVal = USB_ILLEGAL_REQUEST;
973:                           break;
974:                   }
975:                   return retVal;
976:               }
006DF6  060000     RETURN
977:               
978:               /*************************************************************************
979:                * Function:        ManageStateBluetooth
980:                *
981:                * Preconditions:   The DemoState global variable must be initialized to
982:                *                  DEMO_STATE_IDLE (0).  (This occurs on reset.)
983:                *
984:                * Input:           DemoState (global)
985:                *                  Actions selected based value of DemoState on function
986:                *                  entry.
987:                *
988:                *                  deviceAddress (global)
989:                *                  May use device address to access device, depending on
990:                *                  state.
991:                *
992:                *                  DataPacket (global)
993:                *                  May read data from packet buffer, depending on state.
994:                *
995:                * Output:          DemoState (global)
996:                *                  Updates demo state as appropriate.
997:                *
998:                *                  DataPacket (global)
999:                *                  May cause data in the packet buffer to be updated,
1000:               *                  depending on state.
1001:               *
1002:               * Returns:         None
1003:               *
1004:               * Side Effects:    Depend on state transition
1005:               *
1006:               * Overview:        This routine maintains the state of the application,
1007:               *                  updateing global data and taking actions as necessary
1008:               *                  to maintain the custom demo operations.
1009:               *************************************************************************/
1010:              void ManageStateBluetooth(void) {
006DF8  781F88     MOV W8, [W15++]
1011:                  packet_id++;
006DFA  EC6D52     INC.B packet_id
1012:                  /*
1013:                      UART2PutHex(DemoState);
1014:                      UART2PutChar('-');
1015:                      UART2PutHex(HciState);
1016:                      UART2PutChar(' ');
1017:                   */
1018:                  // Watch for device detaching
1019:                  if (USBHostGenericDeviceDetached(deviceAddress) && deviceAddress != 0) {
006DFC  BFCC84     MOV.B deviceAddress, WREG
006DFE  E34EAE     CP.B 0xEAE
006E00  3A0002     BRA NZ, 0x6E06
006E02  AB0EB9     BTST 0xEB9, #0
006E04  3A0005     BRA NZ, 0x6E10
006E06  E00400     CP0.B W0
006E08  320003     BRA Z, 0x6E10
1020:              #ifdef DEBUG_MODE
1021:                      UART2PrintString("Bluetooth adapter detached - polled\r\n");
1022:              #endif
1023:                      ResetStates();
006E0A  07FCA1     RCALL ResetStates
1024:                      SetConnectedDeviceType(NONE);
006E0C  EB0000     CLR W0
006E0E  071416     RCALL SetConnectedDeviceType
1025:                  }
1026:              
1027:                  switch (DemoState) {
006E10  806430     MOV DemoState, W0
006E12  500FE1     SUB W0, #0x1, [W15]
006E14  32000A     BRA Z, 0x6E2A
006E16  390003     BRA NC, 0x6E1E
006E18  500FE2     SUB W0, #0x2, [W15]
006E1A  3A054C     BRA NZ, 0x78B4
006E1C  370540     BRA 0x789E
1028:                      case BT_INITIALIZE:
1029:                          UART2PrintString("INIT\n\r");
006E1E  2986B0     MOV #0x986B, W0
006E20  07142E     RCALL UART2PrintString
1030:                          DemoState = BT_STATE_PROCESS;
006E22  200010     MOV #0x1, W0
006E24  886430     MOV W0, DemoState
1031:                          HciState = HCI_CMD_RESET; //MH
006E26  EF2C88     CLR HciState
006E28  370548     BRA 0x78BA
1032:                          break;
1033:              
1034:              
1035:                      case BT_STATE_PROCESS:
1036:                          switch (HciState) {
006E2A  806440     MOV HciState, W0
006E2C  200001     MOV #0x0, W1
006E2E  200202     MOV #0x20, W2
006E30  500F82     SUB W0, W2, [W15]
006E32  588FE0     SUBB W1, #0x0, [W15]
006E34  3E0542     BRA GTU, 0x78BA
006E36  016000     BRA W0
006E38  370020     BRA 0x6E7A
006E3A  37003B     BRA 0x6EB2
006E3C  37004D     BRA 0x6ED8
006E3E  370069     BRA 0x6F12
006E40  370082     BRA 0x6F46
006E42  370098     BRA 0x6F74
006E44  3700B6     BRA 0x6FB2
006E46  3700BD     BRA 0x6FC2
006E48  3700E8     BRA 0x701A
006E4A  370109     BRA 0x705E
006E4C  37010E     BRA 0x706A
006E4E  370110     BRA 0x7070
006E50  370123     BRA 0x7098
006E52  370161     BRA 0x7116
006E54  37019B     BRA 0x718C
006E56  3701D2     BRA 0x71FC
006E58  370204     BRA 0x7262
006E5A  370232     BRA 0x72C0
006E5C  370295     BRA 0x7388
006E5E  37025F     BRA 0x731E
006E60  3702CE     BRA 0x73FE
006E62  370305     BRA 0x746E
006E64  370335     BRA 0x74D0
006E66  37036F     BRA 0x7546
006E68  3703A7     BRA 0x75B8
006E6A  3703D9     BRA 0x761E
006E6C  37042A     BRA 0x76C2
006E6E  370434     BRA 0x76D8
006E70  370462     BRA 0x7736
006E72  370490     BRA 0x7794
006E74  3704C0     BRA 0x77F6
006E76  3704F0     BRA 0x7858
006E78  370507     BRA 0x7888
1037:                                  //HCI layer***********************************************************************
1038:                              case HCI_CMD_RESET:
1039:                                  timeoutCounter = 0;
006E7A  EB0400     CLR W8
006E7C  8863E8     MOV W8, timeoutCounter
1040:                                  ResetOutputs(BTControllerInPtr);
006E7E  807910     MOV 0xF22, W0
006E80  07FBC9     RCALL ResetOutputs
1041:                                  DelayMs(100); //pause a bit to let whatever transactions were going on finish.
006E82  26A000     MOV #0x6A00, W0
006E84  200181     MOV #0x18, W1
006E86  07D886     RCALL ___delay32
1042:                                  hci_buf[0] = 0x03;
006E88  B3C030     MOV.B #0x3, W0
006E8A  B7ECF3     MOV.B WREG, hci_buf
1043:                                  hci_buf[1] = 0x0c;
006E8C  B3C0C0     MOV.B #0xC, W0
006E8E  B7ECF4     MOV.B WREG, 0xCF4
1044:                                  hci_buf[2] = 0;
006E90  780008     MOV W8, W0
006E92  B7ECF5     MOV.B WREG, 0xCF5
1045:              
1046:                                  strcpy(message, "HCI_CMD_RESET: "); //message for BT_STATE_READ_HCI
006E94  20D530     MOV #0xD53, W0
006E96  298721     MOV #0x9872, W1
006E98  09000F     REPEAT #0xF
006E9A  785831     MOV.B [W1++], [W0++]
1047:                                  if (Write_HCI_Command(message, hci_buf, 3) == USB_SUCCESS) {
006E9C  200032     MOV #0x3, W2
006E9E  20CF31     MOV #0xCF3, W1
006EA0  20D530     MOV #0xD53, W0
006EA2  07FF6D     RCALL Write_HCI_Command
006EA4  E00400     CP0.B W0
006EA6  3A0509     BRA NZ, 0x78BA
1048:                                      HciState = HCI_CMD_READ_BD_ADDR;
006EA8  200010     MOV #0x1, W0
006EAA  886440     MOV W0, HciState
1049:                                      DemoState = BT_STATE_READ_DATA;
006EAC  200020     MOV #0x2, W0
006EAE  886430     MOV W0, DemoState
006EB0  370504     BRA 0x78BA
1050:                                  };
1051:                                  break;
1052:              
1053:                              case HCI_CMD_READ_BD_ADDR:
1054:                                  hci_buf[0] = 0x09;
006EB2  B3C090     MOV.B #0x9, W0
006EB4  B7ECF3     MOV.B WREG, hci_buf
1055:                                  hci_buf[1] = 0x10;
006EB6  B3C100     MOV.B #0x10, W0
006EB8  B7ECF4     MOV.B WREG, 0xCF4
1056:                                  hci_buf[2] = 0;
006EBA  EF6CF5     CLR.B 0xCF5
1057:              
1058:                                  strcpy(message, "HCI_CMD_READ_BD_ADDR: ");
006EBC  20D532     MOV #0xD53, W2
006EBE  298820     MOV #0x9882, W0
006EC0  090016     REPEAT #0x16
006EC2  785930     MOV.B [W0++], [W2++]
1059:                                  if (Write_HCI_Command(message, hci_buf, 3) == USB_SUCCESS) {
006EC4  200032     MOV #0x3, W2
006EC6  20CF31     MOV #0xCF3, W1
006EC8  20D530     MOV #0xD53, W0
006ECA  07FF59     RCALL Write_HCI_Command
006ECC  E00400     CP0.B W0
006ECE  3A04F5     BRA NZ, 0x78BA
1060:                                      HciState = HCI_CMD_LOCAL_NAME;
006ED0  200020     MOV #0x2, W0
006ED2  886440     MOV W0, HciState
1061:                                      DemoState = BT_STATE_READ_DATA;
006ED4  886430     MOV W0, DemoState
006ED6  3704F1     BRA 0x78BA
1062:                                  };
1063:                                  break;
1064:              
1065:                                  //********************************************************************************
1066:                              case HCI_CMD_LOCAL_NAME:
1067:                                  hci_buf[0] = 0x13;
006ED8  B3C130     MOV.B #0x13, W0
006EDA  B7ECF3     MOV.B WREG, hci_buf
1068:                                  hci_buf[1] = 0x0c;
006EDC  B3C0C0     MOV.B #0xC, W0
006EDE  B7ECF4     MOV.B WREG, 0xCF4
1069:                                  hci_buf[2] = 0x04;
006EE0  B3C040     MOV.B #0x4, W0
006EE2  B7ECF5     MOV.B WREG, 0xCF5
1070:                                  hci_buf[3] = 'C';
006EE4  B3C431     MOV.B #0x43, W1
006EE6  780001     MOV W1, W0
006EE8  B7ECF6     MOV.B WREG, 0xCF6
1071:                                  hci_buf[4] = 'P';
006EEA  B3C500     MOV.B #0x50, W0
006EEC  B7ECF7     MOV.B WREG, 0xCF7
1072:                                  hci_buf[5] = 'C';
006EEE  780001     MOV W1, W0
006EF0  B7ECF8     MOV.B WREG, 0xCF8
1073:                                  hci_buf[6] = 0x00;
006EF2  EF6CF9     CLR.B 0xCF9
1074:              
1075:                                  strcpy(message, "HCI_CMD_LOCAL_NAME: ");
006EF4  20D531     MOV #0xD53, W1
006EF6  298992     MOV #0x9899, W2
006EF8  090014     REPEAT #0x14
006EFA  7858B2     MOV.B [W2++], [W1++]
1076:                                  if (Write_HCI_Command(message, hci_buf, 7) == USB_SUCCESS) {
006EFC  200072     MOV #0x7, W2
006EFE  20CF31     MOV #0xCF3, W1
006F00  20D530     MOV #0xD53, W0
006F02  07FF3D     RCALL Write_HCI_Command
006F04  E00400     CP0.B W0
006F06  3A04D9     BRA NZ, 0x78BA
1077:                                      HciState = HCI_CMD_CLASS_DEVICE;
006F08  200030     MOV #0x3, W0
006F0A  886440     MOV W0, HciState
1078:                                      DemoState = BT_STATE_READ_DATA;
006F0C  200020     MOV #0x2, W0
006F0E  886430     MOV W0, DemoState
006F10  3704D4     BRA 0x78BA
1079:                                  };
1080:                                  break;
1081:              
1082:                                  //********************************************************************************
1083:                              case HCI_CMD_CLASS_DEVICE:
1084:                                  hci_buf[0] = 0x24;
006F12  B3C240     MOV.B #0x24, W0
006F14  B7ECF3     MOV.B WREG, hci_buf
1085:                                  hci_buf[1] = 0x0c;
006F16  B3C0C0     MOV.B #0xC, W0
006F18  B7ECF4     MOV.B WREG, 0xCF4
1086:                                  hci_buf[2] = 0x03;
006F1A  B3C030     MOV.B #0x3, W0
006F1C  B7ECF5     MOV.B WREG, 0xCF5
1087:                                  hci_buf[3] = 0x08; //gamepad
006F1E  B3C080     MOV.B #0x8, W0
006F20  B7ECF6     MOV.B WREG, 0xCF6
1088:                                  hci_buf[4] = 0x05; //joystick
006F22  B3C050     MOV.B #0x5, W0
006F24  B7ECF7     MOV.B WREG, 0xCF7
1089:                                  hci_buf[5] = 0x00;
006F26  EF6CF8     CLR.B 0xCF8
1090:              
1091:                                  strcpy(message, "HCI_CMD_CLASS_DEVICE: ");
006F28  20D530     MOV #0xD53, W0
006F2A  298AE1     MOV #0x98AE, W1
006F2C  090016     REPEAT #0x16
006F2E  785831     MOV.B [W1++], [W0++]
1092:                                  if (Write_HCI_Command(message, hci_buf, 6) == USB_SUCCESS) {
006F30  200062     MOV #0x6, W2
006F32  20CF31     MOV #0xCF3, W1
006F34  20D530     MOV #0xD53, W0
006F36  07FF23     RCALL Write_HCI_Command
006F38  E00400     CP0.B W0
006F3A  3A04BF     BRA NZ, 0x78BA
1093:                                      HciState = HCI_CMD_SCAN_ENABLE;
006F3C  200040     MOV #0x4, W0
006F3E  886440     MOV W0, HciState
1094:                                      DemoState = BT_STATE_READ_DATA;
006F40  200020     MOV #0x2, W0
006F42  886430     MOV W0, DemoState
006F44  3704BA     BRA 0x78BA
1095:                                  };
1096:                                  break;
1097:              
1098:                              case HCI_CMD_SCAN_ENABLE:
1099:                                  hci_buf[0] = 0x1a;
006F46  B3C1A0     MOV.B #0x1A, W0
006F48  B7ECF3     MOV.B WREG, hci_buf
1100:                                  hci_buf[1] = 0x0c;
006F4A  B3C0C0     MOV.B #0xC, W0
006F4C  B7ECF4     MOV.B WREG, 0xCF4
1101:                                  hci_buf[2] = 0x01;
006F4E  B3C010     MOV.B #0x1, W0
006F50  B7ECF5     MOV.B WREG, 0xCF5
1102:                                  hci_buf[3] = 0x03; //enable page
006F52  B3C030     MOV.B #0x3, W0
006F54  B7ECF6     MOV.B WREG, 0xCF6
1103:              
1104:                                  strcpy(message, "HCI_CMD_SCAN_ENABLE: ");
006F56  20D532     MOV #0xD53, W2
006F58  298C50     MOV #0x98C5, W0
006F5A  090015     REPEAT #0x15
006F5C  785930     MOV.B [W0++], [W2++]
1105:                                  if (Write_HCI_Command(message, hci_buf, 4) == USB_SUCCESS) {
006F5E  200042     MOV #0x4, W2
006F60  20CF31     MOV #0xCF3, W1
006F62  20D530     MOV #0xD53, W0
006F64  07FF0C     RCALL Write_HCI_Command
006F66  E00400     CP0.B W0
006F68  3A04A8     BRA NZ, 0x78BA
1106:                                      HciState = HCI_CMD_SCAN_ENABLE_WAIT;
006F6A  200060     MOV #0x6, W0
006F6C  886440     MOV W0, HciState
1107:                                      DemoState = BT_STATE_READ_DATA;
006F6E  200020     MOV #0x2, W0
006F70  886430     MOV W0, DemoState
006F72  3704A3     BRA 0x78BA
1108:                                  };
1109:                                  break;
1110:              
1111:                              case HCI_CMD_INQUIRY:
1112:                                  hci_buf[0] = 0x01;
006F74  B3C010     MOV.B #0x1, W0
006F76  B7ECF3     MOV.B WREG, hci_buf
1113:                                  hci_buf[1] = 0x01 << 2;
006F78  B3C040     MOV.B #0x4, W0
006F7A  B7ECF4     MOV.B WREG, 0xCF4
1114:                                  hci_buf[2] = 0x05; // Parameter Total Length = 5
006F7C  B3C050     MOV.B #0x5, W0
006F7E  B7ECF5     MOV.B WREG, 0xCF5
1115:                                  hci_buf[3] = 0x33; // LAP: Genera/Unlimited Inquiry Access Code (GIAC = 0x9E8B33) - see https://www.bluetooth.org/Technical/AssignedNumbers/baseband.htm
006F80  B3C330     MOV.B #0x33, W0
006F82  B7ECF6     MOV.B WREG, 0xCF6
1116:                                  hci_buf[4] = 0x8B;
006F84  B3C8B0     MOV.B #0x8B, W0
006F86  B7ECF7     MOV.B WREG, 0xCF7
1117:                                  hci_buf[5] = 0x9E;
006F88  404073     ADD.B W0, #0x13, W0
006F8A  B7ECF8     MOV.B WREG, 0xCF8
1118:                                  hci_buf[6] = 0x30; // Inquiry time = 61.44 sec (maximum)
006F8C  B3C300     MOV.B #0x30, W0
006F8E  B7ECF9     MOV.B WREG, 0xCF9
1119:                                  hci_buf[7] = 0x0A; // 10 number of responses
006F90  B3C0A0     MOV.B #0xA, W0
006F92  B7ECFA     MOV.B WREG, 0xCFA
1120:              
1121:              
1122:                                  strcpy(message, "HCI_CMD_INQUIRY: ");
006F94  20D531     MOV #0xD53, W1
006F96  298DB2     MOV #0x98DB, W2
006F98  090011     REPEAT #0x11
006F9A  7858B2     MOV.B [W2++], [W1++]
1123:                                  if (Write_HCI_Command(message, hci_buf, 8) == USB_SUCCESS) {
006F9C  200082     MOV #0x8, W2
006F9E  20CF31     MOV #0xCF3, W1
006FA0  20D530     MOV #0xD53, W0
006FA2  07FEED     RCALL Write_HCI_Command
006FA4  E00400     CP0.B W0
006FA6  3A0489     BRA NZ, 0x78BA
1124:                                      HciState = HCI_CMD_SCAN_ENABLE_WAIT;
006FA8  200060     MOV #0x6, W0
006FAA  886440     MOV W0, HciState
1125:                                      DemoState = BT_STATE_READ_DATA;
006FAC  200020     MOV #0x2, W0
006FAE  886430     MOV W0, DemoState
006FB0  370484     BRA 0x78BA
1126:                                  };
1127:                                  break;
1128:              
1129:              
1130:                              case HCI_CMD_SCAN_ENABLE_WAIT:
1131:                                  USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
006FB2  BFCC84     MOV.B deviceAddress, WREG
006FB4  200572     MOV #0x57, W2
006FB6  200003     MOV #0x0, W3
006FB8  20CF31     MOV #0xCF3, W1
006FBA  071273     RCALL USBHostGenericRead
1132:                                  DemoState = BT_STATE_READ_DATA;
006FBC  200020     MOV #0x2, W0
006FBE  886430     MOV W0, DemoState
006FC0  37047C     BRA 0x78BA
1133:                                  break;
1134:              
1135:                              case HCI_CMD_CREATE_CONNECTION:
1136:                                  hci_buf[0] = 0x05;
006FC2  B3C050     MOV.B #0x5, W0
006FC4  B7ECF3     MOV.B WREG, hci_buf
1137:                                  hci_buf[1] = 0x01 << 2; // HCI OGF = 1
006FC6  B3C040     MOV.B #0x4, W0
006FC8  B7ECF4     MOV.B WREG, 0xCF4
1138:                                  hci_buf[2] = 0x0D; // parameter Total Length = 13
006FCA  B3C0D0     MOV.B #0xD, W0
006FCC  B7ECF5     MOV.B WREG, 0xCF5
1139:                                  hci_buf[3] = remote_bd_addr[0]; // 6 octet bdaddr (LSB)
006FCE  BFCC96     MOV.B remote_bd_addr, WREG
006FD0  B7ECF6     MOV.B WREG, 0xCF6
1140:                                  hci_buf[4] = remote_bd_addr[1];
006FD2  BFCC97     MOV.B 0xC97, WREG
006FD4  B7ECF7     MOV.B WREG, 0xCF7
1141:                                  hci_buf[5] = remote_bd_addr[2];
006FD6  BFCC98     MOV.B 0xC98, WREG
006FD8  B7ECF8     MOV.B WREG, 0xCF8
1142:                                  hci_buf[6] = remote_bd_addr[3];
006FDA  BFCC99     MOV.B 0xC99, WREG
006FDC  B7ECF9     MOV.B WREG, 0xCF9
1143:                                  hci_buf[7] = remote_bd_addr[4];
006FDE  BFCC9A     MOV.B 0xC9A, WREG
006FE0  B7ECFA     MOV.B WREG, 0xCFA
1144:                                  hci_buf[8] = remote_bd_addr[5];
006FE2  BFCC9B     MOV.B 0xC9B, WREG
006FE4  B7ECFB     MOV.B WREG, 0xCFB
1145:                                  hci_buf[9] = 0x18; // DM1 or DH1 may be used
006FE6  B3C180     MOV.B #0x18, W0
006FE8  B7ECFC     MOV.B WREG, 0xCFC
1146:                                  hci_buf[10] = 0xCC; // DM3, DH3, DM5, DH5 may be used
006FEA  B3CCC0     MOV.B #0xCC, W0
006FEC  B7ECFD     MOV.B WREG, 0xCFD
1147:                                  hci_buf[11] = 0x01; // Page repetition mode R1
006FEE  B3C010     MOV.B #0x1, W0
006FF0  B7ECFE     MOV.B WREG, 0xCFE
1148:                                  hci_buf[12] = 0x00; // Reserved
006FF2  EB4000     CLR.B W0
006FF4  B7ECFF     MOV.B WREG, 0xCFF
006FF6  B7ED00     MOV.B WREG, 0xD00
006FF8  B7ED01     MOV.B WREG, 0xD01
006FFA  B7ED02     MOV.B WREG, 0xD02
1149:                                  hci_buf[13] = 0x00; // Clock offset
1150:                                  hci_buf[14] = 0x00; // Invalid clock offset
1151:                                  hci_buf[15] = 0x00; // Do not allow role switch
1152:              
1153:                                  strcpy(message, "HCI_CMD_CREATE_CONNECTION: ");
006FFC  20D531     MOV #0xD53, W1
006FFE  298ED2     MOV #0x98ED, W2
007000  09001B     REPEAT #0x1B
007002  7858B2     MOV.B [W2++], [W1++]
1154:                                  if (Write_HCI_Command(message, hci_buf, 16) == USB_SUCCESS) {
007004  200102     MOV #0x10, W2
007006  20CF31     MOV #0xCF3, W1
007008  20D530     MOV #0xD53, W0
00700A  07FEB9     RCALL Write_HCI_Command
00700C  E00400     CP0.B W0
00700E  3A0455     BRA NZ, 0x78BA
1155:                                      HciState = HCI_CMD_SCAN_ENABLE_WAIT;
007010  200060     MOV #0x6, W0
007012  886440     MOV W0, HciState
1156:                                      DemoState = BT_STATE_READ_DATA;
007014  200020     MOV #0x2, W0
007016  886430     MOV W0, DemoState
007018  370450     BRA 0x78BA
1157:                                  };
1158:              
1159:                                  break;
1160:              
1161:                              case HCI_CMD_INCOMING_ACCEPT: //Accept connection, role change to master
1162:                                  hci_buf[0] = 0x09;
00701A  B3C090     MOV.B #0x9, W0
00701C  B7ECF3     MOV.B WREG, hci_buf
1163:                                  hci_buf[1] = 0x04;
00701E  B3C040     MOV.B #0x4, W0
007020  B7ECF4     MOV.B WREG, 0xCF4
1164:                                  hci_buf[2] = 0x07;
007022  B3C070     MOV.B #0x7, W0
007024  B7ECF5     MOV.B WREG, 0xCF5
1165:                                  hci_buf[3] = remote_bd_addr[0]; //******************************************
007026  BFCC96     MOV.B remote_bd_addr, WREG
007028  B7ECF6     MOV.B WREG, 0xCF6
1166:                                  hci_buf[4] = remote_bd_addr[1]; //BD address (6 octets) of the slave bluetooth
00702A  BFCC97     MOV.B 0xC97, WREG
00702C  B7ECF7     MOV.B WREG, 0xCF7
1167:                                  hci_buf[5] = remote_bd_addr[2]; //
00702E  BFCC98     MOV.B 0xC98, WREG
007030  B7ECF8     MOV.B WREG, 0xCF8
1168:                                  hci_buf[6] = remote_bd_addr[3]; //
007032  BFCC99     MOV.B 0xC99, WREG
007034  B7ECF9     MOV.B WREG, 0xCF9
1169:                                  hci_buf[7] = remote_bd_addr[4]; //
007036  BFCC9A     MOV.B 0xC9A, WREG
007038  B7ECFA     MOV.B WREG, 0xCFA
1170:                                  hci_buf[8] = remote_bd_addr[5]; //******************************************
00703A  BFCC9B     MOV.B 0xC9B, WREG
00703C  B7ECFB     MOV.B WREG, 0xCFB
1171:                                  hci_buf[9] = 0x00;
00703E  EF6CFC     CLR.B 0xCFC
1172:              
1173:                                  strcpy(message, "HCI_CMD_ACCEPT_INCOMING. ROLE CHANGE REQUESTED: ");
007040  20D531     MOV #0xD53, W1
007042  299092     MOV #0x9909, W2
007044  090030     REPEAT #0x30
007046  7858B2     MOV.B [W2++], [W1++]
1174:                                  if (Write_HCI_Command(message, hci_buf, 10) == USB_SUCCESS) {
007048  2000A2     MOV #0xA, W2
00704A  20CF31     MOV #0xCF3, W1
00704C  20D530     MOV #0xD53, W0
00704E  07FE97     RCALL Write_HCI_Command
007050  E00400     CP0.B W0
007052  3A0433     BRA NZ, 0x78BA
1175:                                      HciState = HCI_ROLE_CHANGE_WAIT;
007054  200090     MOV #0x9, W0
007056  886440     MOV W0, HciState
1176:                                      DemoState = BT_STATE_READ_DATA;
007058  200020     MOV #0x2, W0
00705A  886430     MOV W0, DemoState
00705C  37042E     BRA 0x78BA
1177:                                  };
1178:                                  break;
1179:              
1180:                              case HCI_ROLE_CHANGE_WAIT:
1181:                                  USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
00705E  BFCC84     MOV.B deviceAddress, WREG
007060  200572     MOV #0x57, W2
007062  200003     MOV #0x0, W3
007064  20CF31     MOV #0xCF3, W1
007066  07121D     RCALL USBHostGenericRead
007068  370428     BRA 0x78BA
1182:                                  break;
1183:              
1184:                              case HCI_CMD_CONNECTION_ACCEPTED:
1185:                                  HciState = HCI_CMD_SCAN_DISABLE;
00706A  2000B0     MOV #0xB, W0
00706C  886440     MOV W0, HciState
00706E  370425     BRA 0x78BA
1186:                                  break;
1187:              
1188:                              case HCI_CMD_SCAN_DISABLE: //wait for controller to initiate L2CAP Connection Request
1189:                                  hci_buf[0] = 0x1a;
007070  B3C1A0     MOV.B #0x1A, W0
007072  B7ECF3     MOV.B WREG, hci_buf
1190:                                  hci_buf[1] = 0x0c;
007074  B3C0C0     MOV.B #0xC, W0
007076  B7ECF4     MOV.B WREG, 0xCF4
1191:                                  hci_buf[2] = 0x01;
007078  B3C010     MOV.B #0x1, W0
00707A  B7ECF5     MOV.B WREG, 0xCF5
1192:                                  hci_buf[3] = 0x00; //disable scan
00707C  EF6CF6     CLR.B 0xCF6
1193:                                  strcpy(message, "HCI_CMD_SCAN_DISABLE: ");
00707E  20D530     MOV #0xD53, W0
007080  2993A1     MOV #0x993A, W1
007082  090016     REPEAT #0x16
007084  785831     MOV.B [W1++], [W0++]
1194:                                  if (Write_HCI_Command(message, hci_buf, 4) == USB_SUCCESS) {
007086  200042     MOV #0x4, W2
007088  20CF31     MOV #0xCF3, W1
00708A  20D530     MOV #0xD53, W0
00708C  07FE78     RCALL Write_HCI_Command
00708E  E00400     CP0.B W0
007090  3A0414     BRA NZ, 0x78BA
1195:                                      HciState = HCI_READ;
007092  200200     MOV #0x20, W0
007094  886440     MOV W0, HciState
007096  370411     BRA 0x78BA
1196:                                  };
1197:                                  break;
1198:              
1199:                              case LINK_KEY_REPLY: //wait for controller to initiate L2CAP Connection Request
1200:                                  hci_buf[0] = 0x0B;
007098  B3C0B0     MOV.B #0xB, W0
00709A  B7ECF3     MOV.B WREG, hci_buf
1201:                                  hci_buf[1] = 0x01 << 2;
00709C  B3C040     MOV.B #0x4, W0
00709E  B7ECF4     MOV.B WREG, 0xCF4
1202:                                  hci_buf[2] = 22;
0070A0  B3C160     MOV.B #0x16, W0
0070A2  B7ECF5     MOV.B WREG, 0xCF5
1203:                                  hci_buf[3] = remote_bd_addr[0];
0070A4  BFCC96     MOV.B remote_bd_addr, WREG
0070A6  B7ECF6     MOV.B WREG, 0xCF6
1204:                                  hci_buf[4] = remote_bd_addr[1];
0070A8  BFCC97     MOV.B 0xC97, WREG
0070AA  B7ECF7     MOV.B WREG, 0xCF7
1205:                                  hci_buf[5] = remote_bd_addr[2];
0070AC  BFCC98     MOV.B 0xC98, WREG
0070AE  B7ECF8     MOV.B WREG, 0xCF8
1206:                                  hci_buf[6] = remote_bd_addr[3];
0070B0  BFCC99     MOV.B 0xC99, WREG
0070B2  B7ECF9     MOV.B WREG, 0xCF9
1207:                                  hci_buf[7] = remote_bd_addr[4];
0070B4  BFCC9A     MOV.B 0xC9A, WREG
0070B6  B7ECFA     MOV.B WREG, 0xCFA
1208:                                  hci_buf[8] = remote_bd_addr[5];
0070B8  BFCC9B     MOV.B 0xC9B, WREG
0070BA  B7ECFB     MOV.B WREG, 0xCFB
1209:                                  hci_buf[9] = 0x56;
0070BC  B3C560     MOV.B #0x56, W0
0070BE  B7ECFC     MOV.B WREG, 0xCFC
1210:                                  hci_buf[10] = 0xE8;
0070C0  B3CE80     MOV.B #0xE8, W0
0070C2  B7ECFD     MOV.B WREG, 0xCFD
1211:                                  hci_buf[11] = 0x81;
0070C4  B3C810     MOV.B #0x81, W0
0070C6  B7ECFE     MOV.B WREG, 0xCFE
1212:                                  hci_buf[12] = 0x38;
0070C8  B3C380     MOV.B #0x38, W0
0070CA  B7ECFF     MOV.B WREG, 0xCFF
1213:                                  hci_buf[13] = 0x08;
0070CC  B3C080     MOV.B #0x8, W0
0070CE  B7ED00     MOV.B WREG, 0xD00
1214:                                  hci_buf[14] = 0x06;
0070D0  B3C060     MOV.B #0x6, W0
0070D2  B7ED01     MOV.B WREG, 0xD01
1215:                                  hci_buf[15] = 0x51;
0070D4  B3C510     MOV.B #0x51, W0
0070D6  B7ED02     MOV.B WREG, 0xD02
1216:                                  hci_buf[16] = 0x41;
0070D8  504070     SUB.B W0, #0x10, W0
0070DA  B7ED03     MOV.B WREG, 0xD03
1217:                                  hci_buf[17] = 0xC0;
0070DC  B3CC00     MOV.B #0xC0, W0
0070DE  B7ED04     MOV.B WREG, 0xD04
1218:                                  hci_buf[18] = 0x7F;
0070E0  B3C7F0     MOV.B #0x7F, W0
0070E2  B7ED05     MOV.B WREG, 0xD05
1219:                                  hci_buf[19] = 0x12;
0070E4  B3C120     MOV.B #0x12, W0
0070E6  B7ED06     MOV.B WREG, 0xD06
1220:                                  hci_buf[20] = 0xAA;
0070E8  B3CAA0     MOV.B #0xAA, W0
0070EA  B7ED07     MOV.B WREG, 0xD07
1221:                                  hci_buf[21] = 0xD9;
0070EC  B3CD90     MOV.B #0xD9, W0
0070EE  B7ED08     MOV.B WREG, 0xD08
1222:                                  hci_buf[22] = 0x66;
0070F0  B3C660     MOV.B #0x66, W0
0070F2  B7ED09     MOV.B WREG, 0xD09
1223:                                  hci_buf[23] = 0x3C;
0070F4  B3C3C0     MOV.B #0x3C, W0
0070F6  B7ED0A     MOV.B WREG, 0xD0A
1224:                                  hci_buf[24] = 0xCE;
0070F8  B3CCE0     MOV.B #0xCE, W0
0070FA  B7ED0B     MOV.B WREG, 0xD0B
1225:              
1226:              
1227:                                  strcpy(message, "LINK_KEY_REPLY: ");
0070FC  20D531     MOV #0xD53, W1
0070FE  299512     MOV #0x9951, W2
007100  090010     REPEAT #0x10
007102  7858B2     MOV.B [W2++], [W1++]
1228:                                  if (Write_HCI_Command(message, hci_buf, 25) == USB_SUCCESS) {
007104  200192     MOV #0x19, W2
007106  20CF31     MOV #0xCF3, W1
007108  20D530     MOV #0xD53, W0
00710A  07FE39     RCALL Write_HCI_Command
00710C  E00400     CP0.B W0
00710E  3A03D5     BRA NZ, 0x78BA
1229:                                      HciState = HCI_READ;
007110  200200     MOV #0x20, W0
007112  886440     MOV W0, HciState
007114  3703D2     BRA 0x78BA
1230:                                  };
1231:                                  break;
1232:                                  //HCI_ACL ************************************************************************
1233:                                  //Respond to PS4 controller's request to open a connection channel for HID_Control 0x0011
1234:                                  /*              
1235:                                            case L2CAP_CONNECT_REQ01:
1236:                                                packet_id = 1;
1237:                                                acl_buf[0]=handle[0];
1238:                                                acl_buf[1]=handle[1]+0x20;   
1239:                                                acl_buf[2]=0x0C;//length
1240:                                                acl_buf[3]=0x00;
1241:                                                acl_buf[4]=0x08; //length
1242:                                                acl_buf[5]=0x00;
1243:                                                acl_buf[6]=0x01; //cid
1244:                                                acl_buf[7]=0x00;
1245:                                                acl_buf[8]=0x02; //code
1246:                                                acl_buf[9]=0x01; //packet id
1247:                                                acl_buf[10]=0x04; //length
1248:                                                acl_buf[11]=0x00;
1249:                                                acl_buf[12]=0x11;//HID PSM
1250:                                                acl_buf[13]=0x00;
1251:                                                acl_buf[14]=cid_host_ctrl[0];
1252:                                                acl_buf[15]=cid_host_ctrl[1];
1253:              
1254:                                                strcpy(message,"L2CAP_CONNECT_REQ01 ");
1255:                                                if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS)
1256:                                                {
1257:                                                    HciState = HCI_READ; 
1258:                                                }
1259:                              
1260:                                                break;
1261:                                   */
1262:                              case L2CAP_CONNECT_RESP01:
1263:                                  acl_buf[0] = handle[0];
007116  BFCD4A     MOV.B handle, WREG
007118  B7EC9C     MOV.B WREG, acl_buf
1264:                                  acl_buf[1] = handle[1] + 0x20;
00711A  BFCD4B     MOV.B 0xD4B, WREG
00711C  B04200     ADD.B #0x20, W0
00711E  B7EC9D     MOV.B WREG, 0xC9D
1265:                                  acl_buf[2] = 0x10;
007120  B3C100     MOV.B #0x10, W0
007122  B7EC9E     MOV.B WREG, 0xC9E
1266:                                  acl_buf[3] = 0x00;
007124  EB4080     CLR.B W1
007126  780001     MOV W1, W0
007128  B7EC9F     MOV.B WREG, 0xC9F
1267:                                  acl_buf[4] = 0x0c;
00712A  B3C0C0     MOV.B #0xC, W0
00712C  B7ECA0     MOV.B WREG, 0xCA0
1268:                                  acl_buf[5] = 0x00;
00712E  780001     MOV W1, W0
007130  B7ECA1     MOV.B WREG, 0xCA1
1269:                                  acl_buf[6] = 0x01;
007132  B3C010     MOV.B #0x1, W0
007134  B7ECA2     MOV.B WREG, 0xCA2
1270:                                  acl_buf[7] = 0x00;
007136  780001     MOV W1, W0
007138  B7ECA3     MOV.B WREG, 0xCA3
1271:                                  acl_buf[8] = 0x03;
00713A  B3C030     MOV.B #0x3, W0
00713C  B7ECA4     MOV.B WREG, 0xCA4
1272:                                  acl_buf[9] = packet_id;
00713E  BFCD52     MOV.B packet_id, WREG
007140  B7ECA5     MOV.B WREG, 0xCA5
1273:                                  acl_buf[10] = 0x08;
007142  B3C080     MOV.B #0x8, W0
007144  B7ECA6     MOV.B WREG, 0xCA6
1274:                                  acl_buf[11] = 0x00;
007146  780001     MOV W1, W0
007148  B7ECA7     MOV.B WREG, 0xCA7
1275:                                  acl_buf[12] = cid_host_sdp[0];
00714A  B3C720     MOV.B #0x72, W0
00714C  B7ECA8     MOV.B WREG, 0xCA8
1276:                                  acl_buf[13] = cid_host_sdp[1];
00714E  780001     MOV W1, W0
007150  B7ECA9     MOV.B WREG, 0xCA9
1277:                                  acl_buf[14] = cid_dev_sdp[0];
007152  BFCD50     MOV.B cid_dev_sdp, WREG
007154  B7ECAA     MOV.B WREG, 0xCAA
1278:                                  acl_buf[15] = cid_dev_sdp[1];
007156  BFCD51     MOV.B 0xD51, WREG
007158  B7ECAB     MOV.B WREG, 0xCAB
1279:                                  acl_buf[16] = 0x00;
00715A  FD0080     EXCH W0, W1
00715C  B7ECAC     MOV.B WREG, 0xCAC
00715E  B7ECAD     MOV.B WREG, 0xCAD
007160  B7ECAE     MOV.B WREG, 0xCAE
007162  B7ECAF     MOV.B WREG, 0xCAF
007164  FD0080     EXCH W0, W1
1280:                                  acl_buf[17] = 0x00;
1281:                                  acl_buf[18] = 0x00;
1282:                                  acl_buf[19] = 0x00;
1283:              
1284:                                  UART2PrintString("SCID CTRL = ");
007166  299620     MOV #0x9962, W0
007168  07128A     RCALL UART2PrintString
1285:                                  UART2PutHex(cid_host_ctrl[0]);
00716A  200700     MOV #0x70, W0
00716C  071354     RCALL UART2PutHex
1286:                                  UART2PrintString("\n\r");
00716E  2947C0     MOV #0x947C, W0
007170  071286     RCALL UART2PrintString
1287:                                  strcpy(message, "L2CAP_CONNECT_RESP01: ");
007172  20D531     MOV #0xD53, W1
007174  2996F2     MOV #0x996F, W2
007176  090016     REPEAT #0x16
007178  7858B2     MOV.B [W2++], [W1++]
1288:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
00717A  200142     MOV #0x14, W2
00717C  20C9C1     MOV #0xC9C, W1
00717E  20D530     MOV #0xD53, W0
007180  07FE0D     RCALL Write_ACL_Command
007182  E00400     CP0.B W0
007184  3A039A     BRA NZ, 0x78BA
1289:                                      HciState = L2CAP_CONFIG_REQ01; //No response from controller, go to config request
007186  2000E0     MOV #0xE, W0
007188  886440     MOV W0, HciState
00718A  370397     BRA 0x78BA
1290:                                  }
1291:              
1292:                                  break;
1293:                                  //Config request for Ch 0x0001 (SDP
1294:                              case L2CAP_CONFIG_REQ01: //config request
1295:                                  acl_buf[0] = handle[0];
00718C  BFCD4A     MOV.B handle, WREG
00718E  B7EC9C     MOV.B WREG, acl_buf
1296:                                  acl_buf[1] = handle[1] + 0x20;
007190  BFCD4B     MOV.B 0xD4B, WREG
007192  B04200     ADD.B #0x20, W0
007194  B7EC9D     MOV.B WREG, 0xC9D
1297:                                  acl_buf[2] = 0x10; //length
007196  B3C100     MOV.B #0x10, W0
007198  B7EC9E     MOV.B WREG, 0xC9E
1298:                                  acl_buf[3] = 0x00;
00719A  EB4080     CLR.B W1
00719C  780001     MOV W1, W0
00719E  B7EC9F     MOV.B WREG, 0xC9F
1299:                                  acl_buf[4] = 0x0c; //length
0071A0  B3C0C0     MOV.B #0xC, W0
0071A2  B7ECA0     MOV.B WREG, 0xCA0
1300:                                  acl_buf[5] = 0x00;
0071A4  780001     MOV W1, W0
0071A6  B7ECA1     MOV.B WREG, 0xCA1
1301:                                  acl_buf[6] = 0x01; //CID
0071A8  B3C012     MOV.B #0x1, W2
0071AA  780002     MOV W2, W0
0071AC  B7ECA2     MOV.B WREG, 0xCA2
1302:                                  acl_buf[7] = 0x00;
0071AE  780001     MOV W1, W0
0071B0  B7ECA3     MOV.B WREG, 0xCA3
1303:                                  acl_buf[8] = 0x04;
0071B2  B3C040     MOV.B #0x4, W0
0071B4  B7ECA4     MOV.B WREG, 0xCA4
1304:                                  acl_buf[9] = 0x01;
0071B6  780002     MOV W2, W0
0071B8  B7ECA5     MOV.B WREG, 0xCA5
1305:                                  acl_buf[10] = 0x08;
0071BA  B3C080     MOV.B #0x8, W0
0071BC  B7ECA6     MOV.B WREG, 0xCA6
1306:                                  acl_buf[11] = 0x00;
0071BE  780001     MOV W1, W0
0071C0  B7ECA7     MOV.B WREG, 0xCA7
1307:                                  acl_buf[12] = cid_dev_sdp[0];
0071C2  BFCD50     MOV.B cid_dev_sdp, WREG
0071C4  B7ECA8     MOV.B WREG, 0xCA8
1308:                                  acl_buf[13] = cid_dev_sdp[1];
0071C6  BFCD51     MOV.B 0xD51, WREG
0071C8  B7ECA9     MOV.B WREG, 0xCA9
1309:                                  acl_buf[14] = 0x00;
0071CA  FD0080     EXCH W0, W1
0071CC  B7ECAA     MOV.B WREG, 0xCAA
0071CE  B7ECAB     MOV.B WREG, 0xCAB
0071D0  FD0080     EXCH W0, W1
1310:                                  acl_buf[15] = 0x00;
1311:                                  acl_buf[16] = 0x01;
0071D2  780002     MOV W2, W0
0071D4  B7ECAC     MOV.B WREG, 0xCAC
1312:                                  acl_buf[17] = 0x02;
0071D6  B3C020     MOV.B #0x2, W0
0071D8  B7ECAD     MOV.B WREG, 0xCAD
1313:                                  acl_buf[18] = 0x40;
0071DA  B3C400     MOV.B #0x40, W0
0071DC  B7ECAE     MOV.B WREG, 0xCAE
1314:                                  acl_buf[19] = 0x00;
0071DE  780001     MOV W1, W0
0071E0  B7ECAF     MOV.B WREG, 0xCAF
1315:              
1316:                                  strcpy(message, "L2CAP_CONFIG_REQ01: ");
0071E2  20D531     MOV #0xD53, W1
0071E4  299862     MOV #0x9986, W2
0071E6  090014     REPEAT #0x14
0071E8  7858B2     MOV.B [W2++], [W1++]
1317:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
0071EA  200142     MOV #0x14, W2
0071EC  20C9C1     MOV #0xC9C, W1
0071EE  20D530     MOV #0xD53, W0
0071F0  07FDD5     RCALL Write_ACL_Command
0071F2  E00400     CP0.B W0
0071F4  3A0362     BRA NZ, 0x78BA
1318:                                      HciState = HCI_READ; //Wait for response
0071F6  200200     MOV #0x20, W0
0071F8  886440     MOV W0, HciState
0071FA  37035F     BRA 0x78BA
1319:                                  }
1320:                                  break;
1321:              
1322:                              case L2CAP_CONFIG_RESP01:
1323:                                  acl_buf[0] = handle[0];
0071FC  BFCD4A     MOV.B handle, WREG
0071FE  B7EC9C     MOV.B WREG, acl_buf
1324:                                  acl_buf[1] = handle[1] + 0x20;
007200  BFCD4B     MOV.B 0xD4B, WREG
007202  B04200     ADD.B #0x20, W0
007204  B7EC9D     MOV.B WREG, 0xC9D
1325:                                  acl_buf[2] = 0x0e;
007206  B3C0E0     MOV.B #0xE, W0
007208  B7EC9E     MOV.B WREG, 0xC9E
1326:                                  acl_buf[3] = 0x00;
00720A  EB4080     CLR.B W1
00720C  780001     MOV W1, W0
00720E  B7EC9F     MOV.B WREG, 0xC9F
1327:                                  acl_buf[4] = 0x0a;
007210  B3C0A0     MOV.B #0xA, W0
007212  B7ECA0     MOV.B WREG, 0xCA0
1328:                                  acl_buf[5] = 0x00;
007214  780001     MOV W1, W0
007216  B7ECA1     MOV.B WREG, 0xCA1
1329:                                  acl_buf[6] = 0x01;
007218  B3C010     MOV.B #0x1, W0
00721A  B7ECA2     MOV.B WREG, 0xCA2
1330:                                  acl_buf[7] = 0x00;
00721C  780001     MOV W1, W0
00721E  B7ECA3     MOV.B WREG, 0xCA3
1331:                                  acl_buf[8] = 0x05;
007220  B3C050     MOV.B #0x5, W0
007222  B7ECA4     MOV.B WREG, 0xCA4
1332:                                  acl_buf[9] = packet_id;
007224  BFCD52     MOV.B packet_id, WREG
007226  B7ECA5     MOV.B WREG, 0xCA5
1333:                                  acl_buf[10] = 0x06;
007228  B3C060     MOV.B #0x6, W0
00722A  B7ECA6     MOV.B WREG, 0xCA6
1334:                                  acl_buf[11] = 0x00;
00722C  780001     MOV W1, W0
00722E  B7ECA7     MOV.B WREG, 0xCA7
1335:                                  acl_buf[12] = cid_dev_sdp[0];
007230  BFCD50     MOV.B cid_dev_sdp, WREG
007232  B7ECA8     MOV.B WREG, 0xCA8
1336:                                  acl_buf[13] = cid_dev_sdp[1];
007234  BFCD51     MOV.B 0xD51, WREG
007236  B7ECA9     MOV.B WREG, 0xCA9
1337:                                  acl_buf[14] = 0x00;
007238  FD0080     EXCH W0, W1
00723A  B7ECAA     MOV.B WREG, 0xCAA
00723C  B7ECAB     MOV.B WREG, 0xCAB
00723E  B7ECAC     MOV.B WREG, 0xCAC
007240  B7ECAD     MOV.B WREG, 0xCAD
007242  FD0080     EXCH W0, W1
1338:                                  acl_buf[15] = 0x00;
1339:                                  acl_buf[16] = 0x00;
1340:                                  acl_buf[17] = 0x00;
1341:              
1342:                                  strcpy(message, "L2CAP_CONFIG_RESP01: ");
007244  20D531     MOV #0xD53, W1
007246  2999B2     MOV #0x999B, W2
007248  090015     REPEAT #0x15
00724A  7858B2     MOV.B [W2++], [W1++]
1343:                                  if (Write_ACL_Command(message, acl_buf, 18) == USB_SUCCESS) {
00724C  200122     MOV #0x12, W2
00724E  20C9C1     MOV #0xC9C, W1
007250  20D530     MOV #0xD53, W0
007252  07FDA4     RCALL Write_ACL_Command
007254  E00400     CP0.B W0
007256  3A0331     BRA NZ, 0x78BA
1344:                                      HciState = L2CAP_DISCONNECT_SDP; //wait for response
007258  200100     MOV #0x10, W0
00725A  886440     MOV W0, HciState
1345:                                      DemoState = BT_STATE_READ_DATA;
00725C  200020     MOV #0x2, W0
00725E  886430     MOV W0, DemoState
007260  37032C     BRA 0x78BA
1346:                                  }
1347:                                  break;
1348:              
1349:                              case L2CAP_DISCONNECT_SDP:
1350:                                  acl_buf[0] = handle[0];
007262  BFCD4A     MOV.B handle, WREG
007264  B7EC9C     MOV.B WREG, acl_buf
1351:                                  acl_buf[1] = handle[1] + 0x20;
007266  BFCD4B     MOV.B 0xD4B, WREG
007268  B04200     ADD.B #0x20, W0
00726A  B7EC9D     MOV.B WREG, 0xC9D
1352:                                  acl_buf[2] = 0x0c;
00726C  B3C0C0     MOV.B #0xC, W0
00726E  B7EC9E     MOV.B WREG, 0xC9E
1353:                                  acl_buf[3] = 0x00;
007270  EB4080     CLR.B W1
007272  780001     MOV W1, W0
007274  B7EC9F     MOV.B WREG, 0xC9F
1354:                                  acl_buf[4] = 0x08;
007276  B3C080     MOV.B #0x8, W0
007278  B7ECA0     MOV.B WREG, 0xCA0
1355:                                  acl_buf[5] = 0x00;
00727A  780001     MOV W1, W0
00727C  B7ECA1     MOV.B WREG, 0xCA1
1356:                                  acl_buf[6] = 0x01;
00727E  B3C010     MOV.B #0x1, W0
007280  B7ECA2     MOV.B WREG, 0xCA2
1357:                                  acl_buf[7] = 0x00;
007282  780001     MOV W1, W0
007284  B7ECA3     MOV.B WREG, 0xCA3
1358:                                  acl_buf[8] = 0x06; //disconnect command
007286  B3C060     MOV.B #0x6, W0
007288  B7ECA4     MOV.B WREG, 0xCA4
1359:                                  acl_buf[9] = packet_id;
00728A  BFCD52     MOV.B packet_id, WREG
00728C  B7ECA5     MOV.B WREG, 0xCA5
1360:                                  acl_buf[10] = 0x04;
00728E  B3C040     MOV.B #0x4, W0
007290  B7ECA6     MOV.B WREG, 0xCA6
1361:                                  acl_buf[11] = 0x00;
007292  780001     MOV W1, W0
007294  B7ECA7     MOV.B WREG, 0xCA7
1362:                                  acl_buf[12] = cid_dev_sdp[0];
007296  BFCD50     MOV.B cid_dev_sdp, WREG
007298  B7ECA8     MOV.B WREG, 0xCA8
1363:                                  acl_buf[13] = cid_dev_sdp[1];
00729A  BFCD51     MOV.B 0xD51, WREG
00729C  B7ECA9     MOV.B WREG, 0xCA9
1364:                                  acl_buf[14] = cid_host_sdp[0];
00729E  B3C720     MOV.B #0x72, W0
0072A0  B7ECAA     MOV.B WREG, 0xCAA
1365:                                  acl_buf[15] = cid_host_sdp[1];
0072A2  780001     MOV W1, W0
0072A4  B7ECAB     MOV.B WREG, 0xCAB
1366:                                  strcpy(message, "L2CAP_DISCONNECT_SDP_REQ: ");
0072A6  20D531     MOV #0xD53, W1
0072A8  299B12     MOV #0x99B1, W2
0072AA  09001A     REPEAT #0x1A
0072AC  7858B2     MOV.B [W2++], [W1++]
1367:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
0072AE  200102     MOV #0x10, W2
0072B0  20C9C1     MOV #0xC9C, W1
0072B2  20D530     MOV #0xD53, W0
0072B4  07FD73     RCALL Write_ACL_Command
0072B6  E00400     CP0.B W0
0072B8  3A0300     BRA NZ, 0x78BA
1368:                                      HciState = HCI_READ;
0072BA  200200     MOV #0x20, W0
0072BC  886440     MOV W0, HciState
0072BE  3702FD     BRA 0x78BA
1369:                                  }
1370:                                  break;
1371:              
1372:                              case L2CAP_DISCONNECT_RESP01:
1373:                                  acl_buf[0] = handle[0];
0072C0  BFCD4A     MOV.B handle, WREG
0072C2  B7EC9C     MOV.B WREG, acl_buf
1374:                                  acl_buf[1] = handle[1] + 0x20;
0072C4  BFCD4B     MOV.B 0xD4B, WREG
0072C6  B04200     ADD.B #0x20, W0
0072C8  B7EC9D     MOV.B WREG, 0xC9D
1375:                                  acl_buf[2] = 0x0c;
0072CA  B3C0C0     MOV.B #0xC, W0
0072CC  B7EC9E     MOV.B WREG, 0xC9E
1376:                                  acl_buf[3] = 0x00;
0072CE  EB4080     CLR.B W1
0072D0  780001     MOV W1, W0
0072D2  B7EC9F     MOV.B WREG, 0xC9F
1377:                                  acl_buf[4] = 0x08;
0072D4  B3C080     MOV.B #0x8, W0
0072D6  B7ECA0     MOV.B WREG, 0xCA0
1378:                                  acl_buf[5] = 0x00;
0072D8  780001     MOV W1, W0
0072DA  B7ECA1     MOV.B WREG, 0xCA1
1379:                                  acl_buf[6] = 0x01;
0072DC  B3C010     MOV.B #0x1, W0
0072DE  B7ECA2     MOV.B WREG, 0xCA2
1380:                                  acl_buf[7] = 0x00;
0072E0  780001     MOV W1, W0
0072E2  B7ECA3     MOV.B WREG, 0xCA3
1381:                                  acl_buf[8] = 0x06;
0072E4  B3C060     MOV.B #0x6, W0
0072E6  B7ECA4     MOV.B WREG, 0xCA4
1382:                                  acl_buf[9] = packet_id;
0072E8  BFCD52     MOV.B packet_id, WREG
0072EA  B7ECA5     MOV.B WREG, 0xCA5
1383:                                  acl_buf[10] = 0x04;
0072EC  B3C040     MOV.B #0x4, W0
0072EE  B7ECA6     MOV.B WREG, 0xCA6
1384:                                  acl_buf[11] = 0x00;
0072F0  780001     MOV W1, W0
0072F2  B7ECA7     MOV.B WREG, 0xCA7
1385:                                  acl_buf[12] = cid_host_sdp[0];
0072F4  B3C720     MOV.B #0x72, W0
0072F6  B7ECA8     MOV.B WREG, 0xCA8
1386:                                  acl_buf[13] = cid_host_sdp[1];
0072F8  780001     MOV W1, W0
0072FA  B7ECA9     MOV.B WREG, 0xCA9
1387:                                  acl_buf[14] = cid_dev_sdp[0];
0072FC  BFCD50     MOV.B cid_dev_sdp, WREG
0072FE  B7ECAA     MOV.B WREG, 0xCAA
1388:                                  acl_buf[15] = cid_dev_sdp[1];
007300  BFCD51     MOV.B 0xD51, WREG
007302  B7ECAB     MOV.B WREG, 0xCAB
1389:              
1390:                                  strcpy(message, "L2CAP_DISCONNECT_RESP01: ");
007304  20D531     MOV #0xD53, W1
007306  299CC2     MOV #0x99CC, W2
007308  090019     REPEAT #0x19
00730A  7858B2     MOV.B [W2++], [W1++]
1391:                                  if (Write_ACL_Command(message, acl_buf, 18) == USB_SUCCESS) {
00730C  200122     MOV #0x12, W2
00730E  20C9C1     MOV #0xC9C, W1
007310  20D530     MOV #0xD53, W0
007312  07FD44     RCALL Write_ACL_Command
007314  E00400     CP0.B W0
007316  3A02D1     BRA NZ, 0x78BA
1392:                                      HciState = HCI_READ; //wait for response
007318  200200     MOV #0x20, W0
00731A  886440     MOV W0, HciState
00731C  3702CE     BRA 0x78BA
1393:                                  }
1394:                                  break;
1395:              
1396:                              case L2CAP_CONNECT_REQ11:
1397:                                  acl_buf[0] = handle[0];
00731E  BFCD4A     MOV.B handle, WREG
007320  B7EC9C     MOV.B WREG, acl_buf
1398:                                  acl_buf[1] = handle[1] + 0x20;
007322  BFCD4B     MOV.B 0xD4B, WREG
007324  B04200     ADD.B #0x20, W0
007326  B7EC9D     MOV.B WREG, 0xC9D
1399:                                  acl_buf[2] = 0x0C;
007328  B3C0C0     MOV.B #0xC, W0
00732A  B7EC9E     MOV.B WREG, 0xC9E
1400:                                  acl_buf[3] = 0x00;
00732C  EB4080     CLR.B W1
00732E  780001     MOV W1, W0
007330  B7EC9F     MOV.B WREG, 0xC9F
1401:                                  acl_buf[4] = 0x08;
007332  B3C080     MOV.B #0x8, W0
007334  B7ECA0     MOV.B WREG, 0xCA0
1402:                                  acl_buf[5] = 0x00;
007336  780001     MOV W1, W0
007338  B7ECA1     MOV.B WREG, 0xCA1
1403:                                  acl_buf[6] = 0x01;
00733A  B3C010     MOV.B #0x1, W0
00733C  B7ECA2     MOV.B WREG, 0xCA2
1404:                                  acl_buf[7] = 0x00;
00733E  780001     MOV W1, W0
007340  B7ECA3     MOV.B WREG, 0xCA3
1405:                                  acl_buf[8] = 0x02;
007342  B3C020     MOV.B #0x2, W0
007344  B7ECA4     MOV.B WREG, 0xCA4
1406:                                  acl_buf[9] = packet_id;
007346  BFCD52     MOV.B packet_id, WREG
007348  B7ECA5     MOV.B WREG, 0xCA5
1407:                                  acl_buf[10] = 0x04;
00734A  B3C040     MOV.B #0x4, W0
00734C  B7ECA6     MOV.B WREG, 0xCA6
1408:                                  acl_buf[11] = 0x00;
00734E  780001     MOV W1, W0
007350  B7ECA7     MOV.B WREG, 0xCA7
1409:                                  acl_buf[12] = 0x011; //PSM = 0x0011
007352  B3C110     MOV.B #0x11, W0
007354  B7ECA8     MOV.B WREG, 0xCA8
1410:                                  acl_buf[13] = 0x00;
007356  780001     MOV W1, W0
007358  B7ECA9     MOV.B WREG, 0xCA9
1411:                                  acl_buf[14] = cid_host_ctrl[0];
00735A  B3C700     MOV.B #0x70, W0
00735C  B7ECAA     MOV.B WREG, 0xCAA
1412:                                  acl_buf[15] = cid_host_ctrl[1];
00735E  780001     MOV W1, W0
007360  B7ECAB     MOV.B WREG, 0xCAB
1413:              
1414:                                  UART2PrintString("SCID CTRL = ");
007362  299620     MOV #0x9962, W0
007364  07118C     RCALL UART2PrintString
1415:                                  UART2PutHex(cid_host_ctrl[0]);
007366  200700     MOV #0x70, W0
007368  071256     RCALL UART2PutHex
1416:                                  UART2PrintString("\n\r");
00736A  2947C0     MOV #0x947C, W0
00736C  071188     RCALL UART2PrintString
1417:                                  strcpy(message, "L2CAP_CONNECT_REQ11: ");
00736E  20D531     MOV #0xD53, W1
007370  299E62     MOV #0x99E6, W2
007372  090015     REPEAT #0x15
007374  7858B2     MOV.B [W2++], [W1++]
1418:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
007376  200102     MOV #0x10, W2
007378  20C9C1     MOV #0xC9C, W1
00737A  20D530     MOV #0xD53, W0
00737C  07FD0F     RCALL Write_ACL_Command
00737E  E00400     CP0.B W0
007380  3A029C     BRA NZ, 0x78BA
1419:                                      HciState = HCI_READ; //No response from controller, go to config request
007382  200200     MOV #0x20, W0
007384  886440     MOV W0, HciState
007386  370299     BRA 0x78BA
1420:                                  }
1421:                                  break;
1422:              
1423:                              case L2CAP_CONNECT_RESP11:
1424:                                  acl_buf[0] = handle[0];
007388  BFCD4A     MOV.B handle, WREG
00738A  B7EC9C     MOV.B WREG, acl_buf
1425:                                  acl_buf[1] = handle[1] + 0x20;
00738C  BFCD4B     MOV.B 0xD4B, WREG
00738E  B04200     ADD.B #0x20, W0
007390  B7EC9D     MOV.B WREG, 0xC9D
1426:                                  acl_buf[2] = 0x10;
007392  B3C100     MOV.B #0x10, W0
007394  B7EC9E     MOV.B WREG, 0xC9E
1427:                                  acl_buf[3] = 0x00;
007396  EB4080     CLR.B W1
007398  780001     MOV W1, W0
00739A  B7EC9F     MOV.B WREG, 0xC9F
1428:                                  acl_buf[4] = 0x0c;
00739C  B3C0C0     MOV.B #0xC, W0
00739E  B7ECA0     MOV.B WREG, 0xCA0
1429:                                  acl_buf[5] = 0x00;
0073A0  780001     MOV W1, W0
0073A2  B7ECA1     MOV.B WREG, 0xCA1
1430:                                  acl_buf[6] = 0x01;
0073A4  B3C010     MOV.B #0x1, W0
0073A6  B7ECA2     MOV.B WREG, 0xCA2
1431:                                  acl_buf[7] = 0x00;
0073A8  780001     MOV W1, W0
0073AA  B7ECA3     MOV.B WREG, 0xCA3
1432:                                  acl_buf[8] = 0x03;
0073AC  B3C030     MOV.B #0x3, W0
0073AE  B7ECA4     MOV.B WREG, 0xCA4
1433:                                  acl_buf[9] = packet_id;
0073B0  BFCD52     MOV.B packet_id, WREG
0073B2  B7ECA5     MOV.B WREG, 0xCA5
1434:                                  acl_buf[10] = 0x08;
0073B4  B3C080     MOV.B #0x8, W0
0073B6  B7ECA6     MOV.B WREG, 0xCA6
1435:                                  acl_buf[11] = 0x00;
0073B8  780001     MOV W1, W0
0073BA  B7ECA7     MOV.B WREG, 0xCA7
1436:                                  acl_buf[12] = cid_host_ctrl[0];
0073BC  B3C700     MOV.B #0x70, W0
0073BE  B7ECA8     MOV.B WREG, 0xCA8
1437:                                  acl_buf[13] = cid_host_ctrl[1];
0073C0  780001     MOV W1, W0
0073C2  B7ECA9     MOV.B WREG, 0xCA9
1438:                                  acl_buf[14] = cid_dev_ctrl[0];
0073C4  BFCD4C     MOV.B cid_dev_ctrl, WREG
0073C6  B7ECAA     MOV.B WREG, 0xCAA
1439:                                  acl_buf[15] = cid_dev_ctrl[1];
0073C8  BFCD4D     MOV.B 0xD4D, WREG
0073CA  B7ECAB     MOV.B WREG, 0xCAB
1440:                                  acl_buf[16] = 0x00;
0073CC  FD0080     EXCH W0, W1
0073CE  B7ECAC     MOV.B WREG, 0xCAC
0073D0  B7ECAD     MOV.B WREG, 0xCAD
0073D2  B7ECAE     MOV.B WREG, 0xCAE
0073D4  B7ECAF     MOV.B WREG, 0xCAF
0073D6  FD0080     EXCH W0, W1
1441:                                  acl_buf[17] = 0x00;
1442:                                  acl_buf[18] = 0x00;
1443:                                  acl_buf[19] = 0x00;
1444:              
1445:                                  UART2PrintString("SCID CTRL = ");
0073D8  299620     MOV #0x9962, W0
0073DA  071151     RCALL UART2PrintString
1446:                                  UART2PutHex(cid_host_ctrl[0]);
0073DC  200700     MOV #0x70, W0
0073DE  07121B     RCALL UART2PutHex
1447:                                  UART2PrintString("\n\r");
0073E0  2947C0     MOV #0x947C, W0
0073E2  07114D     RCALL UART2PrintString
1448:                                  strcpy(message, "L2CAP_CONNECT_RESP11: ");
0073E4  20D531     MOV #0xD53, W1
0073E6  299FC2     MOV #0x99FC, W2
0073E8  090016     REPEAT #0x16
0073EA  7858B2     MOV.B [W2++], [W1++]
1449:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
0073EC  200142     MOV #0x14, W2
0073EE  20C9C1     MOV #0xC9C, W1
0073F0  20D530     MOV #0xD53, W0
0073F2  07FCD4     RCALL Write_ACL_Command
0073F4  E00400     CP0.B W0
0073F6  3A0261     BRA NZ, 0x78BA
1450:                                      HciState = L2CAP_CONFIG_REQ11; //No response from controller, go to config request
0073F8  200140     MOV #0x14, W0
0073FA  886440     MOV W0, HciState
0073FC  37025E     BRA 0x78BA
1451:                                  }
1452:                                  break;
1453:              
1454:                                  //Config request for Ch 0x0011
1455:                              case L2CAP_CONFIG_REQ11: //config request
1456:                                  acl_buf[0] = handle[0];
0073FE  BFCD4A     MOV.B handle, WREG
007400  B7EC9C     MOV.B WREG, acl_buf
1457:                                  acl_buf[1] = handle[1] + 0x20;
007402  BFCD4B     MOV.B 0xD4B, WREG
007404  B04200     ADD.B #0x20, W0
007406  B7EC9D     MOV.B WREG, 0xC9D
1458:                                  acl_buf[2] = 0x10;
007408  B3C100     MOV.B #0x10, W0
00740A  B7EC9E     MOV.B WREG, 0xC9E
1459:                                  acl_buf[3] = 0x00;
00740C  EB4080     CLR.B W1
00740E  780001     MOV W1, W0
007410  B7EC9F     MOV.B WREG, 0xC9F
1460:                                  acl_buf[4] = 0x0c;
007412  B3C0C0     MOV.B #0xC, W0
007414  B7ECA0     MOV.B WREG, 0xCA0
1461:                                  acl_buf[5] = 0x00;
007416  780001     MOV W1, W0
007418  B7ECA1     MOV.B WREG, 0xCA1
1462:                                  acl_buf[6] = 0x01;
00741A  B3C012     MOV.B #0x1, W2
00741C  780002     MOV W2, W0
00741E  B7ECA2     MOV.B WREG, 0xCA2
1463:                                  acl_buf[7] = 0x00;
007420  780001     MOV W1, W0
007422  B7ECA3     MOV.B WREG, 0xCA3
1464:                                  acl_buf[8] = 0x04;
007424  B3C040     MOV.B #0x4, W0
007426  B7ECA4     MOV.B WREG, 0xCA4
1465:                                  acl_buf[9] = 0x01;
007428  780002     MOV W2, W0
00742A  B7ECA5     MOV.B WREG, 0xCA5
1466:                                  acl_buf[10] = 0x08;
00742C  B3C080     MOV.B #0x8, W0
00742E  B7ECA6     MOV.B WREG, 0xCA6
1467:                                  acl_buf[11] = 0x00;
007430  780001     MOV W1, W0
007432  B7ECA7     MOV.B WREG, 0xCA7
1468:                                  acl_buf[12] = cid_dev_ctrl[0];
007434  BFCD4C     MOV.B cid_dev_ctrl, WREG
007436  B7ECA8     MOV.B WREG, 0xCA8
1469:                                  acl_buf[13] = cid_dev_ctrl[1];
007438  BFCD4D     MOV.B 0xD4D, WREG
00743A  B7ECA9     MOV.B WREG, 0xCA9
1470:                                  acl_buf[14] = 0x00;
00743C  FD0080     EXCH W0, W1
00743E  B7ECAA     MOV.B WREG, 0xCAA
007440  B7ECAB     MOV.B WREG, 0xCAB
007442  FD0080     EXCH W0, W1
1471:                                  acl_buf[15] = 0x00;
1472:                                  acl_buf[16] = 0x01;
007444  780002     MOV W2, W0
007446  B7ECAC     MOV.B WREG, 0xCAC
1473:                                  acl_buf[17] = 0x02;
007448  B3C020     MOV.B #0x2, W0
00744A  B7ECAD     MOV.B WREG, 0xCAD
1474:                                  acl_buf[18] = 0x40;
00744C  B3C400     MOV.B #0x40, W0
00744E  B7ECAE     MOV.B WREG, 0xCAE
1475:                                  acl_buf[19] = 0x00;
007450  780001     MOV W1, W0
007452  B7ECAF     MOV.B WREG, 0xCAF
1476:              
1477:                                  strcpy(message, "L2CAP_CONFIG_REQ11: ");
007454  20D531     MOV #0xD53, W1
007456  29A132     MOV #0x9A13, W2
007458  090014     REPEAT #0x14
00745A  7858B2     MOV.B [W2++], [W1++]
1478:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
00745C  200142     MOV #0x14, W2
00745E  20C9C1     MOV #0xC9C, W1
007460  20D530     MOV #0xD53, W0
007462  07FC9C     RCALL Write_ACL_Command
007464  E00400     CP0.B W0
007466  3A0229     BRA NZ, 0x78BA
1479:                                      HciState = HCI_READ; //Wait for response
007468  200200     MOV #0x20, W0
00746A  886440     MOV W0, HciState
00746C  370226     BRA 0x78BA
1480:                                  }
1481:                                  break;
1482:              
1483:                                  //Respond to config request for Ch 0x0011
1484:                              case L2CAP_CONFIG_RESP11:
1485:                                  acl_buf[0] = handle[0];
00746E  BFCD4A     MOV.B handle, WREG
007470  B7EC9C     MOV.B WREG, acl_buf
1486:                                  acl_buf[1] = handle[1] + 0x20;
007472  BFCD4B     MOV.B 0xD4B, WREG
007474  B04200     ADD.B #0x20, W0
007476  B7EC9D     MOV.B WREG, 0xC9D
1487:                                  acl_buf[2] = 0x0e;
007478  B3C0E0     MOV.B #0xE, W0
00747A  B7EC9E     MOV.B WREG, 0xC9E
1488:                                  acl_buf[3] = 0x00;
00747C  EB4080     CLR.B W1
00747E  780001     MOV W1, W0
007480  B7EC9F     MOV.B WREG, 0xC9F
1489:                                  acl_buf[4] = 0x0a;
007482  B3C0A0     MOV.B #0xA, W0
007484  B7ECA0     MOV.B WREG, 0xCA0
1490:                                  acl_buf[5] = 0x00;
007486  780001     MOV W1, W0
007488  B7ECA1     MOV.B WREG, 0xCA1
1491:                                  acl_buf[6] = 0x01;
00748A  B3C010     MOV.B #0x1, W0
00748C  B7ECA2     MOV.B WREG, 0xCA2
1492:                                  acl_buf[7] = 0x00;
00748E  780001     MOV W1, W0
007490  B7ECA3     MOV.B WREG, 0xCA3
1493:                                  acl_buf[8] = 0x05;
007492  B3C050     MOV.B #0x5, W0
007494  B7ECA4     MOV.B WREG, 0xCA4
1494:                                  acl_buf[9] = packet_id;
007496  BFCD52     MOV.B packet_id, WREG
007498  B7ECA5     MOV.B WREG, 0xCA5
1495:                                  acl_buf[10] = 0x06;
00749A  B3C060     MOV.B #0x6, W0
00749C  B7ECA6     MOV.B WREG, 0xCA6
1496:                                  acl_buf[11] = 0x00;
00749E  780001     MOV W1, W0
0074A0  B7ECA7     MOV.B WREG, 0xCA7
1497:                                  acl_buf[12] = cid_dev_ctrl[0];
0074A2  BFCD4C     MOV.B cid_dev_ctrl, WREG
0074A4  B7ECA8     MOV.B WREG, 0xCA8
1498:                                  acl_buf[13] = cid_dev_ctrl[1];
0074A6  BFCD4D     MOV.B 0xD4D, WREG
0074A8  B7ECA9     MOV.B WREG, 0xCA9
1499:                                  acl_buf[14] = 0x00;
0074AA  FD0080     EXCH W0, W1
0074AC  B7ECAA     MOV.B WREG, 0xCAA
0074AE  B7ECAB     MOV.B WREG, 0xCAB
0074B0  B7ECAC     MOV.B WREG, 0xCAC
0074B2  B7ECAD     MOV.B WREG, 0xCAD
0074B4  FD0080     EXCH W0, W1
1500:                                  acl_buf[15] = 0x00;
1501:                                  acl_buf[16] = 0x00;
1502:                                  acl_buf[17] = 0x00;
1503:              
1504:                                  strcpy(message, "L2CAP_CONFIG_RESP11: ");
0074B6  20D531     MOV #0xD53, W1
0074B8  29A282     MOV #0x9A28, W2
0074BA  090015     REPEAT #0x15
0074BC  7858B2     MOV.B [W2++], [W1++]
1505:                                  if (Write_ACL_Command(message, acl_buf, 18) == USB_SUCCESS) {
0074BE  200122     MOV #0x12, W2
0074C0  20C9C1     MOV #0xC9C, W1
0074C2  20D530     MOV #0xD53, W0
0074C4  07FC6B     RCALL Write_ACL_Command
0074C6  E00400     CP0.B W0
0074C8  3A01F8     BRA NZ, 0x78BA
1506:                                      HciState = HCI_READ; //wait for response
0074CA  200200     MOV #0x20, W0
0074CC  886440     MOV W0, HciState
0074CE  3701F5     BRA 0x78BA
1507:                                  }
1508:                                  break;
1509:              
1510:                                  //Respond to PS4 controller's request to open a connection channel for HID_Interrupt 0x0013
1511:                              case L2CAP_CONNECT_RESP13:
1512:                                  acl_buf[0] = handle[0];
0074D0  BFCD4A     MOV.B handle, WREG
0074D2  B7EC9C     MOV.B WREG, acl_buf
1513:                                  acl_buf[1] = handle[1] + 0x20;
0074D4  BFCD4B     MOV.B 0xD4B, WREG
0074D6  B04200     ADD.B #0x20, W0
0074D8  B7EC9D     MOV.B WREG, 0xC9D
1514:                                  acl_buf[2] = 0x10;
0074DA  B3C100     MOV.B #0x10, W0
0074DC  B7EC9E     MOV.B WREG, 0xC9E
1515:                                  acl_buf[3] = 0x00;
0074DE  EB4080     CLR.B W1
0074E0  780001     MOV W1, W0
0074E2  B7EC9F     MOV.B WREG, 0xC9F
1516:                                  acl_buf[4] = 0x0c;
0074E4  B3C0C0     MOV.B #0xC, W0
0074E6  B7ECA0     MOV.B WREG, 0xCA0
1517:                                  acl_buf[5] = 0x00;
0074E8  780001     MOV W1, W0
0074EA  B7ECA1     MOV.B WREG, 0xCA1
1518:                                  acl_buf[6] = 0x01;
0074EC  B3C010     MOV.B #0x1, W0
0074EE  B7ECA2     MOV.B WREG, 0xCA2
1519:                                  acl_buf[7] = 0x00;
0074F0  780001     MOV W1, W0
0074F2  B7ECA3     MOV.B WREG, 0xCA3
1520:                                  acl_buf[8] = 0x03;
0074F4  B3C030     MOV.B #0x3, W0
0074F6  B7ECA4     MOV.B WREG, 0xCA4
1521:                                  acl_buf[9] = packet_id;
0074F8  BFCD52     MOV.B packet_id, WREG
0074FA  B7ECA5     MOV.B WREG, 0xCA5
1522:                                  acl_buf[10] = 0x08;
0074FC  B3C080     MOV.B #0x8, W0
0074FE  B7ECA6     MOV.B WREG, 0xCA6
1523:                                  acl_buf[11] = 0x00;
007500  780001     MOV W1, W0
007502  B7ECA7     MOV.B WREG, 0xCA7
1524:                                  acl_buf[12] = cid_host_data[0];
007504  B3C710     MOV.B #0x71, W0
007506  B7ECA8     MOV.B WREG, 0xCA8
1525:                                  acl_buf[13] = cid_host_data[1];
007508  780001     MOV W1, W0
00750A  B7ECA9     MOV.B WREG, 0xCA9
1526:                                  acl_buf[14] = cid_dev_data[0];
00750C  BFCD4E     MOV.B cid_dev_data, WREG
00750E  B7ECAA     MOV.B WREG, 0xCAA
1527:                                  acl_buf[15] = cid_dev_data[1];
007510  BFCD4F     MOV.B 0xD4F, WREG
007512  B7ECAB     MOV.B WREG, 0xCAB
1528:                                  acl_buf[16] = 0x00;
007514  FD0080     EXCH W0, W1
007516  B7ECAC     MOV.B WREG, 0xCAC
007518  B7ECAD     MOV.B WREG, 0xCAD
00751A  B7ECAE     MOV.B WREG, 0xCAE
00751C  B7ECAF     MOV.B WREG, 0xCAF
00751E  FD0080     EXCH W0, W1
1529:                                  acl_buf[17] = 0x00;
1530:                                  acl_buf[18] = 0x00;
1531:                                  acl_buf[19] = 0x00;
1532:              
1533:                                  UART2PrintString("SCID DATA = ");
007520  29A3E0     MOV #0x9A3E, W0
007522  0710AD     RCALL UART2PrintString
1534:                                  UART2PutHex(cid_host_data[0]);
007524  200710     MOV #0x71, W0
007526  071177     RCALL UART2PutHex
1535:                                  UART2PrintString("\n\r");
007528  2947C0     MOV #0x947C, W0
00752A  0710A9     RCALL UART2PrintString
1536:                                  strcpy(message, "L2CAP_CONNECT_RESP13: ");
00752C  20D531     MOV #0xD53, W1
00752E  29A4B2     MOV #0x9A4B, W2
007530  090016     REPEAT #0x16
007532  7858B2     MOV.B [W2++], [W1++]
1537:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
007534  200142     MOV #0x14, W2
007536  20C9C1     MOV #0xC9C, W1
007538  20D530     MOV #0xD53, W0
00753A  07FC30     RCALL Write_ACL_Command
00753C  E00400     CP0.B W0
00753E  3A01BD     BRA NZ, 0x78BA
1538:                                      HciState = L2CAP_CONFIG_REQ13;
007540  200170     MOV #0x17, W0
007542  886440     MOV W0, HciState
007544  3701BA     BRA 0x78BA
1539:                                  }
1540:                                  break;
1541:              
1542:                              case L2CAP_CONFIG_REQ13:
1543:                                  acl_buf[0] = handle[0];
007546  BFCD4A     MOV.B handle, WREG
007548  B7EC9C     MOV.B WREG, acl_buf
1544:                                  acl_buf[1] = handle[1] + 0x20;
00754A  BFCD4B     MOV.B 0xD4B, WREG
00754C  B04200     ADD.B #0x20, W0
00754E  B7EC9D     MOV.B WREG, 0xC9D
1545:                                  acl_buf[2] = 0x10;
007550  B3C100     MOV.B #0x10, W0
007552  B7EC9E     MOV.B WREG, 0xC9E
1546:                                  acl_buf[3] = 0x00;
007554  EB4080     CLR.B W1
007556  780001     MOV W1, W0
007558  B7EC9F     MOV.B WREG, 0xC9F
1547:                                  acl_buf[4] = 0x0c;
00755A  B3C0C0     MOV.B #0xC, W0
00755C  B7ECA0     MOV.B WREG, 0xCA0
1548:                                  acl_buf[5] = 0x00;
00755E  780001     MOV W1, W0
007560  B7ECA1     MOV.B WREG, 0xCA1
1549:                                  acl_buf[6] = 0x01;
007562  B3C013     MOV.B #0x1, W3
007564  780003     MOV W3, W0
007566  B7ECA2     MOV.B WREG, 0xCA2
1550:                                  acl_buf[7] = 0x00;
007568  780001     MOV W1, W0
00756A  B7ECA3     MOV.B WREG, 0xCA3
1551:                                  acl_buf[8] = 0x04;
00756C  B3C040     MOV.B #0x4, W0
00756E  B7ECA4     MOV.B WREG, 0xCA4
1552:                                  acl_buf[9] = 0x02;
007570  B3C022     MOV.B #0x2, W2
007572  780002     MOV W2, W0
007574  B7ECA5     MOV.B WREG, 0xCA5
1553:                                  acl_buf[10] = 0x08;
007576  B3C080     MOV.B #0x8, W0
007578  B7ECA6     MOV.B WREG, 0xCA6
1554:                                  acl_buf[11] = 0x00;
00757A  780001     MOV W1, W0
00757C  B7ECA7     MOV.B WREG, 0xCA7
1555:                                  acl_buf[12] = cid_dev_data[0];
00757E  BFCD4E     MOV.B cid_dev_data, WREG
007580  B7ECA8     MOV.B WREG, 0xCA8
1556:                                  acl_buf[13] = cid_dev_data[1];
007582  BFCD4F     MOV.B 0xD4F, WREG
007584  B7ECA9     MOV.B WREG, 0xCA9
1557:                                  acl_buf[14] = 0x00;
007586  FD0080     EXCH W0, W1
007588  B7ECAA     MOV.B WREG, 0xCAA
00758A  B7ECAB     MOV.B WREG, 0xCAB
00758C  FD0080     EXCH W0, W1
1558:                                  acl_buf[15] = 0x00;
1559:                                  acl_buf[16] = 0x01;
00758E  780003     MOV W3, W0
007590  B7ECAC     MOV.B WREG, 0xCAC
1560:                                  acl_buf[17] = 0x02;
007592  780002     MOV W2, W0
007594  B7ECAD     MOV.B WREG, 0xCAD
1561:                                  acl_buf[18] = 0x40;
007596  B3C400     MOV.B #0x40, W0
007598  B7ECAE     MOV.B WREG, 0xCAE
1562:                                  acl_buf[19] = 0x00;
00759A  780001     MOV W1, W0
00759C  B7ECAF     MOV.B WREG, 0xCAF
1563:              
1564:                                  strcpy(message, "L2CAP_CONFIG_REQ13: ");
00759E  20D531     MOV #0xD53, W1
0075A0  29A622     MOV #0x9A62, W2
0075A2  090014     REPEAT #0x14
0075A4  7858B2     MOV.B [W2++], [W1++]
1565:                                  if (Write_ACL_Command(message, acl_buf, 20) == USB_SUCCESS) {
0075A6  200142     MOV #0x14, W2
0075A8  20C9C1     MOV #0xC9C, W1
0075AA  20D530     MOV #0xD53, W0
0075AC  07FBF7     RCALL Write_ACL_Command
0075AE  E00400     CP0.B W0
0075B0  3A0184     BRA NZ, 0x78BA
1566:                                      HciState = HCI_READ; //wait for response
0075B2  200200     MOV #0x20, W0
0075B4  886440     MOV W0, HciState
0075B6  370181     BRA 0x78BA
1567:                                  }
1568:                                  break;
1569:              
1570:                              case L2CAP_CONFIG_RESP13:
1571:                                  acl_buf[0] = handle[0];
0075B8  BFCD4A     MOV.B handle, WREG
0075BA  B7EC9C     MOV.B WREG, acl_buf
1572:                                  acl_buf[1] = handle[1] + 0x20;
0075BC  BFCD4B     MOV.B 0xD4B, WREG
0075BE  B04200     ADD.B #0x20, W0
0075C0  B7EC9D     MOV.B WREG, 0xC9D
1573:                                  acl_buf[2] = 0x0e;
0075C2  B3C0E0     MOV.B #0xE, W0
0075C4  B7EC9E     MOV.B WREG, 0xC9E
1574:                                  acl_buf[3] = 0x00;
0075C6  EB4080     CLR.B W1
0075C8  780001     MOV W1, W0
0075CA  B7EC9F     MOV.B WREG, 0xC9F
1575:                                  acl_buf[4] = 0x0a;
0075CC  B3C0A0     MOV.B #0xA, W0
0075CE  B7ECA0     MOV.B WREG, 0xCA0
1576:                                  acl_buf[5] = 0x00;
0075D0  780001     MOV W1, W0
0075D2  B7ECA1     MOV.B WREG, 0xCA1
1577:                                  acl_buf[6] = 0x01;
0075D4  B3C010     MOV.B #0x1, W0
0075D6  B7ECA2     MOV.B WREG, 0xCA2
1578:                                  acl_buf[7] = 0x00;
0075D8  780001     MOV W1, W0
0075DA  B7ECA3     MOV.B WREG, 0xCA3
1579:                                  acl_buf[8] = 0x05;
0075DC  B3C050     MOV.B #0x5, W0
0075DE  B7ECA4     MOV.B WREG, 0xCA4
1580:                                  acl_buf[9] = packet_id;
0075E0  BFCD52     MOV.B packet_id, WREG
0075E2  B7ECA5     MOV.B WREG, 0xCA5
1581:                                  acl_buf[10] = 0x06;
0075E4  B3C060     MOV.B #0x6, W0
0075E6  B7ECA6     MOV.B WREG, 0xCA6
1582:                                  acl_buf[11] = 0x00;
0075E8  780001     MOV W1, W0
0075EA  B7ECA7     MOV.B WREG, 0xCA7
1583:                                  acl_buf[12] = cid_dev_data[0];
0075EC  BFCD4E     MOV.B cid_dev_data, WREG
0075EE  B7ECA8     MOV.B WREG, 0xCA8
1584:                                  acl_buf[13] = cid_dev_data[1];
0075F0  BFCD4F     MOV.B 0xD4F, WREG
0075F2  B7ECA9     MOV.B WREG, 0xCA9
1585:                                  acl_buf[14] = 0x00;
0075F4  FD0080     EXCH W0, W1
0075F6  B7ECAA     MOV.B WREG, 0xCAA
0075F8  B7ECAB     MOV.B WREG, 0xCAB
0075FA  B7ECAC     MOV.B WREG, 0xCAC
0075FC  B7ECAD     MOV.B WREG, 0xCAD
0075FE  FD0080     EXCH W0, W1
1586:                                  acl_buf[15] = 0x00;
1587:                                  acl_buf[16] = 0x00;
1588:                                  acl_buf[17] = 0x00;
1589:              
1590:                                  strcpy(message, "L2CAP_CONFIG_RESP13: ");
007600  20D531     MOV #0xD53, W1
007602  29A772     MOV #0x9A77, W2
007604  090015     REPEAT #0x15
007606  7858B2     MOV.B [W2++], [W1++]
1591:                                  if (Write_ACL_Command(message, acl_buf, 18) == USB_SUCCESS) {
007608  200122     MOV #0x12, W2
00760A  20C9C1     MOV #0xC9C, W1
00760C  20D530     MOV #0xD53, W0
00760E  07FBC6     RCALL Write_ACL_Command
007610  E00400     CP0.B W0
007612  3A0153     BRA NZ, 0x78BA
1592:                                      HciState = PS4_BT_INIT;
007614  200190     MOV #0x19, W0
007616  886440     MOV W0, HciState
1593:                                      DemoState = BT_STATE_READ_DATA;
007618  200020     MOV #0x2, W0
00761A  886430     MOV W0, DemoState
00761C  37014E     BRA 0x78BA
1594:                                  }
1595:                                  break;
1596:              
1597:                              case PS4_BT_INIT:
1598:                                  //Initialize output packet values
1599:                                  GetOutputReportBT()[0] = handle[0];
00761E  070A81     RCALL GetOutputReportBT
007620  781F81     MOV W1, [W15++]
007622  20D4A1     MOV #0xD4A, W1
007624  784811     MOV.B [W1], [W0]
007626  7800CF     MOV [--W15], W1
1600:                                  GetOutputReportBT()[1] = handle[1] + 0x20;
007628  070A7C     RCALL GetOutputReportBT
00762A  20D4B1     MOV #0xD4B, W1
00762C  784091     MOV.B [W1], W1
00762E  B04201     ADD.B #0x20, W1
007630  984011     MOV.B W1, [W0+1]
1601:                                  GetOutputReportBT()[2] = 83;
007632  070A77     RCALL GetOutputReportBT
007634  B3C531     MOV.B #0x53, W1
007636  984021     MOV.B W1, [W0+2]
1602:                                  GetOutputReportBT()[3] = 0x00;
007638  070A74     RCALL GetOutputReportBT
00763A  EB4400     CLR.B W8
00763C  984038     MOV.B W8, [W0+3]
1603:                                  GetOutputReportBT()[4] = 79;
00763E  070A71     RCALL GetOutputReportBT
007640  B3C4F1     MOV.B #0x4F, W1
007642  984041     MOV.B W1, [W0+4]
1604:                                  GetOutputReportBT()[5] = 0x00;
007644  070A6E     RCALL GetOutputReportBT
007646  984058     MOV.B W8, [W0+5]
1605:                                  GetOutputReportBT()[6] = cid_dev_ctrl[0];
007648  070A6C     RCALL GetOutputReportBT
00764A  20D4C1     MOV #0xD4C, W1
00764C  784091     MOV.B [W1], W1
00764E  984061     MOV.B W1, [W0+6]
1606:                                  GetOutputReportBT()[7] = cid_dev_ctrl[1];
007650  070A68     RCALL GetOutputReportBT
007652  20D4D2     MOV #0xD4D, W2
007654  784112     MOV.B [W2], W2
007656  984072     MOV.B W2, [W0+7]
1607:                                  GetOutputReportBT()[8] = 0x52; //0 HID BT Set_report (0x50) | Report Type (Output 0x02)
007658  070A64     RCALL GetOutputReportBT
00765A  B3C521     MOV.B #0x52, W1
00765C  984801     MOV.B W1, [W0+8]
1608:                                  GetOutputReportBT()[9] = 0x11; //1 Report ID
00765E  070A61     RCALL GetOutputReportBT
007660  B3C111     MOV.B #0x11, W1
007662  984811     MOV.B W1, [W0+9]
1609:                                  GetOutputReportBT()[10] = 0x80; //2
007664  070A5E     RCALL GetOutputReportBT
007666  B3C801     MOV.B #0x80, W1
007668  984821     MOV.B W1, [W0+10]
1610:                                  GetOutputReportBT()[11] = 0x00; //3
00766A  070A5B     RCALL GetOutputReportBT
00766C  984838     MOV.B W8, [W0+11]
1611:                                  GetOutputReportBT()[12] = 0xff; //4 enable
00766E  070A59     RCALL GetOutputReportBT
007670  EBC080     SETM.B W1
007672  984841     MOV.B W1, [W0+12]
1612:                                  GetOutputReportBT()[13] = 0x00; //5
007674  070A56     RCALL GetOutputReportBT
007676  984858     MOV.B W8, [W0+13]
1613:                                  GetOutputReportBT()[14] = 0x00; //6
007678  070A54     RCALL GetOutputReportBT
00767A  984868     MOV.B W8, [W0+14]
1614:              
1615:              
1616:                                  acl_buf[0] = handle[0];
00767C  BFCD4A     MOV.B handle, WREG
00767E  B7EC9C     MOV.B WREG, acl_buf
1617:                                  acl_buf[1] = handle[1] + 0x20;
007680  BFCD4B     MOV.B 0xD4B, WREG
007682  B04200     ADD.B #0x20, W0
007684  B7EC9D     MOV.B WREG, 0xC9D
1618:                                  acl_buf[2] = 0x06;
007686  B3C060     MOV.B #0x6, W0
007688  B7EC9E     MOV.B WREG, 0xC9E
1619:                                  acl_buf[3] = 0x00;
00768A  780008     MOV W8, W0
00768C  B7EC9F     MOV.B WREG, 0xC9F
1620:                                  acl_buf[4] = 0x02;
00768E  B3C021     MOV.B #0x2, W1
007690  780001     MOV W1, W0
007692  B7ECA0     MOV.B WREG, 0xCA0
1621:                                  acl_buf[5] = 0x00;
007694  780008     MOV W8, W0
007696  B7ECA1     MOV.B WREG, 0xCA1
1622:                                  acl_buf[6] = cid_dev_ctrl[0];
007698  BFCD4C     MOV.B cid_dev_ctrl, WREG
00769A  B7ECA2     MOV.B WREG, 0xCA2
1623:                                  acl_buf[7] = cid_dev_ctrl[1];
00769C  BFCD4D     MOV.B 0xD4D, WREG
00769E  B7ECA3     MOV.B WREG, 0xCA3
1624:                                  acl_buf[8] = 0x43;
0076A0  B3C430     MOV.B #0x43, W0
0076A2  B7ECA4     MOV.B WREG, 0xCA4
1625:                                  acl_buf[9] = 0x02;
0076A4  780001     MOV W1, W0
0076A6  B7ECA5     MOV.B WREG, 0xCA5
1626:              
1627:                                  strcpy(message, "GET FEATURE 0x02 (PS4_BT_INIT): ");
0076A8  20D531     MOV #0xD53, W1
0076AA  29A8D2     MOV #0x9A8D, W2
0076AC  090020     REPEAT #0x20
0076AE  7858B2     MOV.B [W2++], [W1++]
1628:                                  if (Write_ACL_Command(message, acl_buf, 10) == USB_SUCCESS) {
0076B0  2000A2     MOV #0xA, W2
0076B2  20C9C1     MOV #0xC9C, W1
0076B4  20D530     MOV #0xD53, W0
0076B6  07FB72     RCALL Write_ACL_Command
0076B8  E00400     CP0.B W0
0076BA  3A00FF     BRA NZ, 0x78BA
1629:                                      HciState = PS4_BT_RUNNING;
0076BC  2001A0     MOV #0x1A, W0
0076BE  886440     MOV W0, HciState
0076C0  3700FC     BRA 0x78BA
1630:                                  }
1631:                                  break;
1632:              
1633:                              case PS4_BT_RUNNING:
1634:                                  USBHostGenericAclRead(deviceAddress, acl_buf, DATA_PACKET_LENGTH);
0076C2  BFCC84     MOV.B deviceAddress, WREG
0076C4  200572     MOV #0x57, W2
0076C6  200003     MOV #0x0, W3
0076C8  20C9C1     MOV #0xC9C, W1
0076CA  070F7D     RCALL USBHostGenericAclRead
1635:                                  USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
0076CC  BFCC84     MOV.B deviceAddress, WREG
0076CE  200572     MOV #0x57, W2
0076D0  200003     MOV #0x0, W3
0076D2  20CF31     MOV #0xCF3, W1
0076D4  070EE6     RCALL USBHostGenericRead
0076D6  3700F1     BRA 0x78BA
1636:                                  break;
1637:              
1638:                              case L2CAP_DISCONNECT_DATA_RESP:
1639:                                  acl_buf[0] = handle[0];
0076D8  BFCD4A     MOV.B handle, WREG
0076DA  B7EC9C     MOV.B WREG, acl_buf
1640:                                  acl_buf[1] = handle[1] + 0x20;
0076DC  BFCD4B     MOV.B 0xD4B, WREG
0076DE  B04200     ADD.B #0x20, W0
0076E0  B7EC9D     MOV.B WREG, 0xC9D
1641:                                  acl_buf[2] = 0x0c;
0076E2  B3C0C0     MOV.B #0xC, W0
0076E4  B7EC9E     MOV.B WREG, 0xC9E
1642:                                  acl_buf[3] = 0x00;
0076E6  EB4080     CLR.B W1
0076E8  780001     MOV W1, W0
0076EA  B7EC9F     MOV.B WREG, 0xC9F
1643:                                  acl_buf[4] = 0x08;
0076EC  B3C080     MOV.B #0x8, W0
0076EE  B7ECA0     MOV.B WREG, 0xCA0
1644:                                  acl_buf[5] = 0x00;
0076F0  780001     MOV W1, W0
0076F2  B7ECA1     MOV.B WREG, 0xCA1
1645:                                  acl_buf[6] = 0x01;
0076F4  B3C010     MOV.B #0x1, W0
0076F6  B7ECA2     MOV.B WREG, 0xCA2
1646:                                  acl_buf[7] = 0x00;
0076F8  780001     MOV W1, W0
0076FA  B7ECA3     MOV.B WREG, 0xCA3
1647:                                  acl_buf[8] = 0x07;
0076FC  B3C070     MOV.B #0x7, W0
0076FE  B7ECA4     MOV.B WREG, 0xCA4
1648:                                  acl_buf[9] = packet_id;
007700  BFCD52     MOV.B packet_id, WREG
007702  B7ECA5     MOV.B WREG, 0xCA5
1649:                                  acl_buf[10] = 0x04;
007704  B3C040     MOV.B #0x4, W0
007706  B7ECA6     MOV.B WREG, 0xCA6
1650:                                  acl_buf[11] = 0x00;
007708  780001     MOV W1, W0
00770A  B7ECA7     MOV.B WREG, 0xCA7
1651:                                  acl_buf[12] = cid_host_data[0];
00770C  B3C710     MOV.B #0x71, W0
00770E  B7ECA8     MOV.B WREG, 0xCA8
1652:                                  acl_buf[13] = cid_host_data[1];
007710  780001     MOV W1, W0
007712  B7ECA9     MOV.B WREG, 0xCA9
1653:                                  acl_buf[14] = cid_dev_data[0];
007714  BFCD4E     MOV.B cid_dev_data, WREG
007716  B7ECAA     MOV.B WREG, 0xCAA
1654:                                  acl_buf[15] = cid_dev_data[1];
007718  BFCD4F     MOV.B 0xD4F, WREG
00771A  B7ECAB     MOV.B WREG, 0xCAB
1655:                                  strcpy(message, "L2CAP_DISCONNECT_DATA_RESP: ");
00771C  20D531     MOV #0xD53, W1
00771E  29AAE2     MOV #0x9AAE, W2
007720  09001C     REPEAT #0x1C
007722  7858B2     MOV.B [W2++], [W1++]
1656:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
007724  200102     MOV #0x10, W2
007726  20C9C1     MOV #0xC9C, W1
007728  20D530     MOV #0xD53, W0
00772A  07FB38     RCALL Write_ACL_Command
00772C  E00400     CP0.B W0
00772E  3A00C5     BRA NZ, 0x78BA
1657:                                      HciState = PS4_BT_RUNNING;
007730  2001A0     MOV #0x1A, W0
007732  886440     MOV W0, HciState
007734  3700C2     BRA 0x78BA
1658:                                  }
1659:                                  break;
1660:              
1661:                              case L2CAP_DISCONNECT_CTRL_RESP:
1662:                                  acl_buf[0] = handle[0];
007736  BFCD4A     MOV.B handle, WREG
007738  B7EC9C     MOV.B WREG, acl_buf
1663:                                  acl_buf[1] = handle[1] + 0x20;
00773A  BFCD4B     MOV.B 0xD4B, WREG
00773C  B04200     ADD.B #0x20, W0
00773E  B7EC9D     MOV.B WREG, 0xC9D
1664:                                  acl_buf[2] = 0x0c;
007740  B3C0C0     MOV.B #0xC, W0
007742  B7EC9E     MOV.B WREG, 0xC9E
1665:                                  acl_buf[3] = 0x00;
007744  EB4080     CLR.B W1
007746  780001     MOV W1, W0
007748  B7EC9F     MOV.B WREG, 0xC9F
1666:                                  acl_buf[4] = 0x08;
00774A  B3C080     MOV.B #0x8, W0
00774C  B7ECA0     MOV.B WREG, 0xCA0
1667:                                  acl_buf[5] = 0x00;
00774E  780001     MOV W1, W0
007750  B7ECA1     MOV.B WREG, 0xCA1
1668:                                  acl_buf[6] = 0x01;
007752  B3C010     MOV.B #0x1, W0
007754  B7ECA2     MOV.B WREG, 0xCA2
1669:                                  acl_buf[7] = 0x00;
007756  780001     MOV W1, W0
007758  B7ECA3     MOV.B WREG, 0xCA3
1670:                                  acl_buf[8] = 0x07;
00775A  B3C070     MOV.B #0x7, W0
00775C  B7ECA4     MOV.B WREG, 0xCA4
1671:                                  acl_buf[9] = packet_id;
00775E  BFCD52     MOV.B packet_id, WREG
007760  B7ECA5     MOV.B WREG, 0xCA5
1672:                                  acl_buf[10] = 0x04;
007762  B3C040     MOV.B #0x4, W0
007764  B7ECA6     MOV.B WREG, 0xCA6
1673:                                  acl_buf[11] = 0x00;
007766  780001     MOV W1, W0
007768  B7ECA7     MOV.B WREG, 0xCA7
1674:                                  acl_buf[12] = cid_host_ctrl[0];
00776A  B3C700     MOV.B #0x70, W0
00776C  B7ECA8     MOV.B WREG, 0xCA8
1675:                                  acl_buf[13] = cid_host_ctrl[1];
00776E  780001     MOV W1, W0
007770  B7ECA9     MOV.B WREG, 0xCA9
1676:                                  acl_buf[14] = cid_dev_ctrl[0];
007772  BFCD4C     MOV.B cid_dev_ctrl, WREG
007774  B7ECAA     MOV.B WREG, 0xCAA
1677:                                  acl_buf[15] = cid_dev_ctrl[1];
007776  BFCD4D     MOV.B 0xD4D, WREG
007778  B7ECAB     MOV.B WREG, 0xCAB
1678:                                  strcpy(message, "L2CAP_DISCONNECT_CTRL_RESP: ");
00777A  20D531     MOV #0xD53, W1
00777C  29ACB2     MOV #0x9ACB, W2
00777E  09001C     REPEAT #0x1C
007780  7858B2     MOV.B [W2++], [W1++]
1679:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
007782  200102     MOV #0x10, W2
007784  20C9C1     MOV #0xC9C, W1
007786  20D530     MOV #0xD53, W0
007788  07FB09     RCALL Write_ACL_Command
00778A  E00400     CP0.B W0
00778C  3A0096     BRA NZ, 0x78BA
1680:                                      HciState = PS4_BT_RUNNING;
00778E  2001A0     MOV #0x1A, W0
007790  886440     MOV W0, HciState
007792  370093     BRA 0x78BA
1681:                                  }
1682:                                  break;
1683:              
1684:                              case L2CAP_DISCONNECT_DATA:
1685:                                  acl_buf[0] = handle[0];
007794  BFCD4A     MOV.B handle, WREG
007796  B7EC9C     MOV.B WREG, acl_buf
1686:                                  acl_buf[1] = handle[1] + 0x20;
007798  BFCD4B     MOV.B 0xD4B, WREG
00779A  B04200     ADD.B #0x20, W0
00779C  B7EC9D     MOV.B WREG, 0xC9D
1687:                                  acl_buf[2] = 0x0c;
00779E  B3C0C0     MOV.B #0xC, W0
0077A0  B7EC9E     MOV.B WREG, 0xC9E
1688:                                  acl_buf[3] = 0x00;
0077A2  EB4080     CLR.B W1
0077A4  780001     MOV W1, W0
0077A6  B7EC9F     MOV.B WREG, 0xC9F
1689:                                  acl_buf[4] = 0x08;
0077A8  B3C080     MOV.B #0x8, W0
0077AA  B7ECA0     MOV.B WREG, 0xCA0
1690:                                  acl_buf[5] = 0x00;
0077AC  780001     MOV W1, W0
0077AE  B7ECA1     MOV.B WREG, 0xCA1
1691:                                  acl_buf[6] = 0x01;
0077B0  B3C010     MOV.B #0x1, W0
0077B2  B7ECA2     MOV.B WREG, 0xCA2
1692:                                  acl_buf[7] = 0x00;
0077B4  780001     MOV W1, W0
0077B6  B7ECA3     MOV.B WREG, 0xCA3
1693:                                  acl_buf[8] = 0x06; //disconnect command
0077B8  B3C060     MOV.B #0x6, W0
0077BA  B7ECA4     MOV.B WREG, 0xCA4
1694:                                  acl_buf[9] = packet_id;
0077BC  BFCD52     MOV.B packet_id, WREG
0077BE  B7ECA5     MOV.B WREG, 0xCA5
1695:                                  acl_buf[10] = 0x04;
0077C0  B3C040     MOV.B #0x4, W0
0077C2  B7ECA6     MOV.B WREG, 0xCA6
1696:                                  acl_buf[11] = 0x00;
0077C4  780001     MOV W1, W0
0077C6  B7ECA7     MOV.B WREG, 0xCA7
1697:                                  acl_buf[12] = cid_dev_data[0];
0077C8  BFCD4E     MOV.B cid_dev_data, WREG
0077CA  B7ECA8     MOV.B WREG, 0xCA8
1698:                                  acl_buf[13] = cid_dev_data[1];
0077CC  BFCD4F     MOV.B 0xD4F, WREG
0077CE  B7ECA9     MOV.B WREG, 0xCA9
1699:                                  acl_buf[14] = cid_host_data[0];
0077D0  B3C710     MOV.B #0x71, W0
0077D2  B7ECAA     MOV.B WREG, 0xCAA
1700:                                  acl_buf[15] = cid_host_data[1];
0077D4  780001     MOV W1, W0
0077D6  B7ECAB     MOV.B WREG, 0xCAB
1701:                                  strcpy(message, "L2CAP_DISCONNECT_DATA: ");
0077D8  20D531     MOV #0xD53, W1
0077DA  29AE82     MOV #0x9AE8, W2
0077DC  090017     REPEAT #0x17
0077DE  7858B2     MOV.B [W2++], [W1++]
1702:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
0077E0  200102     MOV #0x10, W2
0077E2  20C9C1     MOV #0xC9C, W1
0077E4  20D530     MOV #0xD53, W0
0077E6  07FADA     RCALL Write_ACL_Command
0077E8  E00400     CP0.B W0
0077EA  3A0067     BRA NZ, 0x78BA
1703:                                      HciState = HCI_READ;
0077EC  200200     MOV #0x20, W0
0077EE  886440     MOV W0, HciState
1704:                                      DemoState = BT_STATE_READ_DATA;
0077F0  200020     MOV #0x2, W0
0077F2  886430     MOV W0, DemoState
0077F4  370062     BRA 0x78BA
1705:                                  }
1706:                                  break;
1707:              
1708:                              case L2CAP_DISCONNECT_CTRL:
1709:                                  acl_buf[0] = handle[0];
0077F6  BFCD4A     MOV.B handle, WREG
0077F8  B7EC9C     MOV.B WREG, acl_buf
1710:                                  acl_buf[1] = handle[1] + 0x20;
0077FA  BFCD4B     MOV.B 0xD4B, WREG
0077FC  B04200     ADD.B #0x20, W0
0077FE  B7EC9D     MOV.B WREG, 0xC9D
1711:                                  acl_buf[2] = 0x0c;
007800  B3C0C0     MOV.B #0xC, W0
007802  B7EC9E     MOV.B WREG, 0xC9E
1712:                                  acl_buf[3] = 0x00;
007804  EB4080     CLR.B W1
007806  780001     MOV W1, W0
007808  B7EC9F     MOV.B WREG, 0xC9F
1713:                                  acl_buf[4] = 0x08;
00780A  B3C080     MOV.B #0x8, W0
00780C  B7ECA0     MOV.B WREG, 0xCA0
1714:                                  acl_buf[5] = 0x00;
00780E  780001     MOV W1, W0
007810  B7ECA1     MOV.B WREG, 0xCA1
1715:                                  acl_buf[6] = 0x01;
007812  B3C010     MOV.B #0x1, W0
007814  B7ECA2     MOV.B WREG, 0xCA2
1716:                                  acl_buf[7] = 0x00;
007816  780001     MOV W1, W0
007818  B7ECA3     MOV.B WREG, 0xCA3
1717:                                  acl_buf[8] = 0x06; //disconnect command
00781A  B3C060     MOV.B #0x6, W0
00781C  B7ECA4     MOV.B WREG, 0xCA4
1718:                                  acl_buf[9] = packet_id;
00781E  BFCD52     MOV.B packet_id, WREG
007820  B7ECA5     MOV.B WREG, 0xCA5
1719:                                  acl_buf[10] = 0x04;
007822  B3C040     MOV.B #0x4, W0
007824  B7ECA6     MOV.B WREG, 0xCA6
1720:                                  acl_buf[11] = 0x00;
007826  780001     MOV W1, W0
007828  B7ECA7     MOV.B WREG, 0xCA7
1721:                                  acl_buf[12] = cid_dev_ctrl[0];
00782A  BFCD4C     MOV.B cid_dev_ctrl, WREG
00782C  B7ECA8     MOV.B WREG, 0xCA8
1722:                                  acl_buf[13] = cid_dev_ctrl[1];
00782E  BFCD4D     MOV.B 0xD4D, WREG
007830  B7ECA9     MOV.B WREG, 0xCA9
1723:                                  acl_buf[14] = cid_host_ctrl[0];
007832  B3C700     MOV.B #0x70, W0
007834  B7ECAA     MOV.B WREG, 0xCAA
1724:                                  acl_buf[15] = cid_host_ctrl[1];
007836  780001     MOV W1, W0
007838  B7ECAB     MOV.B WREG, 0xCAB
1725:                                  strcpy(message, "L2CAP_DISCONNECT_DATA: ");
00783A  20D531     MOV #0xD53, W1
00783C  29AE82     MOV #0x9AE8, W2
00783E  090017     REPEAT #0x17
007840  7858B2     MOV.B [W2++], [W1++]
1726:                                  if (Write_ACL_Command(message, acl_buf, 16) == USB_SUCCESS) {
007842  200102     MOV #0x10, W2
007844  20C9C1     MOV #0xC9C, W1
007846  20D530     MOV #0xD53, W0
007848  07FAA9     RCALL Write_ACL_Command
00784A  E00400     CP0.B W0
00784C  3A0036     BRA NZ, 0x78BA
1727:                                      HciState = HCI_READ;
00784E  200200     MOV #0x20, W0
007850  886440     MOV W0, HciState
1728:                                      DemoState = BT_STATE_READ_DATA;
007852  200020     MOV #0x2, W0
007854  886430     MOV W0, DemoState
007856  370031     BRA 0x78BA
1729:                                  }
1730:                                  break;
1731:              
1732:                              case HCI_DISCONNECT:
1733:                                  hci_buf[0] = 0x06;
007858  B3C060     MOV.B #0x6, W0
00785A  B7ECF3     MOV.B WREG, hci_buf
1734:                                  hci_buf[1] = 0x01 << 2;
00785C  B3C040     MOV.B #0x4, W0
00785E  B7ECF4     MOV.B WREG, 0xCF4
1735:                                  hci_buf[2] = 0x03;
007860  B3C030     MOV.B #0x3, W0
007862  B7ECF5     MOV.B WREG, 0xCF5
1736:                                  hci_buf[3] = handle[0];
007864  BFCD4A     MOV.B handle, WREG
007866  B7ECF6     MOV.B WREG, 0xCF6
1737:                                  hci_buf[4] = handle[1];
007868  BFCD4B     MOV.B 0xD4B, WREG
00786A  B7ECF7     MOV.B WREG, 0xCF7
1738:                                  hci_buf[5] = 0x13; //user terminated connection
00786C  B3C130     MOV.B #0x13, W0
00786E  B7ECF8     MOV.B WREG, 0xCF8
1739:              
1740:                                  strcpy(message, "HCI_DISCONNECT: ");
007870  20D531     MOV #0xD53, W1
007872  29B002     MOV #0x9B00, W2
007874  090010     REPEAT #0x10
007876  7858B2     MOV.B [W2++], [W1++]
1741:                                  if (Write_HCI_Command(message, hci_buf, 6) == USB_SUCCESS) {
007878  200062     MOV #0x6, W2
00787A  20CF31     MOV #0xCF3, W1
00787C  20D530     MOV #0xD53, W0
00787E  07FA7F     RCALL Write_HCI_Command
007880  E00400     CP0.B W0
007882  3A001B     BRA NZ, 0x78BA
1742:                                      ResetStates();
007884  07F764     RCALL ResetStates
007886  370019     BRA 0x78BA
1743:                                  }
1744:                                  break;
1745:              
1746:                              case HCI_READ:
1747:                                  USBHostGenericAclRead(deviceAddress, acl_buf, DATA_PACKET_LENGTH);
007888  BFCC84     MOV.B deviceAddress, WREG
00788A  200572     MOV #0x57, W2
00788C  200003     MOV #0x0, W3
00788E  20C9C1     MOV #0xC9C, W1
007890  070E9A     RCALL USBHostGenericAclRead
1748:                                  USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
007892  BFCC84     MOV.B deviceAddress, WREG
007894  200572     MOV #0x57, W2
007896  200003     MOV #0x0, W3
007898  20CF31     MOV #0xCF3, W1
00789A  070E03     RCALL USBHostGenericRead
00789C  37000E     BRA 0x78BA
1749:                                  break;
1750:                          }
1751:                          break;
1752:              
1753:                      case BT_STATE_READ_DATA:
1754:                          USBHostGenericAclRead(deviceAddress, acl_buf, DATA_PACKET_LENGTH);
00789E  BFCC84     MOV.B deviceAddress, WREG
0078A0  200572     MOV #0x57, W2
0078A2  200003     MOV #0x0, W3
0078A4  20C9C1     MOV #0xC9C, W1
0078A6  070E8F     RCALL USBHostGenericAclRead
1755:                          USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
0078A8  BFCC84     MOV.B deviceAddress, WREG
0078AA  200572     MOV #0x57, W2
0078AC  200003     MOV #0x0, W3
0078AE  20CF31     MOV #0xCF3, W1
0078B0  070DF8     RCALL USBHostGenericRead
0078B2  370003     BRA 0x78BA
1756:                          break;
1757:              
1758:                      default:
1759:                          UART2PrintString("Unknown Demo State.\n\r");
0078B4  29B110     MOV #0x9B11, W0
0078B6  070EE3     RCALL UART2PrintString
1760:                          ResetStates();
0078B8  07F74A     RCALL ResetStates
1761:                          break;
1762:                  }
1763:                  //DelayMs(1); // 1ms delay.  Not sure why we need this, but seems to prevent certain errors.
1764:              
1765:              } // ManageStateBluetooth
0078BA  78044F     MOV [--W15], W8
0078BC  060000     RETURN
1766:              
1767:              void ManageStateWire(void) {
0078BE  FA0006     LNK #0x6
0078C0  781F88     MOV W8, [W15++]
1768:                  unsigned long bytes;
1769:                  BYTE errorCode;
1770:                  BYTE usbReturnVal;
1771:                  if (USBHostGenericDeviceDetached(deviceAddress) && deviceAddress != 0) {
0078C2  BFCC84     MOV.B deviceAddress, WREG
0078C4  E34EAE     CP.B 0xEAE
0078C6  3A0002     BRA NZ, 0x78CC
0078C8  AB0EB9     BTST 0xEB9, #0
0078CA  3A0005     BRA NZ, 0x78D6
0078CC  E00400     CP0.B W0
0078CE  320003     BRA Z, 0x78D6
1772:              #ifdef DEBUG_MODE
1773:                      UART2PrintString("Controller detached - polled\r\n");
1774:              #endif
1775:                      ResetStates();
0078D0  07F73E     RCALL ResetStates
1776:                      SetConnectedDeviceType(NONE);
0078D2  EB0000     CLR W0
0078D4  070EB3     RCALL SetConnectedDeviceType
1777:                  }
1778:                  switch (PS4WireState) {
0078D6  806450     MOV PS4WireState, W0
0078D8  500FE2     SUB W0, #0x2, [W15]
0078DA  3200AA     BRA Z, 0x7A30
0078DC  3E0005     BRA GTU, 0x78E8
0078DE  E00000     CP0 W0
0078E0  320009     BRA Z, 0x78F4
0078E2  500FE1     SUB W0, #0x1, [W15]
0078E4  3A0134     BRA NZ, 0x7B4E
0078E6  370032     BRA 0x794C
0078E8  500FE4     SUB W0, #0x4, [W15]
0078EA  3200FC     BRA Z, 0x7AE4
0078EC  3900CF     BRA NC, 0x7A8C
0078EE  500FE5     SUB W0, #0x5, [W15]
0078F0  3A012E     BRA NZ, 0x7B4E
0078F2  370120     BRA 0x7B34
1779:                      case PS4_WIRE_READ_BD_ADDR1:
1780:                          UART2PrintString("Read Back ADDR.\n\r");
0078F4  29B270     MOV #0x9B27, W0
0078F6  070EC3     RCALL UART2PrintString
1781:                          if (USB_SUCCESS == USBHostIssueDeviceRequest(deviceAddress, 0xA1, 0x01, 0x0312, 0, 16, hci_buf, USB_DEVICE_REQUEST_GET, 0)) {
0078F8  BFCC84     MOV.B deviceAddress, WREG
0078FA  E8878F     INC2 W15, W15
0078FC  EB4080     CLR.B W1
0078FE  9FFFE1     MOV.B W1, [W15-2]
007900  B3C017     MOV.B #0x1, W7
007902  20CF36     MOV #0xCF3, W6
007904  200105     MOV #0x10, W5
007906  EB0200     CLR W4
007908  203123     MOV #0x312, W3
00790A  784107     MOV.B W7, W2
00790C  B3CA11     MOV.B #0xA1, W1
00790E  07D7C5     RCALL USBHostIssueDeviceRequest
007910  E9878F     DEC2 W15, W15
007912  E00400     CP0.B W0
007914  320003     BRA Z, 0x791C
007916  37011B     BRA 0x7B4E
1782:                              while (!USBHostTransferIsComplete(deviceAddress, 0, &errorCode, &bytes)) {
00791C  BFCC84     MOV.B deviceAddress, WREG
00791E  5781E8     SUB W15, #0x8, W3
007920  578164     SUB W15, #0x4, W2
007922  EB4080     CLR.B W1
007924  07DD41     RCALL USBHostTransferIsComplete
007926  E00000     CP0 W0
007928  32FFF7     BRA Z, 0x7918
1783:                                  UART2PrintString("Waiting for read to complete...");
007918  29B390     MOV #0x9B39, W0
00791A  070EB1     RCALL UART2PrintString
1784:                              }
1785:                              PS4WireState = PS4_WIRE_WRITE_BD_ADDR;
00792A  200010     MOV #0x1, W0
00792C  886450     MOV W0, PS4WireState
1786:                              for (data_num = 0; data_num < 16; data_num++) {
00792E  EB0000     CLR W0
007930  886470     MOV W0, data_num
007932  20CF38     MOV #0xCF3, W8
00793E  EC0C8E     INC data_num, WREG
007940  886470     MOV W0, data_num
007942  500FEF     SUB W0, #0xF, [W15]
007944  34FFF7     BRA LE, 0x7934
1787:                                  UART2PutHex(hci_buf[data_num]);
007934  7C4060     MOV.B [W0+W8], W0
007936  FB8000     ZE W0, W0
007938  070F6E     RCALL UART2PutHex
1788:                                  UART2PutChar(' ');
00793A  B3C200     MOV.B #0x20, W0
00793C  070EAD     RCALL UART2PutChar
1789:                              }
1790:                              UART2PrintString("\n\r");
007946  2947C0     MOV #0x947C, W0
007948  070E9A     RCALL UART2PrintString
00794A  370101     BRA 0x7B4E
1791:                          }
1792:                          break;
1793:                      case PS4_WIRE_WRITE_BD_ADDR:
1794:                          UART2PrintString("Pair Controller with last Bluetooth dongle...\n\r");
00794C  29B590     MOV #0x9B59, W0
00794E  070E97     RCALL UART2PrintString
1795:                          localBdAddr.ints[0] = DataEERead(EEPROM_BT_ADDR_0);
007950  EB0000     CLR W0
007952  070BD4     RCALL DataEERead
007954  B7EC90     MOV.B WREG, localBdAddr
007956  DE0048     LSR W0, #8, W0
007958  B7EC91     MOV.B WREG, 0xC91
1796:                          localBdAddr.ints[1] = DataEERead(EEPROM_BT_ADDR_1);
00795A  200010     MOV #0x1, W0
00795C  070BCF     RCALL DataEERead
00795E  B7EC92     MOV.B WREG, 0xC92
007960  DE0048     LSR W0, #8, W0
007962  B7EC93     MOV.B WREG, 0xC93
1797:                          localBdAddr.ints[2] = DataEERead(EEPROM_BT_ADDR_2);
007964  200020     MOV #0x2, W0
007966  070BCA     RCALL DataEERead
007968  FB8100     ZE W0, W2
00796A  FD0100     EXCH W0, W2
00796C  B7EC94     MOV.B WREG, 0xC94
00796E  FD0100     EXCH W0, W2
007970  DE01C8     LSR W0, #8, W3
007972  780003     MOV W3, W0
007974  B7EC95     MOV.B WREG, 0xC95
1798:              
1799:                          hci_buf[0] = 0x13;
007976  B3C131     MOV.B #0x13, W1
007978  780001     MOV W1, W0
00797A  B7ECF3     MOV.B WREG, hci_buf
1800:                          hci_buf[1] = localBdAddr.bytes[0];
00797C  BFCC90     MOV.B localBdAddr, WREG
00797E  B7ECF4     MOV.B WREG, 0xCF4
1801:                          hci_buf[2] = localBdAddr.bytes[1];
007980  BFCC91     MOV.B 0xC91, WREG
007982  B7ECF5     MOV.B WREG, 0xCF5
1802:                          hci_buf[3] = localBdAddr.bytes[2];
007984  BFCC92     MOV.B 0xC92, WREG
007986  B7ECF6     MOV.B WREG, 0xCF6
1803:                          hci_buf[4] = localBdAddr.bytes[3];
007988  BFCC93     MOV.B 0xC93, WREG
00798A  B7ECF7     MOV.B WREG, 0xCF7
1804:                          hci_buf[5] = localBdAddr.bytes[4];
00798C  780002     MOV W2, W0
00798E  B7ECF8     MOV.B WREG, 0xCF8
1805:                          hci_buf[6] = localBdAddr.bytes[5];
007990  780003     MOV W3, W0
007992  B7ECF9     MOV.B WREG, 0xCF9
1806:                          hci_buf[7] = 0x56;
007994  B3C560     MOV.B #0x56, W0
007996  B7ECFA     MOV.B WREG, 0xCFA
1807:                          hci_buf[8] = 0xE8;
007998  B3CE80     MOV.B #0xE8, W0
00799A  B7ECFB     MOV.B WREG, 0xCFB
1808:                          hci_buf[9] = 0x81;
00799C  B3C810     MOV.B #0x81, W0
00799E  B7ECFC     MOV.B WREG, 0xCFC
1809:                          hci_buf[10] = 0x38;
0079A0  B3C380     MOV.B #0x38, W0
0079A2  B7ECFD     MOV.B WREG, 0xCFD
1810:                          hci_buf[11] = 0x08;
0079A4  B3C080     MOV.B #0x8, W0
0079A6  B7ECFE     MOV.B WREG, 0xCFE
1811:                          hci_buf[12] = 0x06;
0079A8  B3C060     MOV.B #0x6, W0
0079AA  B7ECFF     MOV.B WREG, 0xCFF
1812:                          hci_buf[13] = 0x51;
0079AC  B3C510     MOV.B #0x51, W0
0079AE  B7ED00     MOV.B WREG, 0xD00
1813:                          hci_buf[14] = 0x41;
0079B0  504070     SUB.B W0, #0x10, W0
0079B2  B7ED01     MOV.B WREG, 0xD01
1814:                          hci_buf[15] = 0xC0;
0079B4  B3CC00     MOV.B #0xC0, W0
0079B6  B7ED02     MOV.B WREG, 0xD02
1815:                          hci_buf[16] = 0x7F;
0079B8  B3C7F0     MOV.B #0x7F, W0
0079BA  B7ED03     MOV.B WREG, 0xD03
1816:                          hci_buf[17] = 0x12;
0079BC  B3C120     MOV.B #0x12, W0
0079BE  B7ED04     MOV.B WREG, 0xD04
1817:                          hci_buf[18] = 0xAA;
0079C0  B3CAA0     MOV.B #0xAA, W0
0079C2  B7ED05     MOV.B WREG, 0xD05
1818:                          hci_buf[19] = 0xD9;
0079C4  B3CD90     MOV.B #0xD9, W0
0079C6  B7ED06     MOV.B WREG, 0xD06
1819:                          hci_buf[20] = 0x66;
0079C8  B3C660     MOV.B #0x66, W0
0079CA  B7ED07     MOV.B WREG, 0xD07
1820:                          hci_buf[21] = 0x3C;
0079CC  B3C3C0     MOV.B #0x3C, W0
0079CE  B7ED08     MOV.B WREG, 0xD08
1821:                          hci_buf[22] = 0xCE;
0079D0  B3CCE0     MOV.B #0xCE, W0
0079D2  B7ED09     MOV.B WREG, 0xD09
1822:              
1823:                          if (USB_SUCCESS == USBHostIssueDeviceRequest(deviceAddress, 0x21, 0x09, 0x0313, 0, 23, hci_buf, USB_DEVICE_REQUEST_SET, 0)) {
0079D4  BFCC84     MOV.B deviceAddress, WREG
0079D6  E8878F     INC2 W15, W15
0079D8  EB4380     CLR.B W7
0079DA  9FFFE7     MOV.B W7, [W15-2]
0079DC  20CF36     MOV #0xCF3, W6
0079DE  200175     MOV #0x17, W5
0079E0  EB0200     CLR W4
0079E2  203133     MOV #0x313, W3
0079E4  B3C092     MOV.B #0x9, W2
0079E6  40C0EE     ADD.B W1, #0xE, W1
0079E8  07D758     RCALL USBHostIssueDeviceRequest
0079EA  E9878F     DEC2 W15, W15
0079EC  E00400     CP0.B W0
0079EE  320003     BRA Z, 0x79F6
0079F0  37000E     BRA 0x7A0E
1824:                              while (!USBHostTransferIsComplete(deviceAddress, 0, &errorCode, &bytes)) {
0079F6  BFCC84     MOV.B deviceAddress, WREG
0079F8  5781E8     SUB W15, #0x8, W3
0079FA  578164     SUB W15, #0x4, W2
0079FC  EB4080     CLR.B W1
0079FE  07DCD4     RCALL USBHostTransferIsComplete
007A00  E00000     CP0 W0
007A02  32FFF7     BRA Z, 0x79F2
1825:                                  UART2PrintString("Waiting for write to complete...");
0079F2  29B890     MOV #0x9B89, W0
0079F4  070E44     RCALL UART2PrintString
1826:                              }
1827:                              UART2PrintString("Done. ");
007A04  29BAA0     MOV #0x9BAA, W0
007A06  070E3B     RCALL UART2PrintString
1828:                              PS4WireState = SET_0x14;
007A08  200020     MOV #0x2, W0
007A0A  886450     MOV W0, PS4WireState
007A0C  370002     BRA 0x7A12
1829:                          } else {
1830:                              UART2PrintString("Device Write Error !\r\n");
007A0E  29BB10     MOV #0x9BB1, W0
007A10  070E36     RCALL UART2PrintString
1831:                          }
1832:                          for (data_num = 0; data_num < 23; data_num++) {
007A12  EB0000     CLR W0
007A14  886470     MOV W0, data_num
007A16  20CF38     MOV #0xCF3, W8
007A22  EC0C8E     INC data_num, WREG
007A24  886470     MOV W0, data_num
007A26  500FF6     SUB W0, #0x16, [W15]
007A28  34FFF7     BRA LE, 0x7A18
1833:                              UART2PutHex(hci_buf[data_num]);
007A18  7C4060     MOV.B [W0+W8], W0
007A1A  FB8000     ZE W0, W0
007A1C  070EFC     RCALL UART2PutHex
1834:                              UART2PutChar(' ');
007A1E  B3C200     MOV.B #0x20, W0
007A20  070E3B     RCALL UART2PutChar
1835:                          }
1836:                          UART2PrintString("\n\r");
007A2A  2947C0     MOV #0x947C, W0
007A2C  070E28     RCALL UART2PrintString
007A2E  37008F     BRA 0x7B4E
1837:                          break;
1838:              
1839:                      case SET_0x14:
1840:                          UART2PrintString("Set Report 0x14:");
007A30  29BC80     MOV #0x9BC8, W0
007A32  070E25     RCALL UART2PrintString
1841:                          hci_buf[0] = 0x14;
007A34  B3C140     MOV.B #0x14, W0
007A36  B7ECF3     MOV.B WREG, hci_buf
1842:                          hci_buf[1] = 0x02;
007A38  B3C020     MOV.B #0x2, W0
007A3A  B7ECF4     MOV.B WREG, 0xCF4
1843:                          hci_buf[2] = 0;
007A3C  EB4380     CLR.B W7
007A3E  FD0380     EXCH W0, W7
007A40  B7ECF5     MOV.B WREG, 0xCF5
007A42  B7ECF6     MOV.B WREG, 0xCF6
007A44  B7ECF7     MOV.B WREG, 0xCF7
007A46  B7ECF8     MOV.B WREG, 0xCF8
007A48  B7ECF9     MOV.B WREG, 0xCF9
007A4A  FD0380     EXCH W0, W7
1844:                          hci_buf[3] = 0;
1845:                          hci_buf[4] = 0;
1846:                          hci_buf[5] = 0;
1847:                          hci_buf[6] = 0;
1848:                          hci_buf[7] = 0;
007A4C  FD0380     EXCH W0, W7
007A4E  B7ECFA     MOV.B WREG, 0xCFA
007A50  B7ECFB     MOV.B WREG, 0xCFB
007A52  B7ECFC     MOV.B WREG, 0xCFC
007A54  B7ECFD     MOV.B WREG, 0xCFD
007A56  B7ECFE     MOV.B WREG, 0xCFE
007A58  FD0380     EXCH W0, W7
1849:                          hci_buf[8] = 0;
1850:                          hci_buf[9] = 0;
1851:                          hci_buf[10] = 0;
1852:                          hci_buf[11] = 0;
1853:                          hci_buf[12] = 0;
007A5A  FD0380     EXCH W0, W7
007A5C  B7ECFF     MOV.B WREG, 0xCFF
007A5E  B7ED00     MOV.B WREG, 0xD00
007A60  B7ED01     MOV.B WREG, 0xD01
007A62  B7ED02     MOV.B WREG, 0xD02
007A64  B7ED03     MOV.B WREG, 0xD03
007A66  FD0380     EXCH W0, W7
1854:                          hci_buf[13] = 0;
1855:                          hci_buf[14] = 0;
1856:                          hci_buf[15] = 0;
1857:                          hci_buf[16] = 0;
1858:                          if (USB_SUCCESS == USBHostIssueDeviceRequest(deviceAddress, 0x21, 0x09, 0x0314, 0, 17, hci_buf, USB_DEVICE_REQUEST_SET, 0)) {
007A68  BFCC84     MOV.B deviceAddress, WREG
007A6A  E8878F     INC2 W15, W15
007A6C  9FFFE7     MOV.B W7, [W15-2]
007A6E  20CF36     MOV #0xCF3, W6
007A70  200115     MOV #0x11, W5
007A72  EB0200     CLR W4
007A74  203143     MOV #0x314, W3
007A76  B3C092     MOV.B #0x9, W2
007A78  B3C211     MOV.B #0x21, W1
007A7A  07D70F     RCALL USBHostIssueDeviceRequest
007A7C  E9878F     DEC2 W15, W15
007A7E  E00400     CP0.B W0
007A80  3A0066     BRA NZ, 0x7B4E
1859:                              PS4WireState = PS4_WIRE_READ_BD_ADDR2;
007A82  200030     MOV #0x3, W0
007A84  886450     MOV W0, PS4WireState
1860:                              UART2PrintString("Success.\n\r");
007A86  29BD90     MOV #0x9BD9, W0
007A88  070DFA     RCALL UART2PrintString
007A8A  370061     BRA 0x7B4E
1861:                          }
1862:              
1863:                          break;
1864:              
1865:                      case PS4_WIRE_READ_BD_ADDR2:
1866:                          UART2PrintString("Read Back ADDR.\n\r");
007A8C  29B270     MOV #0x9B27, W0
007A8E  070DF7     RCALL UART2PrintString
1867:                          if (USB_SUCCESS == USBHostIssueDeviceRequest(deviceAddress, 0xA1, 0x01, 0x0312, 0, 16, hci_buf, USB_DEVICE_REQUEST_GET, 0)) {
007A90  BFCC84     MOV.B deviceAddress, WREG
007A92  E8878F     INC2 W15, W15
007A94  EB4080     CLR.B W1
007A96  9FFFE1     MOV.B W1, [W15-2]
007A98  B3C017     MOV.B #0x1, W7
007A9A  20CF36     MOV #0xCF3, W6
007A9C  200105     MOV #0x10, W5
007A9E  EB0200     CLR W4
007AA0  203123     MOV #0x312, W3
007AA2  784107     MOV.B W7, W2
007AA4  B3CA11     MOV.B #0xA1, W1
007AA6  07D6F9     RCALL USBHostIssueDeviceRequest
007AA8  E9878F     DEC2 W15, W15
007AAA  E00400     CP0.B W0
007AAC  320003     BRA Z, 0x7AB4
007AAE  37004F     BRA 0x7B4E
1868:                              while (!USBHostTransferIsComplete(deviceAddress, 0, &errorCode, &bytes)) {
007AB4  BFCC84     MOV.B deviceAddress, WREG
007AB6  5781E8     SUB W15, #0x8, W3
007AB8  578164     SUB W15, #0x4, W2
007ABA  EB4080     CLR.B W1
007ABC  07DC75     RCALL USBHostTransferIsComplete
007ABE  E00000     CP0 W0
007AC0  32FFF7     BRA Z, 0x7AB0
1869:                                  UART2PrintString("Waiting for read to complete...");
007AB0  29B390     MOV #0x9B39, W0
007AB2  070DE5     RCALL UART2PrintString
1870:                              }
1871:                              PS4WireState = PS4_WIRE_CONTROLLER_INIT;
007AC2  200040     MOV #0x4, W0
007AC4  886450     MOV W0, PS4WireState
1872:                              for (data_num = 0; data_num < 16; data_num++) {
007AC6  EB0000     CLR W0
007AC8  886470     MOV W0, data_num
007ACA  20CF38     MOV #0xCF3, W8
007AD6  EC0C8E     INC data_num, WREG
007AD8  886470     MOV W0, data_num
007ADA  500FEF     SUB W0, #0xF, [W15]
007ADC  34FFF7     BRA LE, 0x7ACC
1873:                                  UART2PutHex(hci_buf[data_num]);
007ACC  7C4060     MOV.B [W0+W8], W0
007ACE  FB8000     ZE W0, W0
007AD0  070EA2     RCALL UART2PutHex
1874:                                  UART2PutChar(' ');
007AD2  B3C200     MOV.B #0x20, W0
007AD4  070DE1     RCALL UART2PutChar
1875:                              }
1876:                              UART2PrintString("\n\r");
007ADE  2947C0     MOV #0x947C, W0
007AE0  070DCE     RCALL UART2PrintString
007AE2  370035     BRA 0x7B4E
1877:                          }
1878:                          break;
1879:              
1880:                      case PS4_WIRE_CONTROLLER_INIT:
1881:                          GetOutputReportWire()[0] = 0x05; // Report ID
007AE4  07081C     RCALL GetOutputReportWire
007AE6  B3C051     MOV.B #0x5, W1
007AE8  784801     MOV.B W1, [W0]
1882:                          GetOutputReportWire()[1] = 0xFF;
007AEA  070819     RCALL GetOutputReportWire
007AEC  EBC080     SETM.B W1
007AEE  984011     MOV.B W1, [W0+1]
1883:                          GetOutputReportWire()[2] = 0x00;
007AF0  070816     RCALL GetOutputReportWire
007AF2  EB4400     CLR.B W8
007AF4  984028     MOV.B W8, [W0+2]
1884:                          GetOutputReportWire()[3] = 0x00;
007AF6  070813     RCALL GetOutputReportWire
007AF8  984038     MOV.B W8, [W0+3]
1885:              
1886:                          SetLEDColor(WHITE, GetLEDBrightness(), 0, 0);
007AFA  07F5C6     RCALL GetLEDBrightness
007AFC  784188     MOV.B W8, W3
007AFE  784108     MOV.B W8, W2
007B00  784080     MOV.B W0, W1
007B02  200090     MOV #0x9, W0
007B04  070810     RCALL SetLEDColor
1887:                          SetRumbleL(0);
007B06  784008     MOV.B W8, W0
007B08  0708A8     RCALL SetRumbleL
1888:                          SetRumbleH(0);
007B0A  784008     MOV.B W8, W0
007B0C  07089F     RCALL SetRumbleH
1889:              
1890:                          usbReturnVal = USBHostGenericWrite(deviceAddress, GetOutputReportWire(), 32);
007B0E  070807     RCALL GetOutputReportWire
007B10  780080     MOV W0, W1
007B12  BFCC84     MOV.B deviceAddress, WREG
007B14  200202     MOV #0x20, W2
007B16  200003     MOV #0x0, W3
007B18  070CE9     RCALL USBHostGenericWrite
007B1A  784400     MOV.B W0, W8
1891:                          UART2PrintString("Initialize Controller.\n\r");
007B1C  29BE40     MOV #0x9BE4, W0
007B1E  070DAF     RCALL UART2PrintString
1892:                          if (USB_SUCCESS == usbReturnVal) {
007B20  E00408     CP0.B W8
007B22  3A0003     BRA NZ, 0x7B2A
1893:                              PS4WireState = PS4_WIRE_RUNNING;
007B24  200050     MOV #0x5, W0
007B26  886450     MOV W0, PS4WireState
007B28  370012     BRA 0x7B4E
1894:                          } else {
1895:                              UART2PutHex(usbReturnVal);
007B2A  FB8008     ZE W8, W0
007B2C  070E74     RCALL UART2PutHex
1896:                              UART2PrintString("Device Write Error !\r\n");
007B2E  29BB10     MOV #0x9BB1, W0
007B30  070DA6     RCALL UART2PrintString
007B32  37000D     BRA 0x7B4E
1897:                          }
1898:                          break;
1899:              
1900:                      case PS4_WIRE_RUNNING:
1901:                          usbReturnVal = USBHostGenericRead(deviceAddress, hci_buf, DATA_PACKET_LENGTH);
007B34  BFCC84     MOV.B deviceAddress, WREG
007B36  200572     MOV #0x57, W2
007B38  200003     MOV #0x0, W3
007B3A  20CF31     MOV #0xCF3, W1
007B3C  070CB2     RCALL USBHostGenericRead
1902:                          //UART2PrintString("Running\n\r");
1903:                          if (usbReturnVal != USB_SUCCESS && usbReturnVal != USB_BUSY) {
007B3E  E00400     CP0.B W0
007B40  320006     BRA Z, 0x7B4E
007B42  504FE2     SUB.B W0, #0x2, [W15]
007B44  320004     BRA Z, 0x7B4E
1904:                              UART2PutHex(usbReturnVal);
007B46  FB8000     ZE W0, W0
007B48  070E66     RCALL UART2PutHex
1905:                              UART2PrintString(" - Device Read Error !\r\n");
007B4A  29BFD0     MOV #0x9BFD, W0
007B4C  070D98     RCALL UART2PrintString
1906:                          }
1907:                          break;
1908:              
1909:                      default:
1910:                          break;
1911:                  }
1912:                  DelayMs(5); // 1ms delay, otherwise seems to get endpoint busy/usb busy errors.
007B4E  238800     MOV #0x3880, W0
007B50  200011     MOV #0x1, W1
007B52  07D220     RCALL ___delay32
1913:              } // ManageStateWire
007B54  78044F     MOV [--W15], W8
007B56  FA8000     ULNK
007B58  060000     RETURN
1914:              
1915:              void ManageStateSpaceNavigator(void){
1916:                  BYTE usbReturnVal;
1917:                  switch(SpaceNavState)
007B5A  806460     MOV SpaceNavState, W0
007B5C  E00000     CP0 W0
007B5E  320003     BRA Z, 0x7B66
007B60  500FE1     SUB W0, #0x1, [W15]
007B62  3A000C     BRA NZ, 0x7B7C
007B64  370006     BRA 0x7B72
1918:                  {
1919:                      case SPACE_NAV_INIT:
1920:                          GetPS4Report()[5] = 0; //have to clear this since the PS4 has bit 7 as 1 by default.
007B66  0707D7     RCALL GetPS4Report
007B68  EB4080     CLR.B W1
007B6A  984051     MOV.B W1, [W0+5]
1921:                          SpaceNavState = SPACE_NAV_RUNNING;
007B6C  200010     MOV #0x1, W0
007B6E  886460     MOV W0, SpaceNavState
007B70  370005     BRA 0x7B7C
1922:                          break;
1923:                      case SPACE_NAV_RUNNING:
1924:                          usbReturnVal = USBHostGenericRead(deviceAddress, hci_buf, 32);
007B72  BFCC84     MOV.B deviceAddress, WREG
007B74  200202     MOV #0x20, W2
007B76  200003     MOV #0x0, W3
007B78  20CF31     MOV #0xCF3, W1
007B7A  070C93     RCALL USBHostGenericRead
1925:                          break;
1926:                      default:
1927:                          break;
1928:                  }
1929:              }
007B7C  060000     RETURN
1930:              //******************************************************************************
1931:              //******************************************************************************
1932:              // USB Support Functions
1933:              //******************************************************************************
1934:              //******************************************************************************
1935:              
1936:              /*************************************************************************
1937:               * Function:        USB_ApplicationEventHandler
1938:               *S
1939:               * Preconditions:   The USB must be initialized.
1940:               *
1941:               * Input:           event       Identifies the bus event that occured
1942:               *
1943:               *                  data        Pointer to event-specific data
1944:               *
1945:               *                  size        Size of the event-specific data
1946:               *
1947:               * Output:          deviceAddress (global)
1948:               *                  Updates device address when an attach or detach occurs.
1949:               *
1950:               *                  DemoState (global)
1951:               *                  Updates the demo state as appropriate when events occur.
1952:               *
1953:               * Returns:         TRUE if the event was handled, FALSE if not
1954:               *
1955:               * Side Effects:    Event-specific actions have been taken.
1956:               *
1957:               * Overview:        This routine is called by the Host layer or client
1958:               *                  driver to notify the application of events that occur.
1959:               *                  If the event is recognized, it is handled and the
1960:               *                  routine returns TRUE.  Otherwise, it is ignored (or
1961:               *                  just "sniffed" and the routine returns FALSE.
1962:               *************************************************************************/
1963:              
1964:              BOOL USB_ApplicationEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
007B7E  781F88     MOV W8, [W15++]
1965:              #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
1966:                  BYTE i;
1967:              #endif
1968:              
1969:                  // Handle specific events.
1970:                  switch (event) {
007B80  200700     MOV #0x70, W0
007B82  508F80     SUB W1, W0, [W15]
007B84  320089     BRA Z, 0x7C98
007B86  3E0012     BRA GTU, 0x7BAC
007B88  500064     SUB W0, #0x4, W0
007B8A  508F80     SUB W1, W0, [W15]
007B8C  320075     BRA Z, 0x7C78
007B8E  3E0009     BRA GTU, 0x7BA2
007B90  500067     SUB W0, #0x7, W0
007B92  508F80     SUB W1, W0, [W15]
007B94  32006D     BRA Z, 0x7C70
007B96  390086     BRA NC, 0x7CA4
007B98  2FF970     MOV #0xFF97, W0
007B9A  408000     ADD W1, W0, W0
007B9C  500FE1     SUB W0, #0x1, [W15]
007B9E  3E0082     BRA GTU, 0x7CA4
007BA0  37007F     BRA 0x7CA0
007BA2  2006E0     MOV #0x6E, W0
007BA4  508F80     SUB W1, W0, [W15]
007BA6  320070     BRA Z, 0x7C88
007BA8  3E0073     BRA GTU, 0x7C90
007BAA  37006A     BRA 0x7C80
007BAC  201900     MOV #0x190, W0
007BAE  508F80     SUB W1, W0, [W15]
007BB0  320018     BRA Z, 0x7BE2
007BB2  3E0008     BRA GTU, 0x7BC4
007BB4  200710     MOV #0x71, W0
007BB6  508F80     SUB W1, W0, [W15]
007BB8  320073     BRA Z, 0x7CA0
007BBA  2FF8C0     MOV #0xFF8C, W0
007BBC  408000     ADD W1, W0, W0
007BBE  500FE1     SUB W0, #0x1, [W15]
007BC0  3E0071     BRA GTU, 0x7CA4
007BC2  37006E     BRA 0x7CA0
007BC4  201930     MOV #0x193, W0
007BC6  508F80     SUB W1, W0, [W15]
007BC8  320027     BRA Z, 0x7C18
007BCA  3E0004     BRA GTU, 0x7BD4
007BCC  E98000     DEC2 W0, W0
007BCE  508F80     SUB W1, W0, [W15]
007BD0  3A0069     BRA NZ, 0x7CA4
007BD2  37001B     BRA 0x7C0A
007BD4  201940     MOV #0x194, W0
007BD6  508F80     SUB W1, W0, [W15]
007BD8  32003A     BRA Z, 0x7C4E
007BDA  27FFF0     MOV #0x7FFF, W0
007BDC  508F80     SUB W1, W0, [W15]
007BDE  3A0062     BRA NZ, 0x7CA4
007BE0  37005F     BRA 0x7CA0
1971:                      case EVENT_GENERIC_ATTACH:
1972:                          if (size == sizeof (GENERIC_DEVICE_ID)) {
007BE2  520FE6     SUB W4, #0x6, [W15]
007BE4  5A8FE0     SUBB W5, #0x0, [W15]
007BE6  3A005E     BRA NZ, 0x7CA4
1973:                              deviceAddress = ((GENERIC_DEVICE_ID *) data)->deviceAddress;
007BE8  904042     MOV.B [W2+4], W0
007BEA  B7EC84     MOV.B WREG, deviceAddress
1974:                              DemoState = BT_STATE_PROCESS;
007BEC  200018     MOV #0x1, W8
007BEE  886438     MOV W8, DemoState
1975:                              HciState = HCI_CMD_RESET; //YTS !!!!!!!!!!!!!!!!!
007BF0  EB0000     CLR W0
007BF2  886440     MOV W0, HciState
1976:                              PS4WireState = PS4_WIRE_READ_BD_ADDR1; //MH
007BF4  886450     MOV W0, PS4WireState
1977:              
1978:                              UART2PrintString("Generic demo device attached - event, deviceAddress=");
007BF6  29C160     MOV #0x9C16, W0
007BF8  070D42     RCALL UART2PrintString
1979:                              UART2PutDec(deviceAddress);
007BFA  BFCC84     MOV.B deviceAddress, WREG
007BFC  070D54     RCALL UART2PutDec
1980:                              UART2PrintString("\r\n");
007BFE  29C4B0     MOV #0x9C4B, W0
007C00  070D3E     RCALL UART2PrintString
1981:              #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
1982:                              for (i = 1; i < ((GENERIC_DEVICE_ID *) data)->serialNumberLength; i++) {
1983:                                  UART2PutChar(((GENERIC_DEVICE_ID *) data)->serialNumber[i]);
1984:                              }
1985:              #endif
1986:                              UART2PrintString("\r\n");
007C02  29C4B0     MOV #0x9C4B, W0
007C04  070D3C     RCALL UART2PrintString
007C06  780008     MOV W8, W0
007C08  37004E     BRA 0x7CA6
1987:                              return TRUE;
1988:                          }
1989:                          break;
1990:              
1991:                      case EVENT_GENERIC_DETACH:
1992:                          UART2PrintString("Generic demo device detached - event\r\n");
007C0A  29C4E0     MOV #0x9C4E, W0
007C0C  070D38     RCALL UART2PrintString
1993:                          ResetStates();
007C0E  07F59F     RCALL ResetStates
1994:                          SetConnectedDeviceType(NONE);
007C10  EB0000     CLR W0
007C12  070D14     RCALL SetConnectedDeviceType
007C14  200010     MOV #0x1, W0
007C16  370047     BRA 0x7CA6
1995:                          return TRUE;
1996:                          break;
1997:              
1998:                      case EVENT_GENERIC_TX_DONE: // The main state machine will poll the driver.
1999:                          break;
2000:              
2001:                      case EVENT_GENERIC_TX2_DONE:
2002:                          break;
2003:              
2004:                      case EVENT_GENERIC_RX1_DONE://YTS
2005:                          if (USBHostGenericGetRx1Length(deviceAddress) > 0) {
007C18  BFCC84     MOV.B deviceAddress, WREG
007C1A  E34EAE     CP.B 0xEAE
007C1C  3A0041     BRA NZ, 0x7CA0
007C1E  AB0EB9     BTST 0xEB9, #0
007C20  32003F     BRA Z, 0x7CA0
007C22  807580     MOV 0xEB0, W0
007C24  807591     MOV 0xEB2, W1
007C26  500FE0     SUB W0, #0x0, [W15]
007C28  588FE0     SUBB W1, #0x0, [W15]
007C2A  32003A     BRA Z, 0x7CA0
2006:                              switch (GetConnectedDeviceType()) {
007C2C  070D05     RCALL GetConnectedDeviceType
007C2E  780400     MOV W0, W8
007C30  500FE2     SUB W0, #0x2, [W15]
007C32  320007     BRA Z, 0x7C42
007C34  500FE3     SUB W0, #0x3, [W15]
007C36  320008     BRA Z, 0x7C48
007C38  500FE1     SUB W0, #0x1, [W15]
007C3A  3A0032     BRA NZ, 0x7CA0
2007:                                  case BLUETOOTH:
2008:                                      ParseRx1PS4BT();
007C3C  07F605     RCALL ParseRx1PS4BT
007C3E  780008     MOV W8, W0
007C40  370032     BRA 0x7CA6
2009:                                      break;
2010:                                  case CONTROLLER:
2011:                                      ParseRx1PS4Wire();
007C42  07F88B     RCALL ParseRx1PS4Wire
007C44  200010     MOV #0x1, W0
007C46  37002F     BRA 0x7CA6
2012:                                      break;
2013:                                  case SPACE_MOUSE:
2014:                                      ParseRx1SpaceNavigator();
007C48  07F88E     RCALL ParseRx1SpaceNavigator
007C4A  200010     MOV #0x1, W0
007C4C  37002C     BRA 0x7CA6
2015:                                      break;
2016:                                  default:
2017:                                      break;
2018:                              }
2019:                          }
2020:                          return TRUE;
2021:                          break;
2022:              
2023:                      case EVENT_GENERIC_RX2_DONE://YTS
2024:                          if (USBHostGenericGetRx2Length(deviceAddress) > 0) {
007C4E  BFCC84     MOV.B deviceAddress, WREG
007C50  E34EAE     CP.B 0xEAE
007C52  3A0026     BRA NZ, 0x7CA0
007C54  AB0EB9     BTST 0xEB9, #0
007C56  320024     BRA Z, 0x7CA0
007C58  8075A0     MOV 0xEB4, W0
007C5A  8075B1     MOV 0xEB6, W1
007C5C  500FE0     SUB W0, #0x0, [W15]
007C5E  588FE0     SUBB W1, #0x0, [W15]
007C60  32001F     BRA Z, 0x7CA0
2025:                              switch (GetConnectedDeviceType()) {
007C62  070CEA     RCALL GetConnectedDeviceType
007C64  780400     MOV W0, W8
007C66  500FE1     SUB W0, #0x1, [W15]
007C68  3A001B     BRA NZ, 0x7CA0
2026:                                  case BLUETOOTH:
2027:                                      ParseRx2PS4BT();
007C6A  07F741     RCALL ParseRx2PS4BT
007C6C  780008     MOV W8, W0
007C6E  37001B     BRA 0x7CA6
2028:                                      break;
2029:                                  default:
2030:                                      break;
2031:                              }
2032:                          }
2033:                          return TRUE;
2034:                          break;
2035:              
2036:                      case EVENT_VBUS_REQUEST_POWER:
2037:                          // We'll let anything attach.
2038:                          return TRUE;
2039:                          break;
2040:              
2041:                      case EVENT_VBUS_RELEASE_POWER:
2042:                          // We aren't keeping track of power.
2043:                          return TRUE;
2044:                          break;
2045:              
2046:                      case EVENT_HUB_ATTACH:
2047:                          UART2PrintString("\r\n***** USB Error - hubs are not supported *****\r\n");
007C70  29C750     MOV #0x9C75, W0
007C72  070D05     RCALL UART2PrintString
007C74  200010     MOV #0x1, W0
007C76  370017     BRA 0x7CA6
2048:                          return TRUE;
2049:                          break;
2050:              
2051:                      case EVENT_UNSUPPORTED_DEVICE:
2052:                          UART2PrintString("\r\n***** USB Error - device is not supported *****\r\n");
007C78  29CA80     MOV #0x9CA8, W0
007C7A  070D01     RCALL UART2PrintString
007C7C  200010     MOV #0x1, W0
007C7E  370013     BRA 0x7CA6
2053:                          return TRUE;
2054:                          break;
2055:              
2056:                      case EVENT_CANNOT_ENUMERATE:
2057:                          UART2PrintString("\r\n***** USB Error - cannot enumerate device *****\r\n");
007C80  29CDC0     MOV #0x9CDC, W0
007C82  070CFD     RCALL UART2PrintString
007C84  200010     MOV #0x1, W0
007C86  37000F     BRA 0x7CA6
2058:                          return TRUE;
2059:                          break;
2060:              
2061:                      case EVENT_CLIENT_INIT_ERROR:
2062:                          UART2PrintString("\r\n***** USB Error - client driver initialization error *****\r\n");
007C88  29D100     MOV #0x9D10, W0
007C8A  070CF9     RCALL UART2PrintString
007C8C  200010     MOV #0x1, W0
007C8E  37000B     BRA 0x7CA6
2063:                          return TRUE;
2064:                          break;
2065:              
2066:                      case EVENT_OUT_OF_MEMORY:
2067:                          UART2PrintString("\r\n***** USB Error - out of heap memory *****\r\n");
007C90  29D4F0     MOV #0x9D4F, W0
007C92  070CF5     RCALL UART2PrintString
007C94  200010     MOV #0x1, W0
007C96  370007     BRA 0x7CA6
2068:                          return TRUE;
2069:                          break;
2070:              
2071:                      case EVENT_UNSPECIFIED_ERROR: // This should never be generated.
2072:                          UART2PrintString("\r\n***** USB Error - unspecified *****\r\n");
007C98  29D7E0     MOV #0x9D7E, W0
007C9A  070CF1     RCALL UART2PrintString
007C9C  200010     MOV #0x1, W0
007C9E  370003     BRA 0x7CA6
2073:                          return TRUE;
007CA0  200010     MOV #0x1, W0
007CA2  370001     BRA 0x7CA6
007CA4  EB0000     CLR W0
2074:                          break;
2075:              
2076:                      case EVENT_SUSPEND:
2077:                      case EVENT_DETACH:
2078:                      case EVENT_RESUME:
2079:                      case EVENT_BUS_ERROR:
2080:                          return TRUE;
2081:                          break;
2082:              
2083:                      default:
2084:                          break;
2085:                  }
2086:                  return FALSE;
2087:              } // USB_ApplicationEventHandler
007CA6  78044F     MOV [--W15], W8
007CA8  060000     RETURN
2088:              
2089:              
2090:              
2091:              //******************************************************************************
2092:              //******************************************************************************
2093:              // Main
2094:              //******************************************************************************
2095:              //******************************************************************************
2096:              
2097:              /*************************************************************************
2098:               * Function:        main
2099:               *
2100:               * Preconditions:   None
2101:               *
2102:               * Input:           None
2103:               *
2104:               * Output:          None
2105:               *
2106:               * Returns:         Never exits
2107:               *
2108:               * Side Effects:    Runs the application
2109:               *
2110:               * Overview:        This is the USB Custom Demo Application's main entry
2111:               *                  point.
2112:               *************************************************************************/
2113:              
2114:              int main(void) {
007CAA  BE9F88     MOV.D W8, [W15++]
007CAC  BE9F8A     MOV.D W10, [W15++]
007CAE  BE9F8C     MOV.D W12, [W15++]
2115:                  unsigned char uartIn;
2116:                  unsigned char charbuf[2] = {0};
2117:                  // Initialize the processor and peripherals.
2118:                  if (InitializeSystem() != TRUE) {
007CB0  07F559     RCALL InitializeSystem
007CB2  500FE1     SUB W0, #0x1, [W15]
007CB4  320005     BRA Z, 0x7CC0
2119:                      UART2PrintString(FIRMWARE_REV);
007CB6  29DA60     MOV #0x9DA6, W0
007CB8  070CE2     RCALL UART2PrintString
2120:                      UART2PrintString(": Could not initialize system.  Halting.");
007CBA  29DAA0     MOV #0x9DAA, W0
007CBC  070CE0     RCALL UART2PrintString
007CBE  37FFFF     BRA 0x7CBE
2121:                      while (1);
2122:                  }
2123:                  if (USBHostInit(0) == TRUE) {
007CC0  B80060     MUL.UU W0, #0, W0
007CC2  07D5D1     RCALL USBHostInit
007CC4  500FE1     SUB W0, #0x1, [W15]
007CC6  3A000B     BRA NZ, 0x7CDE
2124:                      UART2PrintString("\r\n\r\n* ServoShock 2 Firmware Rev ");
007CC8  29DD30     MOV #0x9DD3, W0
007CCA  070CD9     RCALL UART2PrintString
2125:                      UART2PrintString(FIRMWARE_REV);
007CCC  29DA60     MOV #0x9DA6, W0
007CCE  070CD7     RCALL UART2PrintString
2126:                      UART2PrintString(" *\r\n");
007CD0  29DF40     MOV #0x9DF4, W0
007CD2  070CD5     RCALL UART2PrintString
2127:                      UART2PrintString("=Press 'Esc' in console to display quick reference guide=\n\r\n\r");
007CD4  29DF90     MOV #0x9DF9, W0
007CD6  070CD3     RCALL UART2PrintString
2128:                  } else {
2129:                      UART2PrintString(FIRMWARE_REV);
007CDE  29DA60     MOV #0x9DA6, W0
007CE0  070CCE     RCALL UART2PrintString
2130:                      UART2PrintString(" Could not initialize USB.  Halting.");
007CE2  29E370     MOV #0x9E37, W0
007CE4  070CCC     RCALL UART2PrintString
007CE6  37FFFF     BRA 0x7CE6
2131:                      while (1);
2132:                  }
2133:              
2134:                  //Enter test mode
2135:                  if (_PGD == 1) {
007CD8  E242CA     CP0.B PORTB
007CDA  350006     BRA LT, 0x7CE8
007CDC  370009     BRA 0x7CF0
2136:                      UART2PrintString("Circuit Test Mode.\n\r");
007CE8  29E5C0     MOV #0x9E5C, W0
007CEA  070CC9     RCALL UART2PrintString
2137:                      while (1) {
2138:                          TestCases();
007CEC  070E14     RCALL TestCases
007CEE  37FFFE     BRA 0x7CEC
2139:                      }
2140:                  }
2141:              
2142:                  //Initialize non-volatile memory
2143:                  DataEEInit();
007CF0  070994     RCALL DataEEInit
2144:                  dataEEFlags.val = 0;
007CF2  EF6F2A     CLR.B dataEEFlags
2145:              
2146:                  if (DataEERead(DEFAULTS_INITIALIZED_FLAG) == 0xFFFF) {
007CF4  200030     MOV #0x3, W0
007CF6  070A02     RCALL DataEERead
007CF8  400FE1     ADD W0, #0x1, [W15]
007CFA  3A000F     BRA NZ, 0x7D1A
2147:                      LoadDefaultSettings(TRUE, 0);
007CFC  EB0080     CLR W1
007CFE  200010     MOV #0x1, W0
007D00  07E6AF     RCALL LoadDefaultSettings
2148:              
2149:                      if (DataEEWrite(1, DEFAULTS_INITIALIZED_FLAG) == 0) {
007D02  200031     MOV #0x3, W1
007D04  200010     MOV #0x1, W0
007D06  070A45     RCALL DataEEWrite
007D08  E00400     CP0.B W0
007D0A  3A0004     BRA NZ, 0x7D14
2150:                          UART2PrintString("Defaults Loaded.\n\r");
007D0C  29E710     MOV #0x9E71, W0
007D0E  070CB7     RCALL UART2PrintString
2151:                          SaveSettings();
007D10  07E7A1     RCALL SaveSettings
007D12  370004     BRA 0x7D1C
2152:                      } else {
2153:                          UART2PrintString("Loading Defaults Error. \n\r");
007D14  29E840     MOV #0x9E84, W0
007D16  070CB3     RCALL UART2PrintString
007D18  370001     BRA 0x7D1C
2154:                      }
2155:                  } else {
2156:                      LoadSavedSettings();
007D1A  07E795     RCALL LoadSavedSettings
2157:                  }
2158:              
2159:                  ResetOutputs(BTControllerInPtr); //initialize outputs and put in an artificial nominal input so it doesn't read all zeros.
007D1C  807910     MOV 0xF22, W0
007D1E  07F47A     RCALL ResetOutputs
2160:              
2161:              
2162:                  //enable timer4 interrupt
2163:                  IEC1bits.T4IE = 1;
007D20  A86097     BSET 0x97, #3
2164:                  IPC6bits.T4IP = 1; //lowest priority interrupt
007D22  BFC0B1     MOV.B 0xB1, WREG
007D24  B3C8F1     MOV.B #0x8F, W1
007D26  604001     AND.B W0, W1, W0
007D28  A04400     BSET.B W0, #4
007D2A  B7E0B1     MOV.B WREG, 0xB1
2165:              
2166:                  //SPI setup
2167:                  initSPI();
007D2C  070F2D     RCALL initSPI
2168:                  IEC1bits.INT1IE = 1;
007D2E  A88096     BSET IEC1, #4
2169:              
2170:                  InitOutputs(); //enable outputs
007D30  07E5EE     RCALL InitOutputs
007D32  EB4680     CLR.B W13
007D34  78460D     MOV.B W13, W12
2171:              
2172:                  // Main Processing Loop
2173:                  while (1) {
2174:                      UART2ClrError();
007D36  070DEA     RCALL UART2ClrError
2175:                      if (UART2DataReceived())
007D38  BFC232     MOV.B U2STA, WREG
007D3A  A30800     BTST.Z W0, #0
007D3C  32001A     BRA Z, 0x7D72
2176:                      {
2177:                          uartIn = UART2GetChar();
007D3E  070C82     RCALL UART2GetChar
007D40  784480     MOV.B W0, W9
007D42  784400     MOV.B W0, W8
2178:                          if (uartIn == 0x1B) //If 'Esc' entered from keyboard
007D44  504FFB     SUB.B W0, #0x1B, [W15]
007D46  3A0002     BRA NZ, 0x7D4C
2179:                          {
2180:                              PrintMenu();
007D48  07F4C3     RCALL PrintMenu
007D4A  370013     BRA 0x7D72
2181:                          }
2182:                          else
2183:                          {
2184:                              UART2PutChar(uartIn);               
007D4C  070CA5     RCALL UART2PutChar
2185:                              if (charbuf[1] == 'R' && charbuf[0] == 'S' && uartIn == 'T') Reset();
007D4E  B3C520     MOV.B #0x52, W0
007D50  564F80     SUB.B W12, W0, [W15]
007D52  3A000D     BRA NZ, 0x7D6E
007D54  B3C531     MOV.B #0x53, W1
007D56  56CF81     SUB.B W13, W1, [W15]
007D58  3A000A     BRA NZ, 0x7D6E
007D5A  E8C000     INC2.B W0, W0
007D5C  54CF80     SUB.B W9, W0, [W15]
007D5E  320003     BRA Z, 0x7D66
007D60  784689     MOV.B W9, W13
007D62  784601     MOV.B W1, W12
007D64  370006     BRA 0x7D72
007D66  FE0000     RESET
007D68  784689     MOV.B W9, W13
007D6A  B3C53C     MOV.B #0x53, W12
007D6C  370002     BRA 0x7D72
007D6E  78460D     MOV.B W13, W12
007D70  784688     MOV.B W8, W13
2186:                              charbuf[1] = charbuf[0];
2187:                              charbuf[0] = uartIn;
2188:                          }
2189:                      }
2190:              
2191:              #ifdef DEBUG_MODE
2192:                      if (LED_SEL_0 == 1) {
2193:                          UART2PutHex(DemoState);
2194:                          UART2PutChar('-');
2195:                          UART2PutHex(HciState);
2196:                          UART2PutChar(' ');
2197:                      }
2198:              #endif
2199:                      // Maintain USB Host State
2200:                      USBHostTasks();
007D72  07D6B9     RCALL USBHostTasks
2201:                      switch (GetConnectedDeviceType()) {
007D74  070C61     RCALL GetConnectedDeviceType
007D76  500FE2     SUB W0, #0x2, [W15]
007D78  320005     BRA Z, 0x7D84
007D7A  500FE3     SUB W0, #0x3, [W15]
007D7C  320007     BRA Z, 0x7D8C
007D7E  500FE1     SUB W0, #0x1, [W15]
007D80  3A0006     BRA NZ, 0x7D8E
007D82  370002     BRA 0x7D88
2202:                          case CONTROLLER:
2203:                              ManageStateWire();
007D84  07FD9C     RCALL ManageStateWire
007D86  370003     BRA 0x7D8E
2204:                              break;
2205:                          case BLUETOOTH:
2206:                              ManageStateBluetooth();
007D88  07F837     RCALL ManageStateBluetooth
007D8A  370001     BRA 0x7D8E
2207:                              break;
2208:                          case SPACE_MOUSE:
2209:                              ManageStateSpaceNavigator();
007D8C  07FEE6     RCALL ManageStateSpaceNavigator
2210:                          default:
2211:                              break;
2212:                      }
2213:              
2214:                      //Process buttons here
2215:                      if (HciState == PS4_BT_RUNNING || PS4WireState == PS4_WIRE_RUNNING || SpaceNavState == SPACE_NAV_RUNNING){
007D8E  806440     MOV HciState, W0
007D90  500FFA     SUB W0, #0x1A, [W15]
007D92  320006     BRA Z, 0x7DA0
007D94  806450     MOV PS4WireState, W0
007D96  500FE5     SUB W0, #0x5, [W15]
007D98  320003     BRA Z, 0x7DA0
007D9A  806460     MOV SpaceNavState, W0
007D9C  500FE1     SUB W0, #0x1, [W15]
007D9E  3A008C     BRA NZ, 0x7EB8
2216:                          INDICATOR_LED = 0;
007DA0  A9A2E4     BCLR LATE, #5
2217:                          //Process Device Type specific tasks
2218:                          switch (GetConnectedDeviceType()) {
007DA2  070C4A     RCALL GetConnectedDeviceType
007DA4  500FE1     SUB W0, #0x1, [W15]
007DA6  3A0021     BRA NZ, 0x7DEA
2219:                              case BLUETOOTH:
2220:              
2221:                                  if (GetPressDuration()->share > 300 && GetPressDuration()->options > 300) {
007DA8  0706AE     RCALL GetPressDuration
007DAA  9058E0     MOV.B [W0+30], W1
007DAC  FB8081     ZE W1, W1
007DAE  905870     MOV.B [W0+31], W0
007DB0  DD0048     SL W0, #8, W0
007DB2  700001     IOR W0, W1, W0
007DB4  2012C8     MOV #0x12C, W8
007DB6  500F88     SUB W0, W8, [W15]
007DB8  36000C     BRA LEU, 0x7DD2
007DBA  0706A5     RCALL GetPressDuration
007DBC  9058C0     MOV.B [W0+28], W1
007DBE  FB8081     ZE W1, W1
007DC0  905850     MOV.B [W0+29], W0
007DC2  DD0048     SL W0, #8, W0
007DC4  700001     IOR W0, W1, W0
007DC6  500F88     SUB W0, W8, [W15]
007DC8  360004     BRA LEU, 0x7DD2
2222:                                      UART2PrintString("Disconnecting...\n\r");
007DCA  29E9F0     MOV #0x9E9F, W0
007DCC  070C58     RCALL UART2PrintString
2223:                                      HciState = L2CAP_DISCONNECT_DATA;
007DCE  2001D0     MOV #0x1D, W0
007DD0  886440     MOV W0, HciState
2224:                                  }
2225:                                  if ((GetTimeoutSetting() > 0) && (GetIdleTimer() > GetTimeoutSetting())) {
007DD2  07E74B     RCALL GetTimeoutSetting
007DD4  E00000     CP0 W0
007DD6  320009     BRA Z, 0x7DEA
007DD8  070781     RCALL GetIdleTimer
007DDA  780400     MOV W0, W8
007DDC  07E746     RCALL GetTimeoutSetting
007DDE  540F80     SUB W8, W0, [W15]
007DE0  360004     BRA LEU, 0x7DEA
2226:                                      UART2PrintString("Idle Timeout.\n\r");
007DE2  29EB20     MOV #0x9EB2, W0
007DE4  070C4C     RCALL UART2PrintString
2227:                                      HciState = L2CAP_DISCONNECT_DATA;
007DE6  2001D0     MOV #0x1D, W0
007DE8  886440     MOV W0, HciState
2228:                                  }
2229:                                  break;
2230:              
2231:                              case CONTROLLER:
2232:                                  break;
2233:              
2234:                              default:
2235:                                  break;
2236:                          }
2237:                          
2238:                          if (GetSpiInputPacket()->overrideRumbleL) {
007DEA  070F2E     RCALL GetSpiInputPacket
007DEC  784010     MOV.B [W0], W0
007DEE  604062     AND.B W0, #0x2, W0
007DF0  320004     BRA Z, 0x7DFA
2239:                              vibeL = GetSpiInputPacket()->RumbleL;
007DF2  070F2A     RCALL GetSpiInputPacket
007DF4  904060     MOV.B [W0+6], W0
007DF6  B7ED96     MOV.B WREG, vibeL
007DF8  370006     BRA 0x7E06
2240:                          } 
2241:                          else if (AD1CON1bits.DONE) {
007DFA  BFC320     MOV.B AD1CON1, WREG
007DFC  A30800     BTST.Z W0, #0
007DFE  320003     BRA Z, 0x7E06
2242:                              vibeL = (unsigned char)(ADC1BUF0 >> 2); //convert 10-bit to 8-bit
007E00  801800     MOV ADC1BUF0, W0
007E02  DE0042     LSR W0, #2, W0
007E04  B7ED96     MOV.B WREG, vibeL
2243:                          }
2244:              
2245:                          if (GetSpiInputPacket()->overrideRumbleH) {
007E06  070F20     RCALL GetSpiInputPacket
007E08  784010     MOV.B [W0], W0
007E0A  604064     AND.B W0, #0x4, W0
007E0C  320004     BRA Z, 0x7E16
2246:                              vibeH = GetSpiInputPacket()->RumbleH;
007E0E  070F1C     RCALL GetSpiInputPacket
007E10  904070     MOV.B [W0+7], W0
007E12  B7ED97     MOV.B WREG, vibeH
007E14  370006     BRA 0x7E22
2247:                          } else if (AD1CON1bits.DONE) //Control Vibe with SPI bus
007E16  BFC320     MOV.B AD1CON1, WREG
007E18  A30800     BTST.Z W0, #0
007E1A  320003     BRA Z, 0x7E22
2248:                          {
2249:                              vibeH = (unsigned char)(ADC1BUF1 >> 2);
007E1C  801810     MOV ADC1BUF1, W0
007E1E  DE0042     LSR W0, #2, W0
007E20  B7ED97     MOV.B WREG, vibeH
2250:                          }
2251:              
2252:                          if (AD1CON1bits.DONE){ //Control Vibe with SPI bus
007E22  BFC320     MOV.B AD1CON1, WREG
007E24  A30800     BTST.Z W0, #0
007E26  320005     BRA Z, 0x7E32
2253:                              LedAdc = (unsigned char)(ADC1BUF2/93); //convert to 0-10 number
007E28  801820     MOV ADC1BUF2, W0
007E2A  2005D2     MOV #0x5D, W2
007E2C  090011     REPEAT #0x11
007E2E  D88002     DIV.UW W0, W2
007E30  B7EF24     MOV.B WREG, 0xF24
2254:                          }
2255:                                     
2256:                          ////////////100ms loop for writing LEDs and rumble motor values to controller////////////////
2257:                          if (loopCounter >= 10) //time the outputs to avoid spamming the controller.  Spamming will cause it to lag or freeze//
007E32  806410     MOV loopCounter, W0
007E34  500FE9     SUB W0, #0x9, [W15]
007E36  360054     BRA LEU, 0x7EE0
2258:                          {
2259:                              INDICATOR_LED = 1;
007E38  A8A2E4     BSET LATE, #5
2260:                              loopCounter = 0;
007E3A  EF2C82     CLR loopCounter
2261:              
2262:                              if (configFlag == FALSE)
007E3C  E20C7E     CP0 configFlag
007E3E  3A0030     BRA NZ, 0x7EA0
2263:                              {
2264:                                  SetRumbleL(vibeL);
007E40  BFCD96     MOV.B vibeL, WREG
007E42  07070B     RCALL SetRumbleL
2265:                                  SetRumbleH(vibeH);
007E44  BFCD97     MOV.B vibeH, WREG
007E46  070702     RCALL SetRumbleH
2266:                                  if (GetSpiInputPacket()->overrideLED) {//Control LED with SPI
007E48  070EFF     RCALL GetSpiInputPacket
007E4A  784010     MOV.B [W0], W0
007E4C  604061     AND.B W0, #0x1, W0
007E4E  320010     BRA Z, 0x7E70
2267:                                      SetLEDColorRGB(GetSpiInputPacket()->LEDRed, 
007E50  070EFB     RCALL GetSpiInputPacket
007E52  904550     MOV.B [W0+5], W10
007E54  070EF9     RCALL GetSpiInputPacket
007E56  9045C0     MOV.B [W0+4], W11
007E58  070EF7     RCALL GetSpiInputPacket
007E5A  9044B0     MOV.B [W0+3], W9
007E5C  070EF5     RCALL GetSpiInputPacket
007E5E  904420     MOV.B [W0+2], W8
007E60  070EF3     RCALL GetSpiInputPacket
007E62  904010     MOV.B [W0+1], W0
007E64  78420A     MOV.B W10, W4
007E66  78418B     MOV.B W11, W3
007E68  784109     MOV.B W9, W2
007E6A  784088     MOV.B W8, W1
007E6C  0706E4     RCALL SetLEDColorRGB
007E6E  370018     BRA 0x7EA0
2268:                                              GetSpiInputPacket()->LEDGreen, 
2269:                                              GetSpiInputPacket()->LEDBlue,
2270:                                              GetSpiInputPacket()->LEDBlinkOnDuration,
2271:                                              GetSpiInputPacket()->LEDBlinkOffDuration);
2272:                                  }
2273:                                  else{
2274:                                      switch (GetLEDColorSetting())
007E70  07F40D     RCALL GetLEDColorSetting
007E72  500FEB     SUB W0, #0xB, [W15]
007E74  320003     BRA Z, 0x7E7C
007E76  500FEC     SUB W0, #0xC, [W15]
007E78  3A000C     BRA NZ, 0x7E92
007E7A  370008     BRA 0x7E8C
2275:                                      {
2276:                                          case COLOR_ADC:
2277:                                              SetLEDColor(LedAdc, GetLEDBrightness(), 0, 0);
007E7C  07F405     RCALL GetLEDBrightness
007E7E  780080     MOV W0, W1
007E80  BFCF24     MOV.B 0xF24, WREG
007E82  FB8000     ZE W0, W0
007E84  EB4180     CLR.B W3
007E86  784103     MOV.B W3, W2
007E88  07064E     RCALL SetLEDColor
007E8A  37000A     BRA 0x7EA0
2278:                                              break;
2279:                                          case BATTERY:
2280:                                              UpdateBatteryDisplay(TRUE);
007E8C  200010     MOV #0x1, W0
007E8E  0706EC     RCALL UpdateBatteryDisplay
007E90  370007     BRA 0x7EA0
2281:                                              break;
2282:                                          default:
2283:                                              SetLEDColor(GetLEDColorSetting(), GetLEDBrightness(), 0, 0);
007E92  07F3FA     RCALL GetLEDBrightness
007E94  780400     MOV W0, W8
007E96  07F3FA     RCALL GetLEDColorSetting
007E98  EB4180     CLR.B W3
007E9A  784103     MOV.B W3, W2
007E9C  784088     MOV.B W8, W1
007E9E  070643     RCALL SetLEDColor
2284:                                              break;
2285:                                      }
2286:                                  }
2287:                              }
2288:                              
2289:                              UpdateRumbleFeedback(0); //decrease rumble timer if it's set.
007EA0  EB0000     CLR W0
007EA2  07070D     RCALL UpdateRumbleFeedback
2290:                              UpdateBatteryDisplay(FALSE); //display battery levels on LEDs if the command was activated
007EA4  EB0000     CLR W0
007EA6  0706E0     RCALL UpdateBatteryDisplay
2291:                              
2292:                              if (GetConnectedDeviceType() == BLUETOOTH || GetConnectedDeviceType() == CONTROLLER)
007EA8  070BC7     RCALL GetConnectedDeviceType
007EAA  500FE1     SUB W0, #0x1, [W15]
007EAC  320003     BRA Z, 0x7EB4
007EAE  070BC4     RCALL GetConnectedDeviceType
007EB0  500FE2     SUB W0, #0x2, [W15]
007EB2  3A0016     BRA NZ, 0x7EE0
2293:                              {
2294:                                  if (WriteOutputReport() == USB_SUCCESS)
007EB4  07F784     RCALL WriteOutputReport
007EB6  370014     BRA 0x7EE0
2295:                                  {
2296:                                      #ifdef DEBUG_MODE
2297:                                      UART2PrintString("OK:");
2298:                                      #endif
2299:                                  }
2300:                              }
2301:                          }
2302:                      }            
2303:                      //Stuff to do when the controllers are not connected
2304:                      //exit the config state if we were left in that state when the controller was connected
2305:                      else {
2306:                          INDICATOR_LED = 0;
007EB8  A9A2E4     BCLR LATE, #5
2307:                          ResetIdleTimer(); //need to reset the idle timer because being disconnected makes it appear idle and can trigger the auto-disconnect.
007EBA  070712     RCALL ResetIdleTimer
2308:                          GetPS4Report()[0] = 0xFF; //set first byte to 0xFF so anything reading the packs from SPI bus can tell it's disconnected
007EBC  07062C     RCALL GetPS4Report
007EBE  EBC800     SETM.B [W0]
2309:                          if (configFlag == TRUE) {
007EC0  8063F0     MOV configFlag, W0
007EC2  500FE1     SUB W0, #0x1, [W15]
007EC4  3A0003     BRA NZ, 0x7ECC
2310:                              configFlag = FALSE;
007EC6  EF2C7E     CLR configFlag
2311:                              ConfigOutput(configFlag);
007EC8  8063F0     MOV configFlag, W0
007ECA  07E6D1     RCALL ConfigOutput
2312:                          }
2313:                          if (loopCounter == 150)
007ECC  806411     MOV loopCounter, W1
007ECE  200960     MOV #0x96, W0
007ED0  508F80     SUB W1, W0, [W15]
007ED2  3A0001     BRA NZ, 0x7ED6
2314:                          {
2315:                              INDICATOR_LED = 1;
007ED4  A8A2E4     BSET LATE, #5
2316:                          }
2317:                          if (loopCounter > 160)
007ED6  806411     MOV loopCounter, W1
007ED8  200A00     MOV #0xA0, W0
007EDA  508F80     SUB W1, W0, [W15]
007EDC  360001     BRA LEU, 0x7EE0
2318:                          {
2319:                              loopCounter = 0;
007EDE  EF2C82     CLR loopCounter
2320:                          }
2321:                      }
2322:                      DelayMs(1);
007EE0  23E800     MOV #0x3E80, W0
007EE2  200001     MOV #0x0, W1
007EE4  07D057     RCALL ___delay32
007EE6  37FF27     BRA 0x7D36
2323:                  }
2324:                  return 0;
2325:              } // main
2326:              
2327:              //10ms interrupt to poll/update states
2328:              
2329:              void __attribute__((__interrupt__, auto_psv))_T4Interrupt(void) {
007EE8  F80036     PUSH RCOUNT
007EEA  BE9F80     MOV.D W0, [W15++]
007EEC  BE9F82     MOV.D W2, [W15++]
007EEE  BE9F84     MOV.D W4, [W15++]
007EF0  BE9F86     MOV.D W6, [W15++]
007EF2  781F88     MOV W8, [W15++]
007EF4  F80034     PUSH PSVPAG
007EF6  200000     MOV #0x0, W0
007EF8  8801A0     MOV W0, PSVPAG
2330:                  UpdateNewPress(); //Update record of button presses first thing to reduce jitter
007EFA  0705B1     RCALL UpdateNewPress
2331:                  loopCounter++; //counts how many times we enter this ISR routine.
007EFC  EC2C82     INC loopCounter
2332:                  
2333:                  UpdateCurrentStateBuffer((CONTROLLER_IN *)GetPS4Report());
007EFE  07060B     RCALL GetPS4Report
007F00  07020E     RCALL UpdateCurrentStateBuffer
2334:                  
2335:                  UpdateServoOutputs(); //Update servo outputs
007F02  07EF68     RCALL UpdateServoOutputs
2336:                  
2337:                  CheckIdle();
007F04  07052E     RCALL CheckIdle
2338:                  
2339:                  //enter or exit config mode here
2340:                  if (GetPressDuration()->share > 300 && GetPressDuration()->psButton > 300) {
007F06  0705FF     RCALL GetPressDuration
007F08  9058E0     MOV.B [W0+30], W1
007F0A  FB8081     ZE W1, W1
007F0C  905870     MOV.B [W0+31], W0
007F0E  DD0048     SL W0, #8, W0
007F10  700001     IOR W0, W1, W0
007F12  2012C8     MOV #0x12C, W8
007F14  500F88     SUB W0, W8, [W15]
007F16  36000A     BRA LEU, 0x7F2C
007F18  0705F6     RCALL GetPressDuration
007F1A  9060A0     MOV.B [W0+34], W1
007F1C  FB8081     ZE W1, W1
007F1E  906030     MOV.B [W0+35], W0
007F20  DD0048     SL W0, #8, W0
007F22  700001     IOR W0, W1, W0
007F24  500F88     SUB W0, W8, [W15]
007F26  360002     BRA LEU, 0x7F2C
2341:                      configFlag = TRUE;
007F28  200010     MOV #0x1, W0
007F2A  8863F0     MOV W0, configFlag
2342:                  }
2343:                  if (configFlag == TRUE) {
007F2C  8063F0     MOV configFlag, W0
007F2E  500FE1     SUB W0, #0x1, [W15]
007F30  3A0004     BRA NZ, 0x7F3A
2344:                      configFlag = ConfigOutput(configFlag); //configFlag will be set to false when we want to exit config, and breaks this loop.
007F32  8063F0     MOV configFlag, W0
007F34  07E69C     RCALL ConfigOutput
007F36  8863F0     MOV W0, configFlag
007F38  370002     BRA 0x7F3E
2345:                  } 
2346:                  else{
2347:                      UpdateButtonOutputs(FALSE, 0); //don't update button outputs when in config mode because buttons are used to change settings.
007F3A  B80060     MUL.UU W0, #0, W0
007F3C  07ECE7     RCALL UpdateButtonOutputs
2348:                  }    
2349:                  
2350:                  AD1CON1bits.SAMP = 1; //sample ADC
007F3E  A82320     BSET AD1CON1, #1
2351:                  IFS1bits.T4IF = 0;
007F40  A96087     BCLR 0x87, #3
2352:              }
007F42  F90034     POP PSVPAG
007F44  78044F     MOV [--W15], W8
007F46  BE034F     MOV.D [--W15], W6
007F48  BE024F     MOV.D [--W15], W4
007F4A  BE014F     MOV.D [--W15], W2
007F4C  BE004F     MOV.D [--W15], W0
007F4E  F90036     POP RCOUNT
007F50  064000     RETFIE
2353:              
2354:              //SPI bus interrupt to handle SPI packets
2355:              
2356:              void __attribute__((__interrupt__, auto_psv))_SPI1Interrupt(void) {
007F52  F80036     PUSH RCOUNT
007F54  BE9F80     MOV.D W0, [W15++]
007F56  BE9F82     MOV.D W2, [W15++]
007F58  BE9F84     MOV.D W4, [W15++]
007F5A  BE9F86     MOV.D W6, [W15++]
007F5C  F80034     PUSH PSVPAG
007F5E  200000     MOV #0x0, W0
007F60  8801A0     MOV W0, PSVPAG
2357:                  while (!SPI1STATbits.SPITBF) {
007F62  BFC240     MOV.B SPI1STAT, WREG
007F64  A31800     BTST.Z W0, #1
007F66  3A001D     BRA NZ, 0x7FA2
007F9C  BFC240     MOV.B SPI1STAT, WREG
007F9E  A31800     BTST.Z W0, #1
007FA0  32FFE3     BRA Z, 0x7F68
2358:                      if (spi_index < PS4_REPORT_LENGTH) {
007F68  8063D1     MOV spi_index, W1
007F6A  2003C0     MOV #0x3C, W0
007F6C  508F80     SUB W1, W0, [W15]
007F6E  3C0011     BRA GT, 0x7F92
2359:                          if (spi_index < SPI_INPUT_PACKET_LENGTH) {
007F70  8063D1     MOV spi_index, W1
007F72  500076     SUB W0, #0x16, W0
007F74  508F80     SUB W1, W0, [W15]
007F76  3C0005     BRA GT, 0x7F82
2360:                              GetSpiInputPacket()->array[spi_index] = SPI1BUF;
007F78  070E67     RCALL GetSpiInputPacket
007F7A  8063D2     MOV spi_index, W2
007F7C  801241     MOV SPI1BUF, W1
007F7E  787101     MOV.B W1, [W2+W0]
007F80  370002     BRA 0x7F86
2361:                          } else {
2362:                              temp = SPI1BUF; //burn off filler bytes
007F82  801240     MOV SPI1BUF, W0
007F84  B7ED98     MOV.B WREG, temp
2363:                          }
2364:                          SPI1BUF = GetPS4Report()[spi_index]; //fill output buffer
007F86  0705C7     RCALL GetPS4Report
007F88  8063D1     MOV spi_index, W1
007F8A  784061     MOV.B [W1+W0], W0
007F8C  FB8000     ZE W0, W0
007F8E  881240     MOV W0, SPI1BUF
007F90  370004     BRA 0x7F9A
2365:                      } else {
2366:                          SPI1BUF = 0xAA; //padding
007F92  200AA0     MOV #0xAA, W0
007F94  881240     MOV W0, SPI1BUF
2367:                          temp = SPI1BUF; //burn off bytes
007F96  801240     MOV SPI1BUF, W0
007F98  B7ED98     MOV.B WREG, temp
2368:                      }
2369:                      spi_index++;
007F9A  EC2C7A     INC spi_index
2370:                  }
2371:                  IFS0bits.SPI1IF = 0;
007FA2  A94085     BCLR 0x85, #2
2372:              }
007FA4  F90034     POP PSVPAG
007FA6  BE034F     MOV.D [--W15], W6
007FA8  BE024F     MOV.D [--W15], W4
007FAA  BE014F     MOV.D [--W15], W2
007FAC  BE004F     MOV.D [--W15], W0
007FAE  F90036     POP RCOUNT
007FB0  064000     RETFIE
2373:              
2374:              //INT1Interrupt: The INT1Interrupt pin (pin 46) is tied to the SPI slave select pin (pin 45).
2375:              //execute when SPI slave select is pulled high to clear/prime the input/output buffers, so the messages will always be the same length
2376:              
2377:              void __attribute__((__interrupt__, auto_psv))_INT1Interrupt(void) {
007FB2  BE9F80     MOV.D W0, [W15++]
007FB4  F80034     PUSH PSVPAG
007FB6  200000     MOV #0x0, W0
007FB8  8801A0     MOV W0, PSVPAG
2378:                  if (SPI1STATbits.SPIEN) //if we try to run the code in the interrupt when SPI bus is disabled, it will get stuck!
007FBA  E24241     CP0.B 0x241
007FBC  350013     BRA LT, 0x7FE4
007FBE  370016     BRA 0x7FEC
2379:                  {
2380:                      while (!SPI1STATbits.SPITBF) {
007FC4  BFC240     MOV.B SPI1STAT, WREG
007FC6  A31800     BTST.Z W0, #1
007FC8  32FFFB     BRA Z, 0x7FC0
007FE4  BFC240     MOV.B SPI1STAT, WREG
007FE6  A31800     BTST.Z W0, #1
007FE8  32FFEB     BRA Z, 0x7FC0
007FEA  37FFEF     BRA 0x7FCA
2381:                          //The PIC can't manually flush the 8-byte output buffer, so we'll  fill it up so that we
2382:                          //start the packet on the 9th byte every time.  Discard the first 8 byes
2383:                          //on the receiving end.
2384:                          SPI1BUF = 0xAB;
007FC0  200AB0     MOV #0xAB, W0
007FC2  881240     MOV W0, SPI1BUF
2385:                      }
2386:              
2387:                      while (!SPI1STATbits.SRXMPT) {
007FCA  BFC240     MOV.B SPI1STAT, WREG
007FCC  A35800     BTST.Z W0, #5
007FCE  3A0006     BRA NZ, 0x7FDC
007FD2  BFC240     MOV.B SPI1STAT, WREG
007FD4  A35800     BTST.Z W0, #5
007FD6  32FFFC     BRA Z, 0x7FD0
007FD8  780001     MOV W1, W0
007FDA  B7ED98     MOV.B WREG, temp
2388:                          temp = SPI1BUF; //flush the input buffer.
007FD0  801241     MOV SPI1BUF, W1
2389:                      }
2390:                      spi_index = 0;
007FDC  EF2C7A     CLR spi_index
2391:                      SPI1STATbits.SPIROV = 0;
007FDE  A9C240     BCLR SPI1STAT, #6
2392:                      IFS1bits.INT1IF = 0;
007FE0  A98086     BCLR IFS1, #4
007FE2  370004     BRA 0x7FEC
2393:                  }
2394:              }
007FEC  F90034     POP PSVPAG
007FEE  BE004F     MOV.D [--W15], W0
007FF0  064000     RETFIE
2395:              
2396:              
2397:              //Error Traps
2398:              
2399:              void __attribute__((__interrupt__, auto_psv))_AddressError(void) {
007FF2  F80036     PUSH RCOUNT
007FF4  BE9F80     MOV.D W0, [W15++]
007FF6  BE9F82     MOV.D W2, [W15++]
007FF8  BE9F84     MOV.D W4, [W15++]
007FFA  BE9F86     MOV.D W6, [W15++]
007FFC  F80034     PUSH PSVPAG
007FFE  200000     MOV #0x0, W0
008000  8801A0     MOV W0, PSVPAG
2400:                  UART2PutChar('E');
008002  B3C450     MOV.B #0x45, W0
008004  070B49     RCALL UART2PutChar
2401:                  {
2402:                      __asm__ volatile ("nop");
008006  000000     NOP
2403:                  }
2404:              }
008008  F90034     POP PSVPAG
00800A  BE034F     MOV.D [--W15], W6
00800C  BE024F     MOV.D [--W15], W4
00800E  BE014F     MOV.D [--W15], W2
008010  BE004F     MOV.D [--W15], W0
008012  F90036     POP RCOUNT
008014  064000     RETFIE
2405:              
2406:              void __attribute__((__interrupt__, auto_psv))_StackError(void) {
008016  F80036     PUSH RCOUNT
008018  BE9F80     MOV.D W0, [W15++]
00801A  BE9F82     MOV.D W2, [W15++]
00801C  BE9F84     MOV.D W4, [W15++]
00801E  BE9F86     MOV.D W6, [W15++]
008020  F80034     PUSH PSVPAG
008022  200000     MOV #0x0, W0
008024  8801A0     MOV W0, PSVPAG
2407:                  UART2PrintString("StackError");
008026  29EC20     MOV #0x9EC2, W0
008028  070B2A     RCALL UART2PrintString
2408:                  {
2409:                      __asm__ volatile ("retfie");
00802A  064000     RETFIE
2410:                  }
2411:              }
00802C  F90034     POP PSVPAG
00802E  BE034F     MOV.D [--W15], W6
008030  BE024F     MOV.D [--W15], W4
008032  BE014F     MOV.D [--W15], W2
008034  BE004F     MOV.D [--W15], W0
008036  F90036     POP RCOUNT
008038  064000     RETFIE
2412:              
2413:              void __attribute__((__interrupt__, auto_psv))_MathError(void) {
00803A  F80036     PUSH RCOUNT
00803C  BE9F80     MOV.D W0, [W15++]
00803E  BE9F82     MOV.D W2, [W15++]
008040  BE9F84     MOV.D W4, [W15++]
008042  BE9F86     MOV.D W6, [W15++]
008044  F80034     PUSH PSVPAG
008046  200000     MOV #0x0, W0
008048  8801A0     MOV W0, PSVPAG
2414:                  UART2PrintString("Math Error");
00804A  29ECD0     MOV #0x9ECD, W0
00804C  070B18     RCALL UART2PrintString
2415:                  {
2416:                      __asm__ volatile ("retfie");
00804E  064000     RETFIE
2417:                  }
2418:              }
008050  F90034     POP PSVPAG
008052  BE034F     MOV.D [--W15], W6
008054  BE024F     MOV.D [--W15], W4
008056  BE014F     MOV.D [--W15], W2
008058  BE004F     MOV.D [--W15], W0
00805A  F90036     POP RCOUNT
00805C  064000     RETFIE
2419:              /*************************************************************************
2420:               * EOF main.c
2421:               */
2422:              
---  D:/PIC/PIC_PS4_Host/trunk/functional_test.c  -------------------------------------------------------
1:                 #include "functional_test.h"
2:                 #include "main.h"
3:                 #include <p24Fxxxx.h>
4:                 #include <stdlib.h>
5:                 
6:                 #include "GenericTypeDefs.h"
7:                 #include "HardwareProfile.h"
8:                 
9:                 /*************************************************************************
10:                 * Function:        TestCases
11:                 *
12:                 * Preconditions:   None
13:                 *
14:                 * Input:           None
15:                 *
16:                 * Output:          None
17:                 *
18:                 * Returns:         None
19:                 *
20:                 * Side Effects:    None
21:                 *
22:                 * Overview:        This routine is used for use with the automatic testbed.
23:                 *                  clocking the PGC pin will toggle the outputs on and off
24:                 *                  one by one.
25:                 *************************************************************************/
26:                void TestCases(void) {
009916  781F88     MOV W8, [W15++]
27:                    static unsigned int pinNum = 0;
28:                    static BOOL lastClockState = 0;
29:                    BOOL clockState;
30:                
31:                    clockState = _PGC;
009918  BFC2CA     MOV.B PORTB, WREG
00991A  DE0046     LSR W0, #6, W0
00991C  600061     AND W0, #0x1, W0
00991E  FB8400     ZE W0, W8
32:                
33:                    if (clockState == 1 && lastClockState == 0) {
009920  504FE1     SUB.B W0, #0x1, [W15]
009922  3A00AB     BRA NZ, 0x9A7A
009924  E20F26     CP0 lastClockState
009926  3A00A9     BRA NZ, 0x9A7A
34:                        UART2PrintString("Test Case: ");
009928  29F520     MOV #0x9F52, W0
00992A  07FEA9     RCALL UART2PrintString
35:                        UART2PutDecInt(pinNum);
00992C  807940     MOV pinNum, W0
00992E  07FEF5     RCALL UART2PutDecInt
36:                        UART2PrintString("\n\r");
009930  29F5E0     MOV #0x9F5E, W0
009932  07FEA5     RCALL UART2PrintString
37:                
38:                        //Disable Pull-up on RD11 Slave Select;
39:                        CNPU4bits.CN56PUE = 0;
009934  A90073     BCLR 0x73, #0
40:                
41:                        //Set all pins to inputs in case of shorting
42:                        TRISB = 0xFFFF;
009936  EB8000     SETM W0
009938  881640     MOV W0, TRISB
43:                        TRISC = 0xFFFF;
00993A  881680     MOV W0, TRISC
44:                        TRISD = 0xFFFF;
00993C  8816C0     MOV W0, TRISD
45:                        TRISE = 0xFFFF;
00993E  881700     MOV W0, TRISE
46:                        TRISF = 0xFFFF;
009940  881740     MOV W0, TRISF
47:                        TRISG = 0xFFFF;
009942  881780     MOV W0, TRISG
48:                
49:                        LATB = 0;
009944  EB0000     CLR W0
009946  881660     MOV W0, LATB
50:                        LATC = 0;
009948  8816A0     MOV W0, LATC
51:                        LATD = 0;
00994A  8816E0     MOV W0, LATD
52:                        LATE = 0;
00994C  881720     MOV W0, LATE
53:                        LATF = 0;
00994E  881760     MOV W0, LATF
54:                        LATG = 0;
009950  8817A0     MOV W0, LATG
55:                
56:                        switch (pinNum) {
009952  807940     MOV pinNum, W0
009954  B80161     MUL.UU W0, #1, W2
009956  200221     MOV #0x22, W1
009958  510F81     SUB W2, W1, [W15]
00995A  598FE0     SUBB W3, #0x0, [W15]
00995C  3E008C     BRA GTU, 0x9A76
00995E  016002     BRA W2
009960  370022     BRA 0x99A6
009962  370024     BRA 0x99AC
009964  370026     BRA 0x99B2
009966  370028     BRA 0x99B8
009968  37002A     BRA 0x99BE
00996A  37002C     BRA 0x99C4
00996C  37002E     BRA 0x99CA
00996E  370030     BRA 0x99D0
009970  370032     BRA 0x99D6
009972  370034     BRA 0x99DC
009974  370036     BRA 0x99E2
009976  370038     BRA 0x99E8
009978  37003A     BRA 0x99EE
00997A  37003C     BRA 0x99F4
00997C  37003E     BRA 0x99FA
00997E  370040     BRA 0x9A00
009980  370042     BRA 0x9A06
009982  370044     BRA 0x9A0C
009984  370046     BRA 0x9A12
009986  370048     BRA 0x9A18
009988  37004A     BRA 0x9A1E
00998A  37004C     BRA 0x9A24
00998C  37004E     BRA 0x9A2A
00998E  370050     BRA 0x9A30
009990  370052     BRA 0x9A36
009992  370054     BRA 0x9A3C
009994  370056     BRA 0x9A42
009996  370058     BRA 0x9A48
009998  37005A     BRA 0x9A4E
00999A  37005C     BRA 0x9A54
00999C  37005E     BRA 0x9A5A
00999E  370060     BRA 0x9A60
0099A0  370062     BRA 0x9A66
0099A2  370064     BRA 0x9A6C
0099A4  370066     BRA 0x9A72
57:                            case 0: //PWM0
58:                                _TRISG6 = 0;
0099A6  A9C2F0     BCLR TRISG, #6
59:                                _LATG6 = 1;
0099A8  A8C2F4     BSET LATG, #6
0099AA  370065     BRA 0x9A76
60:                                break;
61:                            case 1: //PWM1
62:                                _TRISG7 = 0;
0099AC  A9E2F0     BCLR TRISG, #7
63:                                _LATG7 = 1;
0099AE  A8E2F4     BSET LATG, #7
0099B0  370062     BRA 0x9A76
64:                                break;
65:                            case 2: //PWM2
66:                                _TRISG8 = 0;
0099B2  A902F1     BCLR 0x2F1, #0
67:                                _LATG8 = 1;
0099B4  A802F5     BSET 0x2F5, #0
0099B6  37005F     BRA 0x9A76
68:                                break;
69:                            case 3: //PWM3
70:                                _TRISG9 = 0;
0099B8  A922F1     BCLR 0x2F1, #1
71:                                _LATG9 = 1;
0099BA  A822F5     BSET 0x2F5, #1
0099BC  37005C     BRA 0x9A76
72:                                break;
73:                            case 4: //PWM4
74:                                _TRISB5 = 0;
0099BE  A9A2C8     BCLR TRISB, #5
75:                                _LATB5 = 1;
0099C0  A8A2CC     BSET LATB, #5
0099C2  370059     BRA 0x9A76
76:                                break;
77:                            case 5: //PWM5
78:                                _TRISB4 = 0;
0099C4  A982C8     BCLR TRISB, #4
79:                                _LATB4 = 1;
0099C6  A882CC     BSET LATB, #4
0099C8  370056     BRA 0x9A76
80:                                break;
81:                            case 6: //PWM6
82:                                _TRISB2 = 0;
0099CA  A942C8     BCLR TRISB, #2
83:                                _LATB2 = 1;
0099CC  A842CC     BSET LATB, #2
0099CE  370053     BRA 0x9A76
84:                                break;
85:                            case 7: //PWM7
86:                                _TRISB1 = 0;
0099D0  A922C8     BCLR TRISB, #1
87:                                _LATB1 = 1;
0099D2  A822CC     BSET LATB, #1
0099D4  370050     BRA 0x9A76
88:                                break;
89:                            case 8: //PWM8
90:                                _TRISB0 = 0;
0099D6  A902C8     BCLR TRISB, #0
91:                                _LATB0 = 1;
0099D8  A802CC     BSET LATB, #0
0099DA  37004D     BRA 0x9A76
92:                                break;
93:                            case 9: //PWM9
94:                                _TRISB8 = 0;
0099DC  A902C9     BCLR 0x2C9, #0
95:                                _LATB8 = 1;
0099DE  A802CD     BSET 0x2CD, #0
0099E0  37004A     BRA 0x9A76
96:                                break;
97:                            case 10: //RumbleL
98:                                _TRISB10 = 0;
0099E2  A942C9     BCLR 0x2C9, #2
99:                                _LATB10 = 1;
0099E4  A842CD     BSET 0x2CD, #2
0099E6  370047     BRA 0x9A76
100:                               break;
101:                           case 11: //RumbleH
102:                               _TRISB11 = 0;
0099E8  A962C9     BCLR 0x2C9, #3
103:                               _LATB11 = 1;
0099EA  A862CD     BSET 0x2CD, #3
0099EC  370044     BRA 0x9A76
104:                               break;
105:                           case 12: //LED0
106:                               _TRISB12 = 0;
0099EE  A982C9     BCLR 0x2C9, #4
107:                               _LATB12 = 1;
0099F0  A882CD     BSET 0x2CD, #4
0099F2  370041     BRA 0x9A76
108:                               break;
109:                           case 13: //LED1
110:                               _TRISB13 = 0;
0099F4  A9A2C9     BCLR 0x2C9, #5
111:                               _LATB13 = 1;
0099F6  A8A2CD     BSET 0x2CD, #5
0099F8  37003E     BRA 0x9A76
112:                               break;
113:                           case 14: //B0
114:                               _TRISF3 = 0;
0099FA  A962E8     BCLR TRISF, #3
115:                               _LATF3 = 1;
0099FC  A862EC     BSET LATF, #3
0099FE  37003B     BRA 0x9A76
116:                               break;
117:                           case 15: //SCKIN
118:                               _TRISD8 = 0;
009A00  A902D9     BCLR 0x2D9, #0
119:                               _LATD8 = 1;
009A02  A802DD     BSET 0x2DD, #0
009A04  370038     BRA 0x9A76
120:                               break;
121:                           case 16: //SDI1
122:                               _TRISD9 = 0;
009A06  A922D9     BCLR 0x2D9, #1
123:                               _LATD9 = 1;
009A08  A822DD     BSET 0x2DD, #1
009A0A  370035     BRA 0x9A76
124:                               break;
125:                           case 17: //SDO1
126:                               _TRISD10 = 0;
009A0C  A942D9     BCLR 0x2D9, #2
127:                               _LATD10 = 1;
009A0E  A842DD     BSET 0x2DD, #2
009A10  370032     BRA 0x9A76
128:                               break;
129:                           case 18: //SSIN
130:                               _TRISD11 = 0;
009A12  A962D9     BCLR 0x2D9, #3
131:                               _LATD11 = 1;
009A14  A862DD     BSET 0x2DD, #3
009A16  37002F     BRA 0x9A76
132:                               break;
133:                           case 19: //B1
134:                               _TRISC13 = 0;
009A18  A9A2D1     BCLR 0x2D1, #5
135:                               _LATC13 = 1;
009A1A  A8A2D5     BSET 0x2D5, #5
009A1C  37002C     BRA 0x9A76
136:                               break;
137:                           case 20: //B2
138:                               _TRISC14 = 0;
009A1E  A9C2D1     BCLR 0x2D1, #6
139:                               _LATC14 = 1;
009A20  A8C2D5     BSET 0x2D5, #6
009A22  370029     BRA 0x9A76
140:                               break;
141:                           case 21: //B3
142:                               _TRISD1 = 0;
009A24  A922D8     BCLR TRISD, #1
143:                               _LATD1 = 1;
009A26  A822DC     BSET LATD, #1
009A28  370026     BRA 0x9A76
144:                               break;
145:                           case 22: //B4
146:                               _TRISD2 = 0;
009A2A  A942D8     BCLR TRISD, #2
147:                               _LATD2 = 1;
009A2C  A842DC     BSET LATD, #2
009A2E  370023     BRA 0x9A76
148:                               break;
149:                           case 23: //B5
150:                               _TRISD3 = 0;
009A30  A962D8     BCLR TRISD, #3
151:                               _LATD3 = 1;
009A32  A862DC     BSET LATD, #3
009A34  370020     BRA 0x9A76
152:                               break;
153:                           case 24: //B6
154:                               _TRISD4 = 0;
009A36  A982D8     BCLR TRISD, #4
155:                               _LATD4 = 1;
009A38  A882DC     BSET LATD, #4
009A3A  37001D     BRA 0x9A76
156:                               break;
157:                           case 25: //B7
158:                               _TRISD5 = 0;
009A3C  A9A2D8     BCLR TRISD, #5
159:                               _LATD5 = 1;
009A3E  A8A2DC     BSET LATD, #5
009A40  37001A     BRA 0x9A76
160:                               break;
161:                           case 26: //B8
162:                               _TRISD6 = 0;
009A42  A9C2D8     BCLR TRISD, #6
163:                               _LATD6 = 1;
009A44  A8C2DC     BSET LATD, #6
009A46  370017     BRA 0x9A76
164:                               break;
165:                           case 27: //B9
166:                               _TRISD7 = 0;
009A48  A9E2D8     BCLR TRISD, #7
167:                               _LATD7 = 1;
009A4A  A8E2DC     BSET LATD, #7
009A4C  370014     BRA 0x9A76
168:                               break;
169:                           case 28: //B10
170:                               _TRISF0 = 0;
009A4E  A902E8     BCLR TRISF, #0
171:                               _LATF0 = 1;
009A50  A802EC     BSET LATF, #0
009A52  370011     BRA 0x9A76
172:                               break;
173:                           case 29: //B11
174:                               _TRISF1 = 0;
009A54  A922E8     BCLR TRISF, #1
175:                               _LATF1 = 1;
009A56  A822EC     BSET LATF, #1
009A58  37000E     BRA 0x9A76
176:                               break;
177:                           case 30: //B12
178:                               _TRISE0 = 0;
009A5A  A902E0     BCLR TRISE, #0
179:                               _LATE0 = 1;
009A5C  A802E4     BSET LATE, #0
009A5E  37000B     BRA 0x9A76
180:                               break;
181:                           case 31: //B13
182:                               _TRISE1 = 0;
009A60  A922E0     BCLR TRISE, #1
183:                               _LATE1 = 1;
009A62  A822E4     BSET LATE, #1
009A64  370008     BRA 0x9A76
184:                               break;
185:                           case 32: //B14
186:                               _TRISE2 = 0;
009A66  A942E0     BCLR TRISE, #2
187:                               _LATE2 = 1;
009A68  A842E4     BSET LATE, #2
009A6A  370005     BRA 0x9A76
188:                               break;
189:                           case 33: //B15
190:                               _TRISE3 = 0;
009A6C  A962E0     BCLR TRISE, #3
191:                               _LATE3 = 1;
009A6E  A862E4     BSET LATE, #3
009A70  370002     BRA 0x9A76
192:                               break;
193:                           case 34: //B16
194:                               _TRISE4 = 0;
009A72  A982E0     BCLR TRISE, #4
195:                               _LATE4 = 1;
009A74  A882E4     BSET LATE, #4
196:                               break;
197:                           default:
198:                               break;
199:                       }
200:                       pinNum++;
009A76  E80000     INC W0, W0
009A78  887940     MOV W0, pinNum
201:                   }
202:                   lastClockState = clockState;
009A7A  887938     MOV W8, lastClockState
203:               }
009A7C  78044F     MOV [--W15], W8
009A7E  060000     RETURN
---  D:/PIC/PIC_PS4_Host/trunk/USB/usb_host_generic_PS4.c  ----------------------------------------------
1:                 //MODIFIED VERSION!
2:                 /******************************************************************************
3:                  
4:                   USB Host Generic Client Driver
5:                 
6:                 This is the Generic client driver file for a USB Embedded Host device.  This
7:                 driver should be used in a project with usb_host.c to provided the USB hardware
8:                 interface.
9:                 
10:                To interface with USB Embedded Host layer, the routine USBHostGenericInit()
11:                should be specified as the Initialize() function, and
12:                USBHostGenericEventHandler() should be specified as the EventHandler() function
13:                in the usbClientDrvTable[] array declared in usb_config.c.
14:                
15:                This driver can be configured to either use transfer events from usb_host.c or
16:                use a polling mechanism.  If USB_ENABLE_TRANSFER_EVENT is defined, this
17:                driver will utilize transfer events.  Otherwise, this driver will utilize
18:                polling.
19:                
20:                Since the generic class is performed with interrupt transfers,
21:                USB_SUPPORT_INTERRUPT_TRANSFERS must be defined.
22:                
23:                 *******************************************************************************/
24:                //DOM-IGNORE-BEGIN
25:                /******************************************************************************
26:                
27:                 * FileName:        usb_client_generic.c
28:                 * Dependencies:    None
29:                 * Processor:       PIC24/dsPIC30/dsPIC33/PIC32MX
30:                 * Compiler:        C30 v2.01/C32 v0.00.18
31:                 * Company:         Microchip Technology, Inc.
32:                
33:                Software License Agreement
34:                
35:                The software supplied herewith by Microchip Technology Incorporated
36:                (the CompanyE for its PICmicro Microcontroller is intended and
37:                supplied to you, the Companys customer, for use solely and
38:                exclusively on Microchip PICmicro Microcontroller products. The
39:                software is owned by the Company and/or its supplier, and is
40:                protected under applicable copyright laws. All rights are reserved.
41:                Any use in violation of the foregoing restrictions may subject the
42:                user to criminal sanctions under applicable laws, as well as to
43:                civil liability for the breach of the terms and conditions of this
44:                license.
45:                
46:                THIS SOFTWARE IS PROVIDED IN AN AS ISECONDITION. NO WARRANTIES,
47:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
48:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
49:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
50:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
51:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
52:                
53:                Author          Date    Comments
54:                --------------------------------------------------------------------------------
55:                BC/KO       25-Dec-2007 First release
56:                
57:                 *******************************************************************************/
58:                //DOM-IGNORE-END
59:                
60:                #include <stdlib.h>
61:                #include <string.h>
62:                #include "GenericTypeDefs.h"
63:                #include "USB/usb.h"
64:                #include "USB/usb_host_generic_PS4.h"
65:                #include "uart2.h"
66:                
67:                
68:                
69:                // *****************************************************************************
70:                // *****************************************************************************
71:                // Section: Configuration
72:                // *****************************************************************************
73:                // *****************************************************************************
74:                
75:                // *****************************************************************************
76:                /* Max Number of Supported Devices
77:                
78:                This value represents the maximum number of attached devices this class driver
79:                can support.  If the user does not define a value, it will be set to 1.
80:                Currently this must be set to 1, due to limitations in the USB Host layer.
81:                 */
82:                #ifndef USB_MAX_GENERIC_DEVICES
83:                #define USB_MAX_GENERIC_DEVICES     1
84:                #endif
85:                
86:                #if USB_MAX_GENERIC_DEVICES != 1
87:                #error The Generic client driver supports only one attached device.
88:                #endif
89:                
90:                // *****************************************************************************
91:                // *****************************************************************************
92:                // Section: Global Variables
93:                // *****************************************************************************
94:                // *****************************************************************************
95:                
96:                //Added by MH.
97:                GENERIC_DEVICE gc_DevData;
98:                static BYTE epInterruptIn = 0x81;
99:                static BYTE epInterruptOut = 0x01;
100:               static BYTE epBulkIn = 0x82;
101:               static BYTE epBulkOut = 0x02;
102:               static CONNECTED_DEVICE ConnectedDevice = NONE;
103:               
104:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
105:               #ifndef USB_GENERIC_MAX_SERIAL_NUMBER
106:               #define USB_GENERIC_MAX_SERIAL_NUMBER   64
107:               #endif
108:               
109:               WORD serialNumbers[USB_MAX_GENERIC_DEVICES][USB_GENERIC_MAX_SERIAL_NUMBER];
110:               #endif
111:               
112:               
113:               // *****************************************************************************
114:               // *****************************************************************************
115:               // Section: Host Stack Interface Functions
116:               // *****************************************************************************
117:               // *****************************************************************************
118:               
119:               /****************************************************************************
120:                 Function:
121:                   BOOL USBHostGenericInit ( BYTE address, DWORD flags, BYTE clientDriverID )
122:               
123:                 Summary:
124:                   This function is called by the USB Embedded Host layer when a "generic"
125:                   device attaches.
126:               
127:                 Description:
128:                   This routine is a call out from the USB Embedded Host layer to the USB
129:                   generic client driver.  It is called when a "generic" device has been
130:                   connected to the host.  Its purpose is to initialize and activate the USB
131:                   Generic client driver.
132:               
133:                 Preconditions:
134:                   The device has been configured.
135:               
136:                 Parameters:
137:                   BYTE address    - Device's address on the bus
138:                   DWORD flags     - Initialization flags
139:                   BYTE clientDriverID - ID to send when issuing a Device Request via
140:                                           USBHostIssueDeviceRequest(), USBHostSetDeviceConfiguration(),
141:                                           or USBHostSetDeviceInterface().  
142:               
143:                 Return Values:
144:                   TRUE    - Initialization was successful
145:                   FALSE   - Initialization failed
146:               
147:                 Remarks:
148:                   Multiple client drivers may be used in a single application.  The USB
149:                   Embedded Host layer will call the initialize routine required for the
150:                   attached device.
151:                ***************************************************************************/
152:               
153:               BOOL USBHostGenericInitBT(BYTE address, DWORD flags, BYTE clientDriverID) {
0092B8  BE9F88     MOV.D W8, [W15++]
0092BA  784400     MOV.B W0, W8
0092BC  784481     MOV.B W1, W9
154:                   BYTE *pDesc;
155:               
156:                   SetConnectedDeviceType(BLUETOOTH); //MH
0092BE  200010     MOV #0x1, W0
0092C0  0701BD     RCALL SetConnectedDeviceType
157:                   SetEpInterruptIn(0x81);
0092C2  B3C810     MOV.B #0x81, W0
0092C4  0701B1     RCALL SetEpInterruptIn
158:                   SetEpInterruptOut(0x01);
0092C6  B3C010     MOV.B #0x1, W0
0092C8  0701B1     RCALL SetEpInterruptOut
159:                   SetEpBulkIn(0x82);
0092CA  B3C820     MOV.B #0x82, W0
0092CC  0701B1     RCALL SetEpBulkIn
160:                   SetEpBulkOut(0x02);
0092CE  B3C020     MOV.B #0x2, W0
0092D0  0701B1     RCALL SetEpBulkOut
161:               
162:                   // Initialize state
163:                   gc_DevData.rx1Length = 0;
0092D2  B80060     MUL.UU W0, #0, W0
0092D4  887580     MOV W0, 0xEB0
0092D6  887591     MOV W1, 0xEB2
164:                   gc_DevData.rx2Length = 0;
0092D8  8875A0     MOV W0, 0xEB4
0092DA  8875B1     MOV W1, 0xEB6
165:                   gc_DevData.flags.val = 0;
0092DC  EF6EB9     CLR.B 0xEB9
166:               
167:                   // Save device the address, VID, & PID
168:                   gc_DevData.ID.deviceAddress = address;
0092DE  780008     MOV W8, W0
0092E0  B7EEAE     MOV.B WREG, 0xEAE
169:                   pDesc = USBHostGetDeviceDescriptor(address);
0092E2  8078E2     MOV 0xF1C, W2
170:                   pDesc += 8;
171:                   gc_DevData.ID.vid = (WORD) * pDesc;
0092E4  904882     MOV.B [W2+8], W1
0092E6  FB8081     ZE W1, W1
0092E8  887551     MOV W1, gc_DevData
172:                   pDesc++;
173:                   gc_DevData.ID.vid |= ((WORD) * pDesc) << 8;
0092EA  904812     MOV.B [W2+9], W0
0092EC  DD0048     SL W0, #8, W0
0092EE  708080     IOR W1, W0, W1
0092F0  887551     MOV W1, gc_DevData
174:                   pDesc++;
175:                   gc_DevData.ID.pid = (WORD) * pDesc;
0092F2  9048A2     MOV.B [W2+10], W1
0092F4  FB8081     ZE W1, W1
0092F6  887561     MOV W1, 0xEAC
176:                   pDesc++;
177:                   gc_DevData.ID.pid |= ((WORD) * pDesc) << 8;
0092F8  904832     MOV.B [W2+11], W0
0092FA  DD0048     SL W0, #8, W0
0092FC  708080     IOR W1, W0, W1
0092FE  887561     MOV W1, 0xEAC
178:                   pDesc++;
179:               
180:                   // Save the Client Driver ID
181:                   gc_DevData.clientDriverID = clientDriverID;
009300  780009     MOV W9, W0
009302  B7EEB8     MOV.B WREG, 0xEB8
182:               #ifdef DEBUG_MODE
183:                   UART2PrintString("HOST: USB BLUETOOTH INIT.\r\n"); //MH
184:                   UART2PrintString("GEN: USB Generic Client Initalized: flags=0x");
185:                   UART2PutHex(flags);
186:                   UART2PrintString(" address=");
187:                   UART2PutDec(address);
188:                   UART2PrintString(" VID=0x");
189:                   UART2PutHex(gc_DevData.ID.vid >> 8);
190:                   UART2PutHex(gc_DevData.ID.vid & 0xFF);
191:                   UART2PrintString(" PID=0x");
192:                   UART2PutHex(gc_DevData.ID.pid >> 8);
193:                   UART2PutHex(gc_DevData.ID.pid & 0xFF);
194:                   UART2PrintString("\r\n");
195:               #endif
196:               
197:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
198:                   {
199:                       BYTE *deviceDescriptor;
200:                       BYTE serialNumberIndex;
201:               
202:                       // TODO when multiple devices are implemented, this init will change
203:                       // to find a free slot
204:                       gc_DevData.flags.serialNumberValid = 0;
205:               
206:                       gc_DevData.ID.serialNumber = &(serialNumbers[0][0]);
207:                       gc_DevData.ID.serialNumberLength = 0;
208:               
209:                       deviceDescriptor = USBHostGetDeviceDescriptor(deviceAddress);
210:                       serialNumberIndex = deviceDescriptor[16];
211:               
212:                       if (serialNumberIndex) {
213:               #ifdef DEBUG_MODE
214:                           UART2PrintString("GEN: Getting serial number...\r\n");
215:               #endif
216:                       } else {
217:                           serialNumberIndex = 1;
218:               #ifdef DEBUG_MODE
219:                           UART2PrintString("GEN: Getting string descriptor...\r\n");
220:               #endif
221:                       }
222:               
223:                       if (USBHostGetStringDescriptor(address, serialNumberIndex, (BYTE *) gc_DevData.ID.serialNumber, USB_GENERIC_MAX_SERIAL_NUMBER * 2)) {
224:                           // We can't get the serial number.  Just set the pointer to null
225:                           // and call it good.  We have to call the SN valid so we don't get trapped
226:                           // in the event handler.
227:                           gc_DevData.ID.serialNumber = NULL;
228:                           gc_DevData.flags.initialized = 1;
229:                           gc_DevData.flags.serialNumberValid = 1;
230:               
231:                           // Tell the application layer that we have a device.
232:                           USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
233:               
234:               #ifdef DEBUG_MODE
235:                           UART2PrintString("GEN: Cannot get string descriptor!\r\n");
236:               #endif
237:                       }
238:                   }
239:               #else
240:                   // Generic Client Driver Init Complete.
241:                   gc_DevData.flags.initialized = 1;
009304  A80EB9     BSET 0xEB9, #0
242:               
243:                   // Notify that application that we've been attached to a device.
244:                   USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
009306  200064     MOV #0x6, W4
009308  200005     MOV #0x0, W5
00930A  20EAA2     MOV #0xEAA, W2
00930C  201901     MOV #0x190, W1
00930E  784008     MOV.B W8, W0
009310  07F436     RCALL USB_ApplicationEventHandler
245:               #endif
246:               
247:                   // TBD
248:               
249:                   return TRUE;
250:               
251:               } // USBHostGenericInit
009312  200010     MOV #0x1, W0
009314  BE044F     MOV.D [--W15], W8
009316  060000     RETURN
252:               
253:               BOOL USBHostGenericInitWire(BYTE address, DWORD flags, BYTE clientDriverID) {
009318  BE9F88     MOV.D W8, [W15++]
00931A  784400     MOV.B W0, W8
00931C  784481     MOV.B W1, W9
254:                   BYTE *pDesc;
255:               
256:                   SetConnectedDeviceType(CONTROLLER); //MH
00931E  200020     MOV #0x2, W0
009320  07018D     RCALL SetConnectedDeviceType
257:                   SetEpInterruptIn(0x84);
009322  B3C840     MOV.B #0x84, W0
009324  070181     RCALL SetEpInterruptIn
258:                   SetEpInterruptOut(0x03);
009326  B3C030     MOV.B #0x3, W0
009328  070181     RCALL SetEpInterruptOut
259:               
260:                   // Initialize state
261:                   gc_DevData.rx1Length = 0;
00932A  B80060     MUL.UU W0, #0, W0
00932C  887580     MOV W0, 0xEB0
00932E  887591     MOV W1, 0xEB2
262:                   gc_DevData.rx2Length = 0;
009330  8875A0     MOV W0, 0xEB4
009332  8875B1     MOV W1, 0xEB6
263:                   gc_DevData.flags.val = 0;
009334  EF6EB9     CLR.B 0xEB9
264:               
265:                   // Save device the address, VID, & PID
266:                   gc_DevData.ID.deviceAddress = address;
009336  780008     MOV W8, W0
009338  B7EEAE     MOV.B WREG, 0xEAE
267:                   pDesc = USBHostGetDeviceDescriptor(address);
00933A  8078E2     MOV 0xF1C, W2
268:                   pDesc += 8;
269:                   gc_DevData.ID.vid = (WORD) * pDesc;
00933C  904882     MOV.B [W2+8], W1
00933E  FB8081     ZE W1, W1
009340  887551     MOV W1, gc_DevData
270:                   pDesc++;
271:                   gc_DevData.ID.vid |= ((WORD) * pDesc) << 8;
009342  904812     MOV.B [W2+9], W0
009344  DD0048     SL W0, #8, W0
009346  708080     IOR W1, W0, W1
009348  887551     MOV W1, gc_DevData
272:                   pDesc++;
273:                   gc_DevData.ID.pid = (WORD) * pDesc;
00934A  9048A2     MOV.B [W2+10], W1
00934C  FB8081     ZE W1, W1
00934E  887561     MOV W1, 0xEAC
274:                   pDesc++;
275:                   gc_DevData.ID.pid |= ((WORD) * pDesc) << 8;
009350  904832     MOV.B [W2+11], W0
009352  DD0048     SL W0, #8, W0
009354  708080     IOR W1, W0, W1
009356  887561     MOV W1, 0xEAC
276:                   pDesc++;
277:               
278:                   // Save the Client Driver ID
279:                   gc_DevData.clientDriverID = clientDriverID;
009358  780009     MOV W9, W0
00935A  B7EEB8     MOV.B WREG, 0xEB8
280:               
281:               #ifdef DEBUG_MODE
282:                   UART2PrintString("HOST: USB WIRE INIT.\r\n"); //MH
283:                   UART2PrintString("GEN: USB Controller Client Initalized: flags=0x");
284:                   UART2PutHex(flags);
285:                   UART2PrintString(" address=");
286:                   UART2PutDec(address);
287:                   UART2PrintString(" VID=0x");
288:                   UART2PutHex(gc_DevData.ID.vid >> 8);
289:                   UART2PutHex(gc_DevData.ID.vid & 0xFF);
290:                   UART2PrintString(" PID=0x");
291:                   UART2PutHex(gc_DevData.ID.pid >> 8);
292:                   UART2PutHex(gc_DevData.ID.pid & 0xFF);
293:                   UART2PrintString("\r\n");
294:               #endif
295:               
296:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
297:                   {
298:                       BYTE *deviceDescriptor;
299:                       BYTE serialNumberIndex;
300:               
301:                       // TODO when multiple devices are implemented, this init will change
302:                       // to find a free slot
303:                       gc_DevData.flags.serialNumberValid = 0;
304:               
305:                       gc_DevData.ID.serialNumber = &(serialNumbers[0][0]);
306:                       gc_DevData.ID.serialNumberLength = 0;
307:               
308:                       deviceDescriptor = USBHostGetDeviceDescriptor(deviceAddress);
309:                       serialNumberIndex = deviceDescriptor[16];
310:               
311:                       if (serialNumberIndex) {
312:               #ifdef DEBUG_MODE
313:                           UART2PrintString("GEN: Getting serial number...\r\n");
314:               #endif
315:                       } else {
316:                           serialNumberIndex = 1;
317:               #ifdef DEBUG_MODE
318:                           UART2PrintString("GEN: Getting string descriptor...\r\n");
319:               #endif
320:                       }
321:               
322:                       if (USBHostGetStringDescriptor(address, serialNumberIndex, (BYTE *) gc_DevData.ID.serialNumber, USB_GENERIC_MAX_SERIAL_NUMBER * 2)) {
323:                           // We can't get the serial number.  Just set the pointer to null
324:                           // and call it good.  We have to call the SN valid so we don't get trapped
325:                           // in the event handler.
326:                           gc_DevData.ID.serialNumber = NULL;
327:                           gc_DevData.flags.initialized = 1;
328:                           gc_DevData.flags.serialNumberValid = 1;
329:               
330:                           // Tell the application layer that we have a device.
331:                           USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
332:               
333:               #ifdef DEBUG_MODE
334:                           UART2PrintString("GEN: Cannot get string descriptor!\r\n");
335:               #endif
336:                       }
337:                   }
338:               #else
339:                   // Generic Client Driver Init Complete.
340:                   gc_DevData.flags.initialized = 1;
00935C  A80EB9     BSET 0xEB9, #0
341:               
342:                   // Notify that application that we've been attached to a device.
343:                   USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
00935E  200064     MOV #0x6, W4
009360  200005     MOV #0x0, W5
009362  20EAA2     MOV #0xEAA, W2
009364  201901     MOV #0x190, W1
009366  784008     MOV.B W8, W0
009368  07F40A     RCALL USB_ApplicationEventHandler
344:               #endif
345:               
346:                   // TBD
347:               
348:                   return TRUE;
349:               
350:               } // USBHostGenericInit
00936A  200010     MOV #0x1, W0
00936C  BE044F     MOV.D [--W15], W8
00936E  060000     RETURN
351:               
352:               
353:               BOOL USBHostInitSpaceNavigator(BYTE address, DWORD flags, BYTE clientDriverID) {
009370  BE9F88     MOV.D W8, [W15++]
009372  784400     MOV.B W0, W8
009374  784481     MOV.B W1, W9
354:                   BYTE *pDesc;
355:                   UART2PrintString("Init 3D Mouse\n\r");
009376  29F420     MOV #0x9F42, W0
009378  070182     RCALL UART2PrintString
356:                   
357:                   SetConnectedDeviceType(SPACE_MOUSE); //MH
00937A  200030     MOV #0x3, W0
00937C  07015F     RCALL SetConnectedDeviceType
358:                   SetEpInterruptIn(0x81);
00937E  B3C810     MOV.B #0x81, W0
009380  070153     RCALL SetEpInterruptIn
359:                   SetEpInterruptOut(0x02);
009382  B3C020     MOV.B #0x2, W0
009384  070153     RCALL SetEpInterruptOut
360:               
361:                   // Initialize state
362:                   gc_DevData.rx1Length = 0;
009386  EF2EB0     CLR 0xEB0
009388  EF2EB2     CLR 0xEB2
363:                   gc_DevData.flags.val = 0;
00938A  EF6EB9     CLR.B 0xEB9
364:               
365:                   // Save device the address, VID, & PID
366:                   gc_DevData.ID.deviceAddress = address;
00938C  780008     MOV W8, W0
00938E  B7EEAE     MOV.B WREG, 0xEAE
367:                   pDesc = USBHostGetDeviceDescriptor(address);
009390  8078E2     MOV 0xF1C, W2
368:                   pDesc += 8;
369:                   gc_DevData.ID.vid = (WORD) * pDesc;
009392  904882     MOV.B [W2+8], W1
009394  FB8081     ZE W1, W1
009396  887551     MOV W1, gc_DevData
370:                   pDesc++;
371:                   gc_DevData.ID.vid |= ((WORD) * pDesc) << 8;
009398  904812     MOV.B [W2+9], W0
00939A  DD0048     SL W0, #8, W0
00939C  708080     IOR W1, W0, W1
00939E  887551     MOV W1, gc_DevData
372:                   pDesc++;
373:                   gc_DevData.ID.pid = (WORD) * pDesc;
0093A0  9048A2     MOV.B [W2+10], W1
0093A2  FB8081     ZE W1, W1
0093A4  887561     MOV W1, 0xEAC
374:                   pDesc++;
375:                   gc_DevData.ID.pid |= ((WORD) * pDesc) << 8;
0093A6  904832     MOV.B [W2+11], W0
0093A8  DD0048     SL W0, #8, W0
0093AA  708080     IOR W1, W0, W1
0093AC  887561     MOV W1, 0xEAC
376:                   pDesc++;
377:               
378:                   // Save the Client Driver ID
379:                   gc_DevData.clientDriverID = clientDriverID;
0093AE  780009     MOV W9, W0
0093B0  B7EEB8     MOV.B WREG, 0xEB8
380:               
381:               #ifdef DEBUG_MODE
382:                   UART2PrintString("HOST: USB WIRE INIT.\r\n"); //MH
383:                   UART2PrintString("GEN: USB Controller Client Initalized: flags=0x");
384:                   UART2PutHex(flags);
385:                   UART2PrintString(" address=");
386:                   UART2PutDec(address);
387:                   UART2PrintString(" VID=0x");
388:                   UART2PutHex(gc_DevData.ID.vid >> 8);
389:                   UART2PutHex(gc_DevData.ID.vid & 0xFF);
390:                   UART2PrintString(" PID=0x");
391:                   UART2PutHex(gc_DevData.ID.pid >> 8);
392:                   UART2PutHex(gc_DevData.ID.pid & 0xFF);
393:                   UART2PrintString("\r\n");
394:               #endif
395:               
396:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
397:                   {
398:                       BYTE *deviceDescriptor;
399:                       BYTE serialNumberIndex;
400:               
401:                       // TODO when multiple devices are implemented, this init will change
402:                       // to find a free slot
403:                       gc_DevData.flags.serialNumberValid = 0;
404:               
405:                       gc_DevData.ID.serialNumber = &(serialNumbers[0][0]);
406:                       gc_DevData.ID.serialNumberLength = 0;
407:               
408:                       deviceDescriptor = USBHostGetDeviceDescriptor(deviceAddress);
409:                       serialNumberIndex = deviceDescriptor[16];
410:               
411:                       if (serialNumberIndex) {
412:               #ifdef DEBUG_MODE
413:                           UART2PrintString("GEN: Getting serial number...\r\n");
414:               #endif
415:                       } else {
416:                           serialNumberIndex = 1;
417:               #ifdef DEBUG_MODE
418:                           UART2PrintString("GEN: Getting string descriptor...\r\n");
419:               #endif
420:                       }
421:               
422:                       if (USBHostGetStringDescriptor(address, serialNumberIndex, (BYTE *) gc_DevData.ID.serialNumber, USB_GENERIC_MAX_SERIAL_NUMBER * 2)) {
423:                           // We can't get the serial number.  Just set the pointer to null
424:                           // and call it good.  We have to call the SN valid so we don't get trapped
425:                           // in the event handler.
426:                           gc_DevData.ID.serialNumber = NULL;
427:                           gc_DevData.flags.initialized = 1;
428:                           gc_DevData.flags.serialNumberValid = 1;
429:               
430:                           // Tell the application layer that we have a device.
431:                           USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
432:               
433:               #ifdef DEBUG_MODE
434:                           UART2PrintString("GEN: Cannot get string descriptor!\r\n");
435:               #endif
436:                       }
437:                   }
438:               #else
439:                   // Generic Client Driver Init Complete.
440:                   gc_DevData.flags.initialized = 1;
0093B2  A80EB9     BSET 0xEB9, #0
441:               
442:                   // Notify that application that we've been attached to a device.
443:                   USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
0093B4  200064     MOV #0x6, W4
0093B6  200005     MOV #0x0, W5
0093B8  20EAA2     MOV #0xEAA, W2
0093BA  201901     MOV #0x190, W1
0093BC  784008     MOV.B W8, W0
0093BE  07F3DF     RCALL USB_ApplicationEventHandler
444:               #endif
445:               
446:                   // TBD
447:               
448:                   return TRUE;
449:               
450:               } // USBHostGenericInit
0093C0  200010     MOV #0x1, W0
0093C2  BE044F     MOV.D [--W15], W8
0093C4  060000     RETURN
451:               
452:               /****************************************************************************
453:                 Function:
454:                   BOOL USBHostGenericEventHandler ( BYTE address, USB_EVENT event,
455:                                           void *data, DWORD size )
456:               
457:                 Summary:
458:                   This routine is called by the Host layer to notify the general client of
459:                   events that occur.
460:               
461:                 Description:
462:                   This routine is called by the Host layer to notify the general client of
463:                   events that occur.  If the event is recognized, it is handled and the
464:                   routine returns TRUE.  Otherwise, it is ignored and the routine returns
465:                   FALSE.
466:               
467:                 Preconditions:
468:                   None
469:               
470:                 Parameters:
471:                   BYTE address    - Address of device with the event
472:                   USB_EVENT event - The bus event that occured
473:                   void *data      - Pointer to event-specific data
474:                   DWORD size      - Size of the event-specific data
475:               
476:                 Return Values:
477:                   TRUE    - The event was handled
478:                   FALSE   - The event was not handled
479:               
480:                 Remarks:
481:                   None
482:                ***************************************************************************/
483:               
484:               BOOL USBHostGenericEventHandler(BYTE address, USB_EVENT event, void *data, DWORD size) {
0093C6  FA0004     LNK #0x4
485:                   // Make sure it was for our device
486:                   if (address != gc_DevData.ID.deviceAddress) {
0093C8  20EAE3     MOV #0xEAE, W3
0093CA  784193     MOV.B [W3], W3
0093CC  51CF80     SUB.B W3, W0, [W15]
0093CE  3A0051     BRA NZ, 0x9472
487:                       return FALSE;
488:                   }
489:               
490:                   // Handle specific events.
491:                   switch (event) {
0093D0  200710     MOV #0x71, W0
0093D2  508F80     SUB W1, W0, [W15]
0093D4  320004     BRA Z, 0x93DE
0093D6  E80000     INC W0, W0
0093D8  508F80     SUB W1, W0, [W15]
0093DA  3A004B     BRA NZ, 0x9472
0093DC  37000B     BRA 0x93F4
492:                       case EVENT_DETACH:
493:                           // Notify that application that the device has been detached.
494:                           USB_HOST_APP_EVENT_HANDLER(gc_DevData.ID.deviceAddress, EVENT_GENERIC_DETACH, &gc_DevData.ID.deviceAddress, sizeof (BYTE));
0093DE  200014     MOV #0x1, W4
0093E0  200005     MOV #0x0, W5
0093E2  20EAE2     MOV #0xEAE, W2
0093E4  201911     MOV #0x191, W1
0093E6  784003     MOV.B W3, W0
0093E8  07F3CA     RCALL USB_ApplicationEventHandler
495:                           gc_DevData.flags.val = 0;
0093EA  EB4000     CLR.B W0
0093EC  B7EEB9     MOV.B WREG, 0xEB9
0093EE  B7EEAE     MOV.B WREG, 0xEAE
496:                           gc_DevData.ID.deviceAddress = 0;
0093F0  200010     MOV #0x1, W0
0093F2  370040     BRA 0x9474
497:               #ifdef DEBUG_MODE
498:                           UART2PrintString("USB Generic Client Device Detached: address=");
499:                           UART2PutDec(address);
500:                           UART2PrintString("\r\n");
501:               #endif
502:                           return TRUE;
503:               
504:               #ifdef USB_ENABLE_TRANSFER_EVENT
505:                       case EVENT_TRANSFER:
506:                           if ((data != NULL) && (size == sizeof (HOST_TRANSFER_DATA))) {
0093F4  E00002     CP0 W2
0093F6  32003D     BRA Z, 0x9472
0093F8  520FEA     SUB W4, #0xA, [W15]
0093FA  5A8FE0     SUBB W5, #0x0, [W15]
0093FC  3A003A     BRA NZ, 0x9472
507:                               DWORD dataCount = ((HOST_TRANSFER_DATA *) data)->dataCount;
0093FE  BE0212     MOV.D [W2], W4
009400  9FBFE4     MOV W4, [W15-4]
009402  9FBFF5     MOV W5, [W15-2]
508:               
509:                               if (((HOST_TRANSFER_DATA *) data)->bEndpointAddress == (USB_IN_EP | epInterruptIn))//YTS
009404  9040E2     MOV.B [W2+6], W1
009406  BFCF1E     MOV.B 0xF1E, WREG
009408  A07400     BSET.B W0, #7
00940A  50CF80     SUB.B W1, W0, [W15]
00940C  3A000B     BRA NZ, 0x9424
510:                               {
511:                                   gc_DevData.flags.rx1Busy = 0;
00940E  A96EB9     BCLR 0xEB9, #3
512:                                   gc_DevData.rx1Length = dataCount;
009410  887584     MOV W4, 0xEB0
009412  887595     MOV W5, 0xEB2
513:                                   USB_HOST_APP_EVENT_HANDLER(gc_DevData.ID.deviceAddress, EVENT_GENERIC_RX1_DONE, &dataCount, sizeof (DWORD));
009414  BFCEAE     MOV.B 0xEAE, WREG
009416  200044     MOV #0x4, W4
009418  200005     MOV #0x0, W5
00941A  578164     SUB W15, #0x4, W2
00941C  201931     MOV #0x193, W1
00941E  07F3AF     RCALL USB_ApplicationEventHandler
009420  200010     MOV #0x1, W0
009422  370028     BRA 0x9474
514:                               } else if (((HOST_TRANSFER_DATA *) data)->bEndpointAddress == (USB_IN_EP | epBulkIn))//YTS
009424  BFCF20     MOV.B 0xF20, WREG
009426  A07400     BSET.B W0, #7
009428  50CF80     SUB.B W1, W0, [W15]
00942A  3A000B     BRA NZ, 0x9442
515:                               {
516:                                   gc_DevData.flags.rx2Busy = 0;
00942C  A98EB9     BCLR 0xEB9, #4
517:                                   gc_DevData.rx2Length = dataCount;
00942E  8875A4     MOV W4, 0xEB4
009430  8875B5     MOV W5, 0xEB6
518:                                   USB_HOST_APP_EVENT_HANDLER(gc_DevData.ID.deviceAddress, EVENT_GENERIC_RX2_DONE, &dataCount, sizeof (DWORD));
009432  BFCEAE     MOV.B 0xEAE, WREG
009434  200044     MOV #0x4, W4
009436  200005     MOV #0x0, W5
009438  578164     SUB W15, #0x4, W2
00943A  201941     MOV #0x194, W1
00943C  07F3A0     RCALL USB_ApplicationEventHandler
00943E  200010     MOV #0x1, W0
009440  370019     BRA 0x9474
519:                               }
520:                               else if (((HOST_TRANSFER_DATA *) data)->bEndpointAddress == (USB_OUT_EP | epInterruptOut))//YTS
009442  BFCF1F     MOV.B 0xF1F, WREG
009444  E10C00     CP.B W1, W0
009446  3A0009     BRA NZ, 0x945A
521:                               {
522:                                   gc_DevData.flags.txBusy = 0;
009448  A92EB9     BCLR 0xEB9, #1
523:                                   USB_HOST_APP_EVENT_HANDLER(gc_DevData.ID.deviceAddress, EVENT_GENERIC_TX_DONE, &dataCount, sizeof (DWORD));
00944A  BFCEAE     MOV.B 0xEAE, WREG
00944C  200044     MOV #0x4, W4
00944E  200005     MOV #0x0, W5
009450  578164     SUB W15, #0x4, W2
009452  201921     MOV #0x192, W1
009454  07F394     RCALL USB_ApplicationEventHandler
009456  200010     MOV #0x1, W0
009458  37000D     BRA 0x9474
524:                               } else if (((HOST_TRANSFER_DATA *) data)->bEndpointAddress == (USB_OUT_EP | epBulkOut)) {
00945A  BFCF21     MOV.B 0xF21, WREG
00945C  E10C00     CP.B W1, W0
00945E  3A0009     BRA NZ, 0x9472
525:                                   gc_DevData.flags.tx2Busy = 0;
009460  A94EB9     BCLR 0xEB9, #2
526:                                   USB_HOST_APP_EVENT_HANDLER(gc_DevData.ID.deviceAddress, EVENT_GENERIC_TX2_DONE, &dataCount, sizeof (DWORD));
009462  BFCEAE     MOV.B 0xEAE, WREG
009464  200044     MOV #0x4, W4
009466  200005     MOV #0x0, W5
009468  578164     SUB W15, #0x4, W2
00946A  201951     MOV #0x195, W1
00946C  07F388     RCALL USB_ApplicationEventHandler
00946E  200010     MOV #0x1, W0
009470  370001     BRA 0x9474
009472  EB0000     CLR W0
527:                               } else
528:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
529:                                   if (((((HOST_TRANSFER_DATA *) data)->bEndpointAddress & 0x7F) == 0) && !gc_DevData.flags.serialNumberValid) {
530:               #ifdef DEBUG_MODE
531:                                   UART2PrintString("GEN: Got serial number!\r\n");
532:               #endif
533:                                   // Set the serial number information
534:                                   gc_DevData.ID.serialNumberLength = dataCount;
535:                                   gc_DevData.flags.serialNumberValid = 1;
536:                                   gc_DevData.flags.initialized = 1;
537:               
538:                                   // Tell the application layer that we have a device.
539:                                   USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
540:                               } else
541:               #endif
542:                               {
543:                                   return FALSE;
544:                               }
545:               
546:                               return TRUE;
547:               
548:                           } else
549:                               return FALSE;
550:               #endif
551:               
552:                       case EVENT_SUSPEND:
553:                       case EVENT_RESUME:
554:                       case EVENT_BUS_ERROR:
555:                       default:
556:                           break;
557:                   }
558:               
559:                   return FALSE;
560:               } // USBHostGenericEventHandler
009474  FA8000     ULNK
009476  060000     RETURN
561:               
562:               // *****************************************************************************
563:               // *****************************************************************************
564:               // Section: Application Callable Functions
565:               // *****************************************************************************
566:               // *****************************************************************************
567:               
568:               /****************************************************************************
569:                 Function:
570:                   BOOL USBHostGenericDeviceDetached( BYTE deviceAddress )
571:               
572:                 Description:
573:                   This interface is used to check if the devich has been detached from the
574:                   bus.
575:               
576:                 Preconditions:
577:                   None
578:               
579:                 Parameters:
580:                   deviceAddress     - USB Address of the device.
581:               
582:                 Return Values:
583:                   TRUE    - The device has been detached, or an invalid deviceAddress is given.
584:                   FALSE   - The device is attached
585:               
586:                 Example:
587:                   <code>
588:                   if (USBHostGenericDeviceDetached( deviceAddress ))
589:                   {
590:                       // Handle detach
591:                   }
592:                   </code>
593:               
594:                 Remarks:
595:                   None
596:                ***************************************************************************/
597:               
598:               // Implemented as a macro. See usb_client_generic.h
599:               
600:               /****************************************************************************
601:                 Function:
602:                   BOOL USBHostGenericGetDeviceAddress(GENERIC_DEVICE_ID *pDevID)
603:               
604:                 Description:
605:                   This interface is used get the address of a specific generic device on
606:                   the USB.
607:               
608:                 Preconditions:
609:                   The device must be connected and enumerated.
610:               
611:                 Parameters:
612:                   pDevID  - Pointer to a structure containing the Device ID Info (VID,
613:                                   PID, serial number, and device address).
614:               
615:                 Return Values:
616:                   TRUE    - The device is connected
617:                   FALSE   - The device is not connected.
618:               
619:                 Example:
620:                   <code>
621:                   GENERIC_DEVICE_ID deviceID;
622:                   WORD serialNumber[] = { '1', '2', '3', '4', '5', '6' };
623:                   BYTE deviceAddress;
624:               
625:                   deviceID.vid          = 0x1234;
626:                   deviceID.pid          = 0x5678;
627:                   deviceID.serialNumber = &serialNumber;
628:               
629:                   if (USBHostGenericGetDeviceAddress(&deviceID))
630:                   {
631:                       deviceAddress = deviceID.deviceAddress;
632:                   }
633:                   </code>
634:               
635:                 Remarks:
636:                   None
637:                ***************************************************************************/
638:               
639:               BOOL USBHostGenericGetDeviceAddress(GENERIC_DEVICE_ID *pDevID) {
009478  780100     MOV W0, W2
640:                   if (!gc_DevData.flags.initialized) return FALSE;
00947A  AB0EB9     BTST 0xEB9, #0
00947C  320010     BRA Z, 0x949E
641:               
642:                   if (gc_DevData.ID.deviceAddress != 0 && pDevID != NULL) {
00947E  20EAE3     MOV #0xEAE, W3
009480  784193     MOV.B [W3], W3
009482  E00403     CP0.B W3
009484  32000C     BRA Z, 0x949E
009486  E00000     CP0 W0
009488  32000A     BRA Z, 0x949E
643:                       if (pDevID->vid == gc_DevData.ID.vid && pDevID->pid == gc_DevData.ID.pid) {
00948A  807550     MOV gc_DevData, W0
00948C  100F92     SUBR W0, [W2], [W15]
00948E  3A0007     BRA NZ, 0x949E
009490  900092     MOV [W2+2], W1
009492  807560     MOV 0xEAC, W0
009494  508F80     SUB W1, W0, [W15]
009496  3A0003     BRA NZ, 0x949E
644:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
645:                           if (!strncmp((char *) gc_DevData.ID.serialNumber, (char *) pDevID->serialNumber, gc_DevData.ID.serialNumberLength * 2))
646:               #endif
647:                           {
648:                               pDevID->deviceAddress = gc_DevData.ID.deviceAddress;
009498  984143     MOV.B W3, [W2+4]
00949A  200010     MOV #0x1, W0
00949C  370001     BRA 0x94A0
649:                               return TRUE;
00949E  EB0000     CLR W0
650:                           }
651:                       }
652:                   }
653:               
654:                   return FALSE;
655:               
656:               } // USBHostGenericGetDeviceAddress
0094A0  060000     RETURN
657:               
658:               
659:               /****************************************************************************
660:                 Function:
661:                   DWORD USBHostGenericGetRxLength( BYTE deviceAddress )
662:               
663:                 Description:
664:                   This function retrieves the number of bytes copied to user's buffer by
665:                   the most recent call to the USBHostGenericRead() function.
666:               
667:                 Preconditions:
668:                   The device must be connected and enumerated.
669:               
670:                 Parameters:
671:                   deviceAddress     - USB Address of the device
672:               
673:                 Returns:
674:                   Returns the number of bytes most recently received from the Generic
675:                   device with address deviceAddress.
676:               
677:                 Remarks:
678:                   This function can only be called once per transfer.  Subsequent calls will
679:                   return zero until new data has been received.
680:                ***************************************************************************/
681:               
682:               // Implemented as a macro. See usb_client_generic.h
683:               
684:               /****************************************************************************
685:                 Function:
686:                   void USBHostGenericRead( BYTE deviceAddress, BYTE *buffer, DWORD length )
687:               
688:                 Description:
689:                   Use this routine to receive from the device and store it into memory.
690:               
691:                 Preconditions:
692:                   The device must be connected and enumerated.
693:               
694:                 Parameters:
695:                   deviceAddress  - USB Address of the device.
696:                   buffer         - Pointer to the data buffer
697:                   length         - Number of bytes to be transferred
698:               
699:                 Return Values:
700:                   USB_SUCCESS         - The Read was started successfully
701:                   (USB error code)    - The Read was not started.  See USBHostRead() for
702:                                           a list of errors.
703:               
704:                 Example:
705:                   <code>
706:                   if (!USBHostGenericRxIsBusy( deviceAddress ))
707:                   {
708:                       USBHostGenericRead( deviceAddress, &buffer, sizeof(buffer) );
709:                   }
710:                   </code>
711:               
712:                 Remarks:
713:                   None
714:                ***************************************************************************/
715:               
716:               BYTE USBHostGenericRead(BYTE deviceAddress, void *buffer, DWORD length) {
0094A2  780381     MOV W1, W7
717:                   BYTE RetVal;
718:                   static unsigned int failCounter = 0;
719:               
720:                   // Validate the call
721:                   if (!API_VALID(deviceAddress)) return USB_INVALID_STATE;
0094A4  20EAE6     MOV #0xEAE, W6
0094A6  784316     MOV.B [W6], W6
0094A8  534F80     SUB.B W6, W0, [W15]
0094AA  3A001D     BRA NZ, 0x94E6
0094AC  8075C0     MOV 0xEB8, W0
0094AE  A38800     BTST.Z W0, #8
0094B0  32001A     BRA Z, 0x94E6
722:                   if (gc_DevData.flags.rx1Busy) {
0094B2  A3B800     BTST.Z W0, #11
0094B4  320009     BRA Z, 0x94C8
723:                       failCounter++;
0094B6  EC0EA0     INC failCounter, WREG
0094B8  887500     MOV W0, failCounter
724:                       if (failCounter > FAIL_COUNTER) {
0094BA  200021     MOV #0x2, W1
0094BC  500FE5     SUB W0, #0x5, [W15]
0094BE  360014     BRA LEU, 0x94E8
725:                           gc_DevData.flags.rx1Busy = 0;
0094C0  A96EB9     BCLR 0xEB9, #3
726:                           failCounter = 0;
0094C2  EF2EA0     CLR failCounter
0094C4  200021     MOV #0x2, W1
0094C6  370010     BRA 0x94E8
727:                       }
728:                       return USB_BUSY;
729:                   }
730:               
731:                   // Set the busy flag, clear the count and start a new IN transfer.
732:                   gc_DevData.flags.rx1Busy = 1;
0094C8  A86EB9     BSET 0xEB9, #3
733:                   gc_DevData.rx1Length = 0;
0094CA  EF2EB0     CLR 0xEB0
0094CC  EF2EB2     CLR 0xEB2
734:                   RetVal = USBHostRead(deviceAddress, USB_IN_EP | epInterruptIn, (BYTE *) buffer, length);
0094CE  20F1E1     MOV #0xF1E, W1
0094D0  784091     MOV.B [W1], W1
0094D2  A07401     BSET.B W1, #7
0094D4  BE0202     MOV.D W2, W4
0094D6  780107     MOV W7, W2
0094D8  784006     MOV.B W6, W0
0094DA  07CA67     RCALL USBHostRead
735:                   if (RetVal != USB_SUCCESS) {
0094DC  E00400     CP0.B W0
0094DE  320001     BRA Z, 0x94E2
736:                       gc_DevData.flags.rx1Busy = 0; // Clear flag to allow re-try
0094E0  A96EB9     BCLR 0xEB9, #3
737:                   }
738:               
739:                   return RetVal;
0094E2  FB8080     ZE W0, W1
0094E4  370001     BRA 0x94E8
0094E6  200011     MOV #0x1, W1
740:               
741:               } // USBHostGenericRead
0094E8  780001     MOV W1, W0
0094EA  060000     RETURN
742:               
743:               /****************************************************************************
744:                 Function:
745:                   BOOL USBHostGenericRxIsBusy( BYTE deviceAddress )
746:               
747:                 Summary:
748:                   This interface is used to check if the client driver is currently busy
749:                   receiving data from the device.
750:               
751:                 Description:
752:                   This interface is used to check if the client driver is currently busy
753:                   receiving data from the device.  This function is intended for use with
754:                   transfer events.  With polling, the function USBHostGenericRxIsComplete()
755:                   should be used.
756:               
757:                 Preconditions:
758:                   The device must be connected and enumerated.
759:               
760:                 Parameters:
761:                   deviceAddress     - USB Address of the device
762:               
763:                 Return Values:
764:                   TRUE    - The device is receiving data or an invalid deviceAddress is
765:                               given.
766:                   FALSE   - The device is not receiving data
767:               
768:                 Example:
769:                   <code>
770:                   if (!USBHostGenericRxIsBusy( deviceAddress ))
771:                   {
772:                       USBHostGenericRead( deviceAddress, &Buffer, sizeof( Buffer ) );
773:                   }
774:                   </code>
775:               
776:                 Remarks:
777:                   None
778:                ***************************************************************************/
779:               
780:               // Implemented as a macro. See usb_client_generic.h
781:               
782:               
783:               /****************************************************************************
784:                 Function:
785:                   BOOL USBHostGenericRxIsComplete( BYTE deviceAddress, BYTE *errorCode,
786:                               DWORD *byteCount )
787:               
788:                 Summary:
789:                   This routine indicates whether or not the last IN transfer is complete.
790:               
791:                 Description:
792:                   This routine indicates whether or not the last IN transfer is complete.
793:                   If it is, then the returned errorCode and byteCount are valid, and
794:                   reflect the error code and the number of bytes received.
795:               
796:                   This function is intended for use with polling.  With transfer events,
797:                   the function USBHostGenericRxIsBusy() should be used.
798:               
799:                 Preconditions:
800:                   None
801:               
802:                 Parameters:
803:                   BYTE deviceAddress  - Address of the attached peripheral
804:                   BYTE *errorCode     - Error code of the last transfer, if complete
805:                   DWORD *byteCount    - Bytes transferred during the last transfer, if
806:                                           complete
807:               
808:                 Return Values:
809:                   TRUE    - The IN transfer is complete.  errorCode and byteCount are valid.
810:                   FALSE   - The IN transfer is not complete.  errorCode and byteCount are
811:                               invalid.
812:               
813:                 Remarks:
814:                   None
815:                ***************************************************************************/
816:               
817:               #ifndef USB_ENABLE_TRANSFER_EVENT
818:               
819:               BOOL USBHostGenericRxIsComplete(BYTE deviceAddress,
820:                       BYTE *errorCode, DWORD *byteCount) {
821:                   if (gc_DevData.flags.rxBusy) {
822:                       return FALSE;
823:                   } else {
824:                       *byteCount = gc_DevData.rx1Length;
825:                       *errorCode = gc_DevData.rxErrorCode;
826:                       return TRUE;
827:                   }
828:               }
829:               #endif
830:               
831:               /****************************************************************************
832:                 Function:
833:                   void USBHostGenericTasks( void )
834:               
835:                 Summary:
836:                   This routine is used if transfer events are not utilized. It monitors the
837:                   host status and updates the transmit and receive flags.
838:               
839:                 Description:
840:                   This routine is used if transfer events are not utilized. It monitors the
841:                   host status and updates the transmit and receive flags.  If serial
842:                   numbers are supported, then this routine handles the reception of the
843:                   serial number.
844:               
845:                 Preconditions:
846:                   None
847:               
848:                 Parameters:
849:                   None
850:               
851:                 Returns:
852:                   None
853:               
854:                 Remarks:
855:                   This function is compiled only if USB_ENABLE_TRANSFER_EVENT is not
856:                   defined.
857:                ***************************************************************************/
858:               
859:               #ifndef USB_ENABLE_TRANSFER_EVENT
860:               
861:               void USBHostGenericTasks(void) {
862:                   DWORD byteCount;
863:                   BYTE errorCode;
864:               
865:                   if (gc_DevData.ID.deviceAddress && gc_DevData.flags.initialized) {
866:               #ifdef USB_GENERIC_SUPPORT_SERIAL_NUMBERS
867:                       if (!gc_DevData.flags.serialNumberValid) {
868:                           if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, USB_IN_EP, &errorCode, &byteCount);
869:                               {
870:               #ifdef DEBUG_MODE
871:                                   UART2PrintString("GEN: Got serial number!\r\n");
872:               #endif
873:                                           // Set the serial number information
874:                                           gc_DevData.ID.serialNumberLength = byteCount;
875:                                           gc_DevData.flags.serialNumberValid = 1;
876:                                           gc_DevData.flags.initialized = 1;
877:               
878:                                           // Tell the application layer that we have a device.
879:                                           USB_HOST_APP_EVENT_HANDLER(address, EVENT_GENERIC_ATTACH, &(gc_DevData.ID), sizeof (GENERIC_DEVICE_ID));
880:                               }
881:                       }
882:               #endif
883:               
884:                       if (gc_DevData.flags.rxBusy) {
885:                           if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, USB_IN_EP | epInterruptIn, &errorCode, &byteCount)) {
886:                               gc_DevData.flags.rxBusy = 0;
887:                                       gc_DevData.rx1Length = byteCount;
888:                                       gc_DevData.rxErrorCode = errorCode;
889:                           }
890:                       }
891:               
892:                       if (gc_DevData.flags.txBusy) {
893:                           if (USBHostTransferIsComplete(gc_DevData.ID.deviceAddress, USB_OUT_EP | epInterruptOut, &errorCode, &byteCount)) {
894:               
895:                               gc_DevData.flags.txBusy = 0;
896:                                       gc_DevData.txErrorCode = errorCode;
897:                           }
898:                       }
899:                   }
900:               }
901:               #endif
902:               
903:               /****************************************************************************
904:                 Function:
905:                   BOOL USBHostGenericTxIsBusy( BYTE deviceAddress )
906:               
907:                 Summary:
908:                   This interface is used to check if the client driver is currently busy
909:                   transmitting data to the device.
910:               
911:                 Description:
912:                   This interface is used to check if the client driver is currently busy
913:                   transmitting data to the device.  This function is intended for use with
914:                   transfer events.  With polling, the function USBHostGenericTxIsComplete()
915:                   should be used.
916:               
917:                 Preconditions:
918:                   The device must be connected and enumerated.
919:               
920:                 Parameters:
921:                   deviceAddress     - USB Address of the device
922:               
923:                 Return Values:
924:                   TRUE    - The device is transmitting data or an invalid deviceAddress
925:                               is given.
926:                   FALSE   - The device is not transmitting data
927:               
928:                 Example:
929:                   <code>
930:                   if (!USBHostGenericTxIsBusy( deviceAddress ) )
931:                   {
932:                       USBHostGenericWrite( deviceAddress, &buffer, sizeof( buffer ) );
933:                   }
934:                   </code>
935:               
936:                 Remarks:
937:                   None
938:                ***************************************************************************/
939:               
940:               // Implemented as a macro. See usb_client_generic.h
941:               
942:               
943:               /****************************************************************************
944:                 Function:
945:                   BOOL USBHostGenericTxIsComplete( BYTE deviceAddress, BYTE *errorCode )
946:               
947:                 Summary:
948:                   This routine indicates whether or not the last OUT transfer is complete.
949:               
950:                 Description:
951:                   This routine indicates whether or not the last OUT transfer is complete.
952:                   If it is, then the returned errorCode is valid, and reflect the error
953:                   code of the transfer.
954:               
955:                   This function is intended for use with polling.  With transfer events,
956:                   the function USBHostGenericTxIsBusy() should be used.
957:               
958:                 Preconditions:
959:                   None
960:               
961:                 Parameters:
962:                   BYTE deviceAddress  - Address of the attached peripheral
963:                   BYTE *errorCode     - Error code of the last transfer, if complete
964:               
965:                 Return Values:
966:                   TRUE    - The OUT transfer is complete.  errorCode is valid.
967:                   FALSE   - The OUT transfer is not complete.  errorCode is invalid.
968:               
969:                 Remarks:
970:                   None
971:                ***************************************************************************/
972:               
973:               #ifndef USB_ENABLE_TRANSFER_EVENT
974:               BOOL USBHostGenericTxIsComplete(BYTE deviceAddress, BYTE *errorCode) {
975:                   if (gc_DevData.flags.txBusy) {
976:                       return FALSE;
977:                   } else {
978:                       *errorCode = gc_DevData.txErrorCode;
979:               
980:                       return TRUE;
981:                   }
982:               }
983:               #endif
984:               
985:               
986:               /****************************************************************************
987:                 Function:
988:                   void USBHostGenericWrite( BYTE deviceAddress, BYTE *buffer, DWORD length )
989:               
990:                 Description:
991:                   Use this routine to transmit data from memory to the device.
992:               
993:                 Preconditions:
994:                   The device must be connected and enumerated.
995:               
996:                 Parameters:
997:                   deviceAddress   - USB Address of the device.
998:                   buffer          - Pointer to the data buffer
999:                   length          - Number of bytes to be transferred
1000:              
1001:                Return Values:
1002:                  USB_SUCCESS         - The Write was started successfully
1003:                  (USB error code)    - The Write was not started.  See USBHostWrite() for
1004:                                          a list of errors.
1005:              
1006:                Example:
1007:                  <code>
1008:                  if (!USBHostGenericTxIsBusy( deviceAddress ))
1009:                  {
1010:                      USBHostGenericWrite( deviceAddress, &buffer, sizeof(buffer) );
1011:                  }
1012:                  </code>
1013:              
1014:                Remarks:
1015:                  None
1016:               ***************************************************************************/
1017:              
1018:              BYTE USBHostGenericWrite(BYTE deviceAddress, void *buffer, DWORD length) {
0094EC  780381     MOV W1, W7
1019:                  BYTE RetVal;
1020:                          static unsigned int failCounter = 0;
1021:                          // Validate the call
1022:                  if (!API_VALID(deviceAddress)) return USB_INVALID_STATE;
0094EE  20EAE6     MOV #0xEAE, W6
0094F0  784316     MOV.B [W6], W6
0094F2  534F80     SUB.B W6, W0, [W15]
0094F4  3A001A     BRA NZ, 0x952A
0094F6  8075C0     MOV 0xEB8, W0
0094F8  A38800     BTST.Z W0, #8
0094FA  320017     BRA Z, 0x952A
1023:                      if (gc_DevData.flags.txBusy) {
0094FC  A39800     BTST.Z W0, #9
0094FE  320009     BRA Z, 0x9512
1024:                          failCounter++;
009500  EC0EA2     INC failCounter, WREG
009502  887510     MOV W0, failCounter
1025:                          if (failCounter > FAIL_COUNTER) {
009504  200021     MOV #0x2, W1
009506  500FE5     SUB W0, #0x5, [W15]
009508  360011     BRA LEU, 0x952C
1026:                              gc_DevData.flags.txBusy = 0;
00950A  A92EB9     BCLR 0xEB9, #1
1027:                                      failCounter = 0;
00950C  EF2EA2     CLR failCounter
00950E  200021     MOV #0x2, W1
009510  37000D     BRA 0x952C
1028:                          }
1029:                          return USB_BUSY;
1030:                      }
1031:                  // Set the busy flag and start a new OUT transfer.
1032:                  gc_DevData.flags.txBusy = 1;
009512  A82EB9     BSET 0xEB9, #1
1033:                          RetVal = USBHostWrite(deviceAddress, USB_OUT_EP | epInterruptOut, (BYTE *) buffer, length); //ep = 3
009514  20F1F1     MOV #0xF1F, W1
009516  784091     MOV.B [W1], W1
009518  BE0202     MOV.D W2, W4
00951A  780107     MOV W7, W2
00951C  784006     MOV.B W6, W0
00951E  07CF87     RCALL USBHostWrite
1034:                  if (RetVal != USB_SUCCESS) {
009520  E00400     CP0.B W0
009522  320001     BRA Z, 0x9526
1035:              
1036:                      gc_DevData.flags.txBusy = 0; // Clear flag to allow re-try
009524  A92EB9     BCLR 0xEB9, #1
1037:                  }
1038:              
1039:                  return RetVal;
009526  FB8080     ZE W0, W1
009528  370001     BRA 0x952C
00952A  200011     MOV #0x1, W1
1040:              
1041:              } // USBHostGenericWrite
00952C  780001     MOV W1, W0
00952E  060000     RETURN
1042:              
1043:              //YTS added three functions below
1044:              
1045:              BYTE USBHostGenericClassRequest(BYTE deviceAddress, BYTE *data, WORD wLength) {
009530  781F88     MOV W8, [W15++]
009532  780182     MOV W2, W3
1046:                  BYTE RetVal;
1047:                          static unsigned int failCounter = 0;
1048:                          // Validate the call
1049:                  if (!API_VALID(deviceAddress)) return USB_INVALID_STATE;
009534  20EAE8     MOV #0xEAE, W8
009536  784418     MOV.B [W8], W8
009538  544F80     SUB.B W8, W0, [W15]
00953A  3A001F     BRA NZ, 0x957A
00953C  8075C0     MOV 0xEB8, W0
00953E  A38800     BTST.Z W0, #8
009540  32001C     BRA Z, 0x957A
1050:                      if (gc_DevData.flags.txBusy) {
009542  A39800     BTST.Z W0, #9
009544  320009     BRA Z, 0x9558
1051:                          failCounter++;
009546  EC0EA4     INC failCounter, WREG
009548  887520     MOV W0, failCounter
1052:                          if (failCounter > FAIL_COUNTER) {
00954A  200021     MOV #0x2, W1
00954C  500FE5     SUB W0, #0x5, [W15]
00954E  360016     BRA LEU, 0x957C
1053:                              gc_DevData.flags.txBusy = 0;
009550  A92EB9     BCLR 0xEB9, #1
1054:                                      failCounter = 0;
009552  EF2EA4     CLR failCounter
009554  200021     MOV #0x2, W1
009556  370012     BRA 0x957C
1055:                          }
1056:                          return USB_BUSY;
1057:                      }
1058:                  // Set the busy flag and start a new OUT transfer.
1059:                  //    gc_DevData.flags.txBusy = 1;
1060:                  RetVal = USBHostIssueDeviceRequest(deviceAddress, 0x21, 0, 0, 0, wLength, data, USB_DEVICE_REQUEST_SET, 0x00);
009558  E8878F     INC2 W15, W15
00955A  EB4100     CLR.B W2
00955C  9FFFE2     MOV.B W2, [W15-2]
00955E  784382     MOV.B W2, W7
009560  780301     MOV W1, W6
009562  780283     MOV W3, W5
009564  EB0200     CLR W4
009566  780184     MOV W4, W3
009568  B3C211     MOV.B #0x21, W1
00956A  784008     MOV.B W8, W0
00956C  07C996     RCALL USBHostIssueDeviceRequest
1061:                  if (RetVal != USB_SUCCESS) {
00956E  E9878F     DEC2 W15, W15
009570  E00400     CP0.B W0
009572  320001     BRA Z, 0x9576
1062:              
1063:                      gc_DevData.flags.txBusy = 0; // Clear flag to allow re-try
009574  A92EB9     BCLR 0xEB9, #1
1064:                  }
1065:              
1066:                  return RetVal;
009576  FB8080     ZE W0, W1
009578  370001     BRA 0x957C
00957A  200011     MOV #0x1, W1
1067:              
1068:              } // USBHostGenericClassRequest
00957C  780001     MOV W1, W0
00957E  78044F     MOV [--W15], W8
009580  060000     RETURN
1069:              
1070:              BYTE USBHostGenericAclWrite(BYTE deviceAddress, void *buffer, DWORD length) {
009582  780381     MOV W1, W7
1071:                  BYTE RetVal;
1072:                          static unsigned int failCounter = 0;
1073:                          // Validate the call
1074:                  if (!API_VALID(deviceAddress)) return USB_INVALID_STATE;
009584  20EAE6     MOV #0xEAE, W6
009586  784316     MOV.B [W6], W6
009588  534F80     SUB.B W6, W0, [W15]
00958A  3A001A     BRA NZ, 0x95C0
00958C  8075C0     MOV 0xEB8, W0
00958E  A38800     BTST.Z W0, #8
009590  320017     BRA Z, 0x95C0
1075:                      if (gc_DevData.flags.tx2Busy) {
009592  A3A800     BTST.Z W0, #10
009594  320009     BRA Z, 0x95A8
1076:                          failCounter++;
009596  EC0EA6     INC failCounter, WREG
009598  887530     MOV W0, failCounter
1077:                          if (failCounter > FAIL_COUNTER) {
00959A  200021     MOV #0x2, W1
00959C  500FE5     SUB W0, #0x5, [W15]
00959E  360011     BRA LEU, 0x95C2
1078:                              gc_DevData.flags.tx2Busy = 0;
0095A0  A94EB9     BCLR 0xEB9, #2
1079:                                      failCounter = 0;
0095A2  EF2EA6     CLR failCounter
0095A4  200021     MOV #0x2, W1
0095A6  37000D     BRA 0x95C2
1080:                          }
1081:                          return USB_BUSY;
1082:                      };
1083:              
1084:                  // Set the busy flag and start a new OUT transfer.
1085:                  gc_DevData.flags.tx2Busy = 1;
0095A8  A84EB9     BSET 0xEB9, #2
1086:                          RetVal = USBHostWrite(deviceAddress, USB_OUT_EP | epBulkOut, (BYTE *) buffer, length);
0095AA  20F211     MOV #0xF21, W1
0095AC  784091     MOV.B [W1], W1
0095AE  BE0202     MOV.D W2, W4
0095B0  780107     MOV W7, W2
0095B2  784006     MOV.B W6, W0
0095B4  07CF3C     RCALL USBHostWrite
1087:                  if (RetVal != USB_SUCCESS) {
0095B6  E00400     CP0.B W0
0095B8  320001     BRA Z, 0x95BC
1088:              
1089:                      gc_DevData.flags.tx2Busy = 0; // Clear flag to allow re-try
0095BA  A94EB9     BCLR 0xEB9, #2
1090:                  }
1091:              
1092:                  return RetVal;
0095BC  FB8080     ZE W0, W1
0095BE  370001     BRA 0x95C2
0095C0  200011     MOV #0x1, W1
1093:              
1094:              } // USBHostGenericAclWrite
0095C2  780001     MOV W1, W0
0095C4  060000     RETURN
1095:              
1096:              BYTE USBHostGenericAclRead(BYTE deviceAddress, void *buffer, DWORD length) {
0095C6  780381     MOV W1, W7
1097:                  BYTE RetVal;
1098:                          static unsigned int failCounter = 0;
1099:                          // Validate the call
1100:                  if (!API_VALID(deviceAddress)) return USB_INVALID_STATE;
0095C8  20EAE6     MOV #0xEAE, W6
0095CA  784316     MOV.B [W6], W6
0095CC  534F80     SUB.B W6, W0, [W15]
0095CE  3A001D     BRA NZ, 0x960A
0095D0  8075C0     MOV 0xEB8, W0
0095D2  A38800     BTST.Z W0, #8
0095D4  32001A     BRA Z, 0x960A
1101:                      if (gc_DevData.flags.rx2Busy) {
0095D6  A3C800     BTST.Z W0, #12
0095D8  320009     BRA Z, 0x95EC
1102:                          failCounter++;
0095DA  EC0EA8     INC failCounter, WREG
0095DC  887540     MOV W0, failCounter
1103:                          if (failCounter > FAIL_COUNTER) {
0095DE  200021     MOV #0x2, W1
0095E0  500FE5     SUB W0, #0x5, [W15]
0095E2  360014     BRA LEU, 0x960C
1104:                              gc_DevData.flags.txBusy = 0;
0095E4  A92EB9     BCLR 0xEB9, #1
1105:                                      failCounter = 0;
0095E6  EF2EA8     CLR failCounter
0095E8  200021     MOV #0x2, W1
0095EA  370010     BRA 0x960C
1106:                          }
1107:                          return USB_BUSY;
1108:                      };
1109:              
1110:              
1111:                  // Set the busy flag, clear the count and start a new IN transfer.
1112:                  gc_DevData.flags.rx2Busy = 1;
0095EC  A88EB9     BSET 0xEB9, #4
1113:                          gc_DevData.rx2Length = 0;
0095EE  EF2EB4     CLR 0xEB4
0095F0  EF2EB6     CLR 0xEB6
1114:                          RetVal = USBHostRead(deviceAddress, USB_IN_EP | epBulkIn, (BYTE *) buffer, length);
0095F2  20F201     MOV #0xF20, W1
0095F4  784091     MOV.B [W1], W1
0095F6  A07401     BSET.B W1, #7
0095F8  BE0202     MOV.D W2, W4
0095FA  780107     MOV W7, W2
0095FC  784006     MOV.B W6, W0
0095FE  07C9D5     RCALL USBHostRead
1115:                  if (RetVal != USB_SUCCESS) {
009600  E00400     CP0.B W0
009602  320001     BRA Z, 0x9606
1116:              
1117:                      gc_DevData.flags.rx2Busy = 0; // Clear flag to allow re-try
009604  A98EB9     BCLR 0xEB9, #4
1118:                  }
1119:              
1120:                  return RetVal;
009606  FB8080     ZE W0, W1
009608  370001     BRA 0x960C
00960A  200011     MOV #0x1, W1
1121:              
1122:              } // USBHostGenericAclRead
00960C  780001     MOV W1, W0
00960E  060000     RETURN
1123:              
1124:              
1125:              /*****************Added Functions by MH***********************/
1126:              BYTE GetEpInterruptIn(void) {
009610  BFCF1E     MOV.B 0xF1E, WREG
009612  FB8000     ZE W0, W0
1127:              
1128:                  return epInterruptIn;
1129:              }
009614  060000     RETURN
1130:              
1131:              BYTE GetEpInterruptOut(void) {
009616  BFCF1F     MOV.B 0xF1F, WREG
009618  FB8000     ZE W0, W0
1132:              
1133:                  return epInterruptOut;
1134:              }
00961A  060000     RETURN
1135:              
1136:              BYTE GetEpBulkIn(void) {
00961C  BFCF20     MOV.B 0xF20, WREG
00961E  FB8000     ZE W0, W0
1137:              
1138:                  return epBulkIn;
1139:              }
009620  060000     RETURN
1140:              
1141:              BYTE GetEpBulkOut(void) {
009622  BFCF21     MOV.B 0xF21, WREG
009624  FB8000     ZE W0, W0
1142:              
1143:                  return epBulkOut;
1144:              }
009626  060000     RETURN
1145:              
1146:              void SetEpInterruptIn(BYTE ep) {
1147:              
1148:                  epInterruptIn = ep;
009628  B7EF1E     MOV.B WREG, 0xF1E
1149:              }
00962A  060000     RETURN
1150:              
1151:              void SetEpInterruptOut(BYTE ep) {
1152:              
1153:                  epInterruptOut = ep;
00962C  B7EF1F     MOV.B WREG, 0xF1F
1154:              }
00962E  060000     RETURN
1155:              
1156:              void SetEpBulkIn(BYTE ep) {
1157:              
1158:                  epBulkIn = ep;
009630  B7EF20     MOV.B WREG, 0xF20
1159:              }
009632  060000     RETURN
1160:              
1161:              void SetEpBulkOut(BYTE ep) {
1162:              
1163:                  epBulkOut = ep;
009634  B7EF21     MOV.B WREG, 0xF21
1164:              }
009636  060000     RETURN
1165:              
1166:              
1167:              
1168:              CONNECTED_DEVICE GetConnectedDeviceType(void) {
009638  8074F0     MOV ConnectedDevice, W0
1169:              
1170:                  return ConnectedDevice;
1171:              };
00963A  060000     RETURN
1172:              
1173:              void SetConnectedDeviceType(CONNECTED_DEVICE type) {
1174:                  ConnectedDevice = type;
00963C  8874F0     MOV W0, ConnectedDevice
1175:              }
00963E  060000     RETURN
1176:              /*************************************************************************
1177:               * EOF usb_client_generic.c
1178:               */
1179:              
1180:              
---  D:/PIC/PIC_PS4_Host/trunk/USB/usb_host.c  ----------------------------------------------------------
1:                 //#define DEBUG_MODE
2:                 /******************************************************************************
3:                 
4:                     USB Host Driver
5:                 
6:                 This file provides the hardware interface for a USB Embedded Host application.
7:                 Most applications will not make direct use of the functions in this file.
8:                 Instead, one or more client driver files should also be included in the project
9:                 to support the devices that will be attached to the host.  Application
10:                interface will be through the client drivers.
11:                
12:                Note: USB interrupts are cleared by writing a "1" to the interrupt flag.  This
13:                means that read-modify-write instructions cannot be used to clear the flag.  A
14:                bit manipulation instruction, such as "U1OTGIRbits.T1MSECIF = 1;" will read the
15:                value of the U1OTGIR register, set the T1MSECIF bit in that value to "1", and
16:                then write that value back to U1OTGIR.  If U1OTGIR had any other flags set,
17:                those flags are written back as "1", which will clear those flags.  To avoid
18:                this issue, a constant value must be written to U1OTGIR where only the interrupt
19:                flag in question is set, such as "U1OTGIR = USB_INTERRUPT_T1MSECIF;", where
20:                USB_INTERRUPT_T1MSECIF equals 0x40.
21:                
22:                 *******************************************************************************/
23:                //DOM-IGNORE-BEGIN
24:                /******************************************************************************
25:                
26:                 File Name:       usb_host.c
27:                 Dependencies:    None
28:                 Processor:       PIC24F/PIC32MX
29:                 Compiler:        C30/C32
30:                 Company:         Microchip Technology, Inc.
31:                
32:                Software License Agreement
33:                
34:                The software supplied herewith by Microchip Technology Incorporated
35:                (the Company) for its PICmicro Microcontroller is intended and
36:                supplied to you, the Companys customer, for use solely and
37:                exclusively on Microchip PICmicro Microcontroller products. The
38:                software is owned by the Company and/or its supplier, and is
39:                protected under applicable copyright laws. All rights are reserved.
40:                Any use in violation of the foregoing restrictions may subject the
41:                user to criminal sanctions under applicable laws, as well as to
42:                civil liability for the breach of the terms and conditions of this
43:                license.
44:                
45:                THIS SOFTWARE IS PROVIDED IN AN AS IS CONDITION. NO WARRANTIES,
46:                WHETHER EXPRESS, IMPLIED OR STATUTORY, INCLUDING, BUT NOT LIMITED
47:                TO, IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
48:                PARTICULAR PURPOSE APPLY TO THIS SOFTWARE. THE COMPANY SHALL NOT,
49:                IN ANY CIRCUMSTANCES, BE LIABLE FOR SPECIAL, INCIDENTAL OR
50:                CONSEQUENTIAL DAMAGES, FOR ANY REASON WHATSOEVER.
51:                
52:                Change History:
53:                  Rev         Description
54:                  ----------  ----------------------------------------------------------
55:                  2.6 - 2.6a  No change
56:                  
57:                  2.7         Fixed an error where the USBHostClearEndpointErrors() function
58:                              didn't properly return USB_SUCCESS if the errors were successfully
59:                              cleared.
60:                              http://www.microchip.com/forums/fb.aspx?m=490651
61:                
62:                              Fixed an error where the DTS bits for the attached device could
63:                              be accidentally reset on a class specific request with the same
64:                              bRequest and wValue as a HALT_ENDPOINT request.
65:                
66:                              Fixed an error where device may never be able to enumerate if it
67:                              is already attached when the host stack initializes.
68:                
69:                  2.9d        Fixed PIC32 USB register mapping to be more universal
70:                              Fixed a race condition between 1msec timer and USB device stack
71:                
72:                 *******************************************************************************/
73:                
74:                #include <stdlib.h>
75:                #include <string.h>
76:                #include "GenericTypeDefs.h"
77:                #include "USB/usb.h"
78:                #include "usb_host_local.h"
79:                #include "usb_hal_local.h"
80:                #include "HardwareProfile.h"
81:                #include "uart2.h"
82:                
83:                #ifndef USB_MALLOC
84:                #define USB_MALLOC(size) malloc(size)
85:                #endif
86:                
87:                #ifndef USB_FREE
88:                #define USB_FREE(ptr) free(ptr)
89:                #endif
90:                
91:                #define USB_FREE_AND_CLEAR(ptr) {USB_FREE(ptr); ptr = NULL;}
92:                
93:                #if defined( USB_ENABLE_TRANSFER_EVENT )
94:                #include "struct_queue.h"
95:                #endif
96:                
97:                // *****************************************************************************
98:                // Low Level Functionality Configurations.
99:                
100:               //#define DEBUG_MODE
101:               #ifdef DEBUG_MODE
102:               #include "uart2.h"
103:               #endif
104:               
105:               // If the TPL includes an entry specifying a VID of 0xFFFF and a PID of 0xFFFF,
106:               // the specified client driver will be used for any device that attaches.  This
107:               // can be useful for debugging or for providing generic charging functionality.
108:               #define ALLOW_GLOBAL_VID_AND_PID
109:               
110:               // If we allow multiple control transactions during a frame and a NAK is
111:               // generated, we don't get TRNIF.  So we will allow only one control transaction
112:               // per frame.
113:               #define ONE_CONTROL_TRANSACTION_PER_FRAME
114:               
115:               // This definition allow Bulk transfers to take all of the remaining bandwidth
116:               // of a frame.
117:               #define ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
118:               
119:               // If this is defined, then we will repeat a NAK'd request in the same frame.
120:               // Otherwise, we will wait until the next frame to repeat the request.  Some
121:               // mass storage devices require the host to wait until the next frame to
122:               // repeat the request.
123:               //#define ALLOW_MULTIPLE_NAKS_PER_FRAME
124:               
125:               //#define USE_MANUAL_DETACH_DETECT
126:               
127:               // The USB specification states that transactions should be tried three times
128:               // if there is a bus error.  We will allow that number to be configurable. The
129:               // maximum value is 31.
130:               #define USB_TRANSACTION_RETRY_ATTEMPTS  20
131:               
132:               //******************************************************************************
133:               //******************************************************************************
134:               // Section: Host Global Variables
135:               //******************************************************************************
136:               //******************************************************************************
137:               
138:               // When using the PIC32, ping pong mode must be set to FULL.
139:               #if defined (__PIC32MX__)
140:               #if (USB_PING_PONG_MODE != USB_PING_PONG__FULL_PING_PONG)
141:               #undef USB_PING_PONG_MODE
142:               #define USB_PING_PONG_MODE USB_PING_PONG__FULL_PING_PONG
143:               #endif
144:               #endif
145:               
146:               #if (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
147:               #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
148:               static BDT_ENTRY __attribute__((aligned(512))) BDT[2];
149:               #endif
150:               #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
151:               #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Buffer Descriptor
152:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
153:               #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
154:               static BDT_ENTRY __attribute__((aligned(512))) BDT[3];
155:               #endif
156:               #define BDT_IN                                  (&BDT[0])           // EP0 IN Buffer Descriptor
157:               #define BDT_OUT                                 (&BDT[1])           // EP0 OUT Even Buffer Descriptor
158:               #define BDT_OUT_ODD                             (&BDT[2])           // EP0 OUT Odd Buffer Descriptor
159:               #elif (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
160:               #if !defined(USB_SUPPORT_OTG) && !defined(USB_SUPPORT_DEVICE)
161:               static BDT_ENTRY __attribute__((aligned(512))) BDT[4];
162:               #endif
163:               #define BDT_IN                                  (&BDT[0])           // EP0 IN Even Buffer Descriptor
164:               #define BDT_IN_ODD                              (&BDT[1])           // EP0 IN Odd Buffer Descriptor
165:               #define BDT_OUT                                 (&BDT[2])           // EP0 OUT Even Buffer Descriptor
166:               #define BDT_OUT_ODD                             (&BDT[3])           // EP0 OUT Odd Buffer Descriptor
167:               #endif
168:               
169:               #if defined(USB_SUPPORT_OTG) || defined(USB_SUPPORT_DEVICE)
170:               extern BDT_ENTRY BDT[] __attribute__((aligned(512)));
171:               #endif
172:               
173:               // These should all be moved into the USB_DEVICE_INFO structure.
174:               static BYTE countConfigurations; // Count the Configuration Descriptors read during enumeration.
175:               static BYTE numCommandTries; // The number of times the current command has been tried.
176:               static BYTE numEnumerationTries; // The number of times enumeration has been attempted on the attached device.
177:               static volatile WORD numTimerInterrupts; // The number of milliseconds elapsed during the current waiting period.
178:               static volatile USB_ENDPOINT_INFO *pCurrentEndpoint; // Pointer to the endpoint currently performing a transfer.
179:               BYTE *pCurrentConfigurationDescriptor = NULL; // Pointer to the current configuration descriptor of the attached device.
180:               BYTE *pDeviceDescriptor = NULL; // Pointer to the Device Descriptor of the attached device.
181:               static BYTE *pEP0Data = NULL; // A data buffer for use by EP0.
182:               static volatile WORD usbHostState; // State machine state of the attached device.
183:               volatile WORD usbOverrideHostState; // Next state machine state, when set by interrupt processing.
184:               #ifdef ENABLE_STATE_TRACE   // Debug trace support
185:               static WORD prevHostState;
186:               #endif
187:               
188:               static USB_BUS_INFO usbBusInfo; // Information about the USB bus.
189:               static USB_DEVICE_INFO usbDeviceInfo; // A collection of information about the attached device.
190:               #if defined( USB_ENABLE_TRANSFER_EVENT )
191:               static USB_EVENT_QUEUE usbEventQueue; // Queue of USB events used to synchronize ISR to main tasks loop.
192:               #endif
193:               static USB_ROOT_HUB_INFO usbRootHubInfo; // Information about a specific port.
194:               
195:               static volatile WORD msec_count = 0; // The current millisecond count.
196:               
197:               // *****************************************************************************
198:               // *****************************************************************************
199:               // Section: Application Callable Functions
200:               // *****************************************************************************
201:               // *****************************************************************************
202:               
203:               /****************************************************************************
204:                 Function:
205:                   BYTE USBHostClearEndpointErrors( BYTE deviceAddress, BYTE endpoint )
206:               
207:                 Summary:
208:                   This function clears an endpoint's internal error condition.
209:               
210:                 Description:
211:                   This function is called to clear the internal error condition of a device's
212:                   endpoint.  It should be called after the application has dealt with the
213:                   error condition on the device.  This routine clears internal status only;
214:                   it does not interact with the device.
215:               
216:                 Precondition:
217:                   None
218:               
219:                 Parameters:
220:                   BYTE deviceAddress  - Address of device
221:                   BYTE endpoint       - Endpoint to clear error condition
222:               
223:                 Return Values:
224:                   USB_SUCCESS             - Errors cleared
225:                   USB_UNKNOWN_DEVICE      - Device not found
226:                   USB_ENDPOINT_NOT_FOUND  - Specified endpoint not found
227:               
228:                 Remarks:
229:                   None
230:                ***************************************************************************/
231:               
232:               BYTE USBHostClearEndpointErrors(BYTE deviceAddress, BYTE endpoint) {
233:                   USB_ENDPOINT_INFO *ep;
234:               
235:                   // Find the required device
236:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
002800  200062     MOV #0x6, W2
002802  E34ED3     CP.B 0xED3
002804  3A000D     BRA NZ, 0x2820
237:                       return USB_UNKNOWN_DEVICE;
238:                   }
239:               
240:                   ep = _USB_FindEndpoint(endpoint);
002806  784001     MOV.B W1, W0
002808  07070C     RCALL _USB_FindEndpoint
00280A  780080     MOV W0, W1
241:               
242:                   if (ep != NULL) {
00280C  200142     MOV #0x14, W2
00280E  E00000     CP0 W0
002810  320007     BRA Z, 0x2820
243:                       ep->status.bfStalled = 0;
002812  904020     MOV.B [W0+2], W0
002814  A15400     BCLR.B W0, #5
002816  9840A0     MOV.B W0, [W1+2]
244:                       ep->status.bfError = 0;
002818  904021     MOV.B [W1+2], W0
00281A  A16400     BCLR.B W0, #6
00281C  9840A0     MOV.B W0, [W1+2]
00281E  EB0100     CLR W2
245:               
246:                       return USB_SUCCESS;
247:                   }
248:                   return USB_ENDPOINT_NOT_FOUND;
249:               }
002820  780002     MOV W2, W0
002822  060000     RETURN
250:               
251:               /****************************************************************************
252:                 Function:
253:                   BOOL    USBHostDeviceSpecificClientDriver( BYTE deviceAddress )
254:               
255:                 Summary:
256:                   This function indicates if the specified device has explicit client
257:                   driver support specified in the TPL.
258:               
259:                 Description:
260:                   This function indicates if the specified device has explicit client
261:                   driver support specified in the TPL.  It is used in client drivers'
262:                   USB_CLIENT_INIT routines to indicate that the client driver should be
263:                   used even though the class, subclass, and protocol values may not match
264:                   those normally required by the class.  For example, some printing devices
265:                   do not fulfill all of the requirements of the printer class, so their
266:                   class, subclass, and protocol fields indicate a custom driver rather than
267:                   the printer class.  But the printer class driver can still be used, with
268:                   minor limitations.
269:               
270:                 Precondition:
271:                   None
272:               
273:                 Parameters:
274:                   BYTE deviceAddress  - Address of device
275:               
276:                 Return Values:
277:                   TRUE    - This device is listed in the TPL by VID andPID, and has explicit
278:                               client driver support.
279:                   FALSE   - This device is not listed in the TPL by VID and PID.
280:               
281:                 Remarks:
282:                   This function is used so client drivers can allow certain
283:                   devices to enumerate.  For example, some printer devices indicate a custom
284:                   class rather than the printer class, even though the device has only minor
285:                   limitations from the full printer class.   The printer client driver will
286:                   fail to initialize the device if it does not indicate printer class support
287:                   in its interface descriptor.  The printer client driver could allow any
288:                   device with an interface that matches the printer class endpoint
289:                   configuration, but both printer and mass storage devices utilize one bulk
290:                   IN and one bulk OUT endpoint.  So a mass storage device would be
291:                   erroneously initialized as a printer device.  This function allows a
292:                   client driver to know that the client driver support was specified
293:                   explicitly in the TPL, so for this particular device only, the class,
294:                   subclass, and protocol fields can be safely ignored.
295:                ***************************************************************************/
296:               
297:               BOOL USBHostDeviceSpecificClientDriver(BYTE deviceAddress) {
298:                   return usbDeviceInfo.flags.bfUseDeviceClientDriver;
002824  BFCEDE     MOV.B 0xEDE, WREG
002826  DE0046     LSR W0, #6, W0
002828  600061     AND W0, #0x1, W0
299:               }
00282A  060000     RETURN
300:               
301:               /****************************************************************************
302:                 Function:
303:                   BYTE USBHostDeviceStatus( BYTE deviceAddress )
304:               
305:                 Summary:
306:                   This function returns the current status of a device.
307:               
308:                 Description:
309:                   This function returns the current status of a device.  If the device is
310:                   in a holding state due to an error, the error is returned.
311:               
312:                 Precondition:
313:                   None
314:               
315:                 Parameters:
316:                   BYTE deviceAddress  - Device address
317:               
318:                 Return Values:
319:                   USB_DEVICE_ATTACHED                 - Device is attached and running
320:                   USB_DEVICE_DETACHED                 - No device is attached
321:                   USB_DEVICE_ENUMERATING              - Device is enumerating
322:                   USB_HOLDING_OUT_OF_MEMORY           - Not enough heap space available
323:                   USB_HOLDING_UNSUPPORTED_DEVICE      - Invalid configuration or
324:                                                           unsupported class
325:                   USB_HOLDING_UNSUPPORTED_HUB         - Hubs are not supported
326:                   USB_HOLDING_INVALID_CONFIGURATION   - Invalid configuration requested
327:                   USB_HOLDING_PROCESSING_CAPACITY     - Processing requirement excessive
328:                   USB_HOLDING_POWER_REQUIREMENT       - Power requirement excessive
329:                   USB_HOLDING_CLIENT_INIT_ERROR       - Client driver failed to initialize
330:                   USB_DEVICE_SUSPENDED                - Device is suspended
331:                   Other                               - Device is holding in an error
332:                                                           state. The return value
333:                                                           indicates the error.
334:               
335:                 Remarks:
336:                   None
337:                ***************************************************************************/
338:               
339:               BYTE USBHostDeviceStatus(BYTE deviceAddress) {
340:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED) {
00282C  807640     MOV usbHostState, W0
00282E  20F001     MOV #0xF00, W1
002830  600001     AND W0, W1, W0
002832  200312     MOV #0x31, W2
002834  320016     BRA Z, 0x2862
341:                       return USB_DEVICE_DETACHED;
342:                   }
343:               
344:                   if ((usbHostState & STATE_MASK) == STATE_RUNNING) {
002836  807640     MOV usbHostState, W0
002838  20F001     MOV #0xF00, W1
00283A  600001     AND W0, W1, W0
00283C  204001     MOV #0x400, W1
00283E  500F81     SUB W0, W1, [W15]
002840  3A0007     BRA NZ, 0x2850
345:                       if ((usbHostState & SUBSTATE_MASK) == SUBSTATE_SUSPEND_AND_RESUME) {
002842  807640     MOV usbHostState, W0
002844  B20F00     AND #0xF0, W0
002846  2003A2     MOV #0x3A, W2
002848  500FF0     SUB W0, #0x10, [W15]
00284A  32000B     BRA Z, 0x2862
00284C  200302     MOV #0x30, W2
00284E  370009     BRA 0x2862
346:                           return USB_DEVICE_SUSPENDED;
347:                       } else {
348:                           return USB_DEVICE_ATTACHED;
349:                       }
350:                   }
351:               
352:                   if ((usbHostState & STATE_MASK) == STATE_HOLDING) {
002850  807640     MOV usbHostState, W0
002852  20F001     MOV #0xF00, W1
002854  600001     AND W0, W1, W0
002856  200322     MOV #0x32, W2
002858  205001     MOV #0x500, W1
00285A  500F81     SUB W0, W1, [W15]
00285C  3A0002     BRA NZ, 0x2862
353:                       return usbDeviceInfo.errorCode;
00285E  BFCED4     MOV.B 0xED4, WREG
002860  FB8100     ZE W0, W2
354:                   }
355:               
356:                   return USB_DEVICE_ENUMERATING;
357:               }
002862  780002     MOV W2, W0
002864  060000     RETURN
358:               
359:               /****************************************************************************
360:                 Function:
361:                   BOOL USBHostInit(  unsigned long flags  )
362:               
363:                 Summary:
364:                   This function initializes the variables of the USB host stack.
365:               
366:                 Description:
367:                   This function initializes the variables of the USB host stack.  It does
368:                   not initialize the hardware.  The peripheral itself is initialized in one
369:                   of the state machine states.  Therefore, USBHostTasks() should be called
370:                   soon after this function.
371:               
372:                 Precondition:
373:                   None
374:               
375:                 Parameters:
376:                   flags - reserved
377:               
378:                 Return Values:
379:                   TRUE  - Initialization successful
380:                   FALSE - Could not allocate memory.
381:               
382:                 Remarks:
383:                   If the endpoint list is empty, an entry is created in the endpoint list
384:                   for EP0.  If the list is not empty, free all allocated memory other than
385:                   the EP0 node.  This allows the routine to be called multiple times by the
386:                   application.
387:                ***************************************************************************/
388:               
389:               BOOL USBHostInit(unsigned long flags) {
390:                   // Allocate space for Endpoint 0.  We will initialize it in the state machine,
391:                   // so we can reinitialize when another device connects.  If the Endpoint 0
392:                   // node already exists, free all other allocated memory.
393:                   if (usbDeviceInfo.pEndpoint0 == NULL) {
002866  E20EDC     CP0 0xEDC
002868  3A0007     BRA NZ, 0x2878
394:                       if ((usbDeviceInfo.pEndpoint0 = (USB_ENDPOINT_INFO*) USB_MALLOC(sizeof (USB_ENDPOINT_INFO))) == NULL) {
00286A  200220     MOV #0x22, W0
00286C  07ED3A     RCALL _malloc
00286E  8876E0     MOV W0, 0xEDC
002870  E00000     CP0 W0
002872  320012     BRA Z, 0x2898
395:               #ifdef DEBUG_MODE
396:                           UART2PrintString("HOST: Cannot allocate for endpoint 0.\r\n");
397:               #endif
398:                           //return USB_MEMORY_ALLOCATION_ERROR;
399:                           return FALSE;
400:                       }
401:                       usbDeviceInfo.pEndpoint0->next = NULL;
002874  EB0800     CLR [W0]
002876  370001     BRA 0x287A
402:                   } else {
403:                       _USB_FreeMemory();
002878  070B22     RCALL _USB_FreeMemory
404:                   }
405:               
406:                   // Initialize other variables.
407:                   pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
00287A  8076E0     MOV 0xEDC, W0
00287C  887630     MOV W0, pCurrentEndpoint
408:                   usbHostState = STATE_DETACHED;
00287E  EB0080     CLR W1
002880  887641     MOV W1, usbHostState
409:                   usbOverrideHostState = NO_STATE;
002882  EFAF18     SETM usbOverrideHostState
410:                   usbDeviceInfo.deviceAddressAndSpeed = 0;
002884  FD0080     EXCH W0, W1
002886  B7EED2     MOV.B WREG, 0xED2
002888  B7EED3     MOV.B WREG, 0xED3
00288A  FD0080     EXCH W0, W1
411:                   usbDeviceInfo.deviceAddress = 0;
412:                   usbRootHubInfo.flags.bPowerGoodPort0 = 1;
00288C  A80F16     BSET usbRootHubInfo, #0
413:               
414:                   // Initialize event queue
415:               #if defined( USB_ENABLE_TRANSFER_EVENT )
416:                   StructQueueInit(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
00288E  200040     MOV #0x4, W0
002890  887700     MOV W0, usbEventQueue
002892  887710     MOV W0, 0xEE2
002894  887721     MOV W1, 0xEE4
002896  200010     MOV #0x1, W0
417:               #endif
418:               
419:                   return TRUE;
420:               }
002898  060000     RETURN
421:               
422:               
423:               /****************************************************************************
424:                 Function:
425:                   BOOL USBHostIsochronousBuffersCreate( ISOCHRONOUS_DATA * isocData, 
426:                           BYTE numberOfBuffers, WORD bufferSize )
427:                   
428:                 Description:
429:                   This function initializes the isochronous data buffer information and
430:                   allocates memory for each buffer.  This function will not allocate memory
431:                   if the buffer pointer is not NULL.
432:               
433:                 Precondition:
434:                   None
435:               
436:                 Parameters:
437:                   None
438:               
439:                 Return Values:
440:                   TRUE    - All buffers are allocated successfully.
441:                   FALSE   - Not enough heap space to allocate all buffers - adjust the 
442:                               project to provide more heap space.
443:               
444:                 Remarks:
445:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
446:                   is defined in usb_config.h.
447:                ***************************************************************************/
448:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
449:               
450:               BOOL USBHostIsochronousBuffersCreate(ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers, WORD bufferSize) {
451:                   BYTE i;
452:                   BYTE j;
453:               
454:                   USBHostIsochronousBuffersReset(isocData, numberOfBuffers);
455:                   for (i = 0; i < numberOfBuffers; i++) {
456:                       if (isocData->buffers[i].pBuffer == NULL) {
457:                           isocData->buffers[i].pBuffer = USB_MALLOC(bufferSize);
458:                           if (isocData->buffers[i].pBuffer == NULL) {
459:               #ifdef DEBUG_MODE
460:                               UART2PrintString("HOST:  Not enough memory for isoc buffers.\r\n");
461:               #endif
462:               
463:                               // Release all previous buffers.
464:                               for (j = 0; j < i; j++) {
465:                                   USB_FREE_AND_CLEAR(isocData->buffers[j].pBuffer);
466:                                   isocData->buffers[j].pBuffer = NULL;
467:                               }
468:                               return FALSE;
469:                           }
470:                       }
471:                   }
472:                   return TRUE;
473:               }
474:               #endif
475:               
476:               /****************************************************************************
477:                 Function:
478:                   void USBHostIsochronousBuffersDestroy( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
479:                   
480:                 Description:
481:                   This function releases all of the memory allocated for the isochronous
482:                   data buffers.  It also resets all other information about the buffers.
483:               
484:                 Precondition:
485:                   None
486:               
487:                 Parameters:
488:                   None
489:               
490:                 Returns:
491:                   None
492:               
493:                 Remarks:
494:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
495:                   is defined in usb_config.h.
496:                ***************************************************************************/
497:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
498:               
499:               void USBHostIsochronousBuffersDestroy(ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers) {
500:                   BYTE i;
501:               
502:                   USBHostIsochronousBuffersReset(isocData, numberOfBuffers);
503:                   for (i = 0; i < numberOfBuffers; i++) {
504:                       if (isocData->buffers[i].pBuffer != NULL) {
505:                           USB_FREE_AND_CLEAR(isocData->buffers[i].pBuffer);
506:                           isocData->buffers[i].pBuffer = NULL;
507:                       }
508:                   }
509:               }
510:               #endif
511:               
512:               
513:               /****************************************************************************
514:                 Function:
515:                   void USBHostIsochronousBuffersReset( ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers )
516:                   
517:                 Description:
518:                   This function resets all the isochronous data buffers.  It does not do 
519:                   anything with the space allocated for the buffers.
520:               
521:                 Precondition:
522:                   None
523:               
524:                 Parameters:
525:                   None
526:               
527:                 Returns:
528:                   None
529:               
530:                 Remarks:
531:                   This function is available only if USB_SUPPORT_ISOCHRONOUS_TRANSFERS
532:                   is defined in usb_config.h.
533:                ***************************************************************************/
534:               #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
535:               
536:               void USBHostIsochronousBuffersReset(ISOCHRONOUS_DATA * isocData, BYTE numberOfBuffers) {
537:                   BYTE i;
538:               
539:                   for (i = 0; i < numberOfBuffers; i++) {
540:                       isocData->buffers[i].dataLength = 0;
541:                       isocData->buffers[i].bfDataLengthValid = 0;
542:                   }
543:               
544:                   isocData->totalBuffers = numberOfBuffers;
545:                   isocData->currentBufferUser = 0;
546:                   isocData->currentBufferUSB = 0;
547:                   isocData->pDataUser = NULL;
548:               }
549:               #endif
550:               
551:               /****************************************************************************
552:                 Function:
553:                   BYTE USBHostIssueDeviceRequest( BYTE deviceAddress, BYTE bmRequestType,
554:                                   BYTE bRequest, WORD wValue, WORD wIndex, WORD wLength,
555:                                   BYTE *data, BYTE dataDirection, BYTE clientDriverID )
556:               
557:                 Summary:
558:                   This function sends a standard device request to the attached device.
559:               
560:                 Description:
561:                   This function sends a standard device request to the attached device.
562:                   The user must pass in the parameters of the device request.  If there is
563:                   input or output data associated with the request, a pointer to the data
564:                   must be provided.  The direction of the associated data (input or output)
565:                   must also be indicated.
566:               
567:                   This function does no special processing in regards to the request except
568:                   for three requests.  If SET INTERFACE is sent, then DTS is reset for all
569:                   endpoints.  If CLEAR FEATURE (ENDPOINT HALT) is sent, then DTS is reset
570:                   for that endpoint.  If SET CONFIGURATION is sent, the request is aborted
571:                   with a failure.  The function USBHostSetDeviceConfiguration() must be
572:                   called to change the device configuration, since endpoint definitions may
573:                   change.
574:               
575:                 Precondition:
576:                   The host state machine should be in the running state, and no reads or
577:                   writes to EP0 should be in progress.
578:               
579:                 Parameters:
580:                   BYTE deviceAddress  - Device address
581:                   BYTE bmRequestType  - The request type as defined by the USB
582:                                           specification.
583:                   BYTE bRequest       - The request as defined by the USB specification.
584:                   WORD wValue         - The value for the request as defined by the USB
585:                                           specification.
586:                   WORD wIndex         - The index for the request as defined by the USB
587:                                           specification.
588:                   WORD wLength        - The data length for the request as defined by the
589:                                           USB specification.
590:                   BYTE *data          - Pointer to the data for the request.
591:                   BYTE dataDirection  - USB_DEVICE_REQUEST_SET or USB_DEVICE_REQUEST_GET
592:                   BYTE clientDriverID - Client driver to send the event to.
593:               
594:                 Return Values:
595:                   USB_SUCCESS                 - Request processing started
596:                   USB_UNKNOWN_DEVICE          - Device not found
597:                   USB_INVALID_STATE           - The host must be in a normal running state
598:                                                   to do this request
599:                   USB_ENDPOINT_BUSY           - A read or write is already in progress
600:                   USB_ILLEGAL_REQUEST         - SET CONFIGURATION cannot be performed with
601:                                                   this function.
602:               
603:                 Remarks:
604:                   DTS reset is done before the command is issued.
605:                ***************************************************************************/
606:               
607:               BYTE USBHostIssueDeviceRequest(BYTE deviceAddress, BYTE bmRequestType, BYTE bRequest,
608:                       WORD wValue, WORD wIndex, WORD wLength, BYTE *data, BYTE dataDirection,
609:                       BYTE clientDriverID) {
00289A  E8878F     INC2 W15, W15
00289C  BE9F88     MOV.D W8, [W15++]
00289E  BE9F8A     MOV.D W10, [W15++]
0028A0  BE9F8C     MOV.D W12, [W15++]
0028A2  781F8E     MOV W14, [W15++]
0028A4  784601     MOV.B W1, W12
0028A6  784402     MOV.B W2, W8
0028A8  780483     MOV W3, W9
0028AA  BE0504     MOV.D W4, W10
0028AC  780706     MOV W6, W14
0028AE  784687     MOV.B W7, W13
610:                   // Find the required device
611:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
0028B0  200062     MOV #0x6, W2
0028B2  E34ED3     CP.B 0xED3
0028B4  3A0073     BRA NZ, 0x299C
612:                       return USB_UNKNOWN_DEVICE;
613:                   }
614:               
615:                   // If we are not in a normal user running state, we cannot do this.
616:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING) {
0028B6  807640     MOV usbHostState, W0
0028B8  20F001     MOV #0xF00, W1
0028BA  600001     AND W0, W1, W0
0028BC  200012     MOV #0x1, W2
0028BE  204001     MOV #0x400, W1
0028C0  500F81     SUB W0, W1, [W15]
0028C2  3A006C     BRA NZ, 0x299C
617:                       return USB_INVALID_STATE;
618:                   }
619:               
620:                   // Make sure no other reads or writes on EP0 are in progress.
621:                   if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
0028C4  8076E0     MOV 0xEDC, W0
0028C6  904030     MOV.B [W0+3], W0
0028C8  200102     MOV #0x10, W2
0028CA  A31800     BTST.Z W0, #1
0028CC  320067     BRA Z, 0x299C
622:                       return USB_ENDPOINT_BUSY;
623:                   }
624:               
625:                   // We can't do a SET CONFIGURATION here.  Must use USBHostSetDeviceConfiguration().
626:                   // ***** Some USB classes need to be able to do this, so we'll remove
627:                   // the constraint.
628:                   //    if (bRequest == USB_REQUEST_SET_CONFIGURATION)
629:                   //    {
630:                   //        return USB_ILLEGAL_REQUEST;
631:                   //    }
632:               
633:                   // If the user is doing a SET INTERFACE, we must reset DATA0 for all endpoints.
634:                   if (bRequest == USB_REQUEST_SET_INTERFACE) {
0028CE  544FEB     SUB.B W8, #0xB, [W15]
0028D0  3A0025     BRA NZ, 0x291C
635:                       USB_ENDPOINT_INFO *pEndpoint;
636:                       USB_INTERFACE_INFO *pInterface;
637:                       USB_INTERFACE_SETTING_INFO *pSetting;
638:               
639:                       // Make sure there are no transfers currently in progress on the current
640:                       // interface setting.
641:                       pInterface = usbDeviceInfo.pInterfaceList;
0028D2  8076D2     MOV 0xEDA, W2
642:                       while (pInterface && (pInterface->interface != wIndex)) {
0028D4  E00002     CP0 W2
0028D6  320052     BRA Z, 0x297C
0028D8  370053     BRA 0x2980
0028DC  E00002     CP0 W2
0028DE  32004E     BRA Z, 0x297C
0028E0  904062     MOV.B [W2+6], W0
0028E2  FB8000     ZE W0, W0
0028E4  550F80     SUB W10, W0, [W15]
0028E6  3AFFF9     BRA NZ, 0x28DA
002980  904062     MOV.B [W2+6], W0
002982  FB8000     ZE W0, W0
002984  520F80     SUB W4, W0, [W15]
002986  3AFFA9     BRA NZ, 0x28DA
002988  37FFAF     BRA 0x28E8
643:                           pInterface = pInterface->next;
0028DA  780112     MOV [W2], W2
644:                       }
645:                       if ((pInterface == NULL) || (pInterface->pCurrentSetting == NULL)) {
0028E8  900022     MOV [W2+4], W0
0028EA  E00000     CP0 W0
0028EC  320047     BRA Z, 0x297C
646:                           // The specified interface was not found.
647:                           return USB_ILLEGAL_REQUEST;
648:                       }
649:                       pEndpoint = pInterface->pCurrentSetting->pEndpointList;
0028EE  9000A0     MOV [W0+4], W1
650:                       while (pEndpoint) {
0028F0  E00001     CP0 W1
0028F2  3A004B     BRA NZ, 0x298A
0028F4  370006     BRA 0x2902
0028FE  E00001     CP0 W1
002900  3AFFFA     BRA NZ, 0x28F6
651:                           if (!pEndpoint->status.bfTransferComplete) {
0028F6  904031     MOV.B [W1+3], W0
0028F8  A31800     BTST.Z W0, #1
0028FA  320040     BRA Z, 0x297C
00298A  904031     MOV.B [W1+3], W0
00298C  A31800     BTST.Z W0, #1
00298E  3AFFB6     BRA NZ, 0x28FC
002990  37FFF5     BRA 0x297C
652:                               // An endpoint on this setting is still transferring data.
653:                               return USB_ILLEGAL_REQUEST;
654:                           }
655:                           pEndpoint = pEndpoint->next;
0028FC  780091     MOV [W1], W1
656:                       }
657:               
658:                       // Make sure the new setting is valid.
659:                       pSetting = pInterface->pInterfaceSettings;
002902  900092     MOV [W2+2], W1
660:                       while (pSetting && (pSetting->interfaceAltSetting != wValue)) {
002904  E00001     CP0 W1
002906  32003A     BRA Z, 0x297C
002908  370044     BRA 0x2992
00290C  E00001     CP0 W1
00290E  320036     BRA Z, 0x297C
002910  904021     MOV.B [W1+2], W0
002912  FB8000     ZE W0, W0
002914  548F80     SUB W9, W0, [W15]
002916  3AFFF9     BRA NZ, 0x290A
002992  904021     MOV.B [W1+2], W0
002994  FB8000     ZE W0, W0
002996  548F80     SUB W9, W0, [W15]
002998  3AFFB8     BRA NZ, 0x290A
00299A  37FFBE     BRA 0x2918
661:                           pSetting = pSetting->next;
00290A  780091     MOV [W1], W1
662:                       }
663:                       if (pSetting == NULL) {
664:                           return USB_ILLEGAL_REQUEST;
665:                       }
666:               
667:                       // Set the pointer to the new setting.
668:                       pInterface->pCurrentSetting = pSetting;
002918  980121     MOV W1, [W2+4]
00291A  370008     BRA 0x292C
669:                   }
670:               
671:                   // If the user is doing a CLEAR FEATURE(ENDPOINT_HALT), we must reset DATA0 for that endpoint.
672:                   if ((bRequest == USB_REQUEST_CLEAR_FEATURE) && (wValue == USB_FEATURE_ENDPOINT_HALT)) {
00291C  544FE1     SUB.B W8, #0x1, [W15]
00291E  3A0006     BRA NZ, 0x292C
002920  E00003     CP0 W3
002922  3A0004     BRA NZ, 0x292C
673:                       switch (bmRequestType) {
002924  564FE2     SUB.B W12, #0x2, [W15]
002926  3E0002     BRA GTU, 0x292C
674:                           case 0x00:
675:                           case 0x01:
676:                           case 0x02:
677:                               _USB_ResetDATA0((BYTE) wIndex);
002928  784004     MOV.B W4, W0
00292A  070D1F     RCALL _USB_ResetDATA0
678:                               break;
679:                           default:
680:                               break;
681:                       }
682:                   }
683:               
684:                   // Set up the control packet.
685:                   pEP0Data[0] = bmRequestType;
00292C  8075D0     MOV pEP0Data, W0
00292E  78480C     MOV.B W12, [W0]
686:                   pEP0Data[1] = bRequest;
002930  8075D0     MOV pEP0Data, W0
002932  984018     MOV.B W8, [W0+1]
687:                   pEP0Data[2] = wValue & 0xFF;
002934  8075D0     MOV pEP0Data, W0
002936  984029     MOV.B W9, [W0+2]
688:                   pEP0Data[3] = (wValue >> 8) & 0xFF;
002938  DE48C8     LSR W9, #8, W1
00293A  8075D0     MOV pEP0Data, W0
00293C  984031     MOV.B W1, [W0+3]
689:                   pEP0Data[4] = wIndex & 0xFF;
00293E  8075D0     MOV pEP0Data, W0
002940  98404A     MOV.B W10, [W0+4]
690:                   pEP0Data[5] = (wIndex >> 8) & 0xFF;
002942  DE50C8     LSR W10, #8, W1
002944  8075D0     MOV pEP0Data, W0
002946  984051     MOV.B W1, [W0+5]
691:                   pEP0Data[6] = wLength & 0xFF;
002948  8075D0     MOV pEP0Data, W0
00294A  98406B     MOV.B W11, [W0+6]
692:                   pEP0Data[7] = (wLength >> 8) & 0xFF;
00294C  DE58C8     LSR W11, #8, W1
00294E  8075D0     MOV pEP0Data, W0
002950  984071     MOV.B W1, [W0+7]
693:               
694:                   // Set up the client driver for the event.
695:                   usbDeviceInfo.pEndpoint0->clientDriver = clientDriverID;
002952  8076E0     MOV 0xEDC, W0
002954  97E8AF     MOV.B [W15-22], W1
002956  985811     MOV.B W1, [W0+25]
696:               
697:                   if (dataDirection == USB_DEVICE_REQUEST_SET) {
002958  E0040D     CP0.B W13
00295A  3A0008     BRA NZ, 0x296C
698:                       // We are doing a SET command that requires data be sent.
699:                       _USB_InitControlWrite(usbDeviceInfo.pEndpoint0, pEP0Data, 8, data, wLength);
00295C  8075D1     MOV pEP0Data, W1
00295E  8076E0     MOV 0xEDC, W0
002960  78020B     MOV W11, W4
002962  78018E     MOV W14, W3
002964  200082     MOV #0x8, W2
002966  070AEB     RCALL _USB_InitControlWrite
002968  EB0100     CLR W2
00296A  370018     BRA 0x299C
700:                   } else {
701:                       // We are doing a GET request.
702:                       _USB_InitControlRead(usbDeviceInfo.pEndpoint0, pEP0Data, 8, data, wLength);
00296C  8075D1     MOV pEP0Data, W1
00296E  8076E0     MOV 0xEDC, W0
002970  78020B     MOV W11, W4
002972  78018E     MOV W14, W3
002974  200082     MOV #0x8, W2
002976  070ABF     RCALL _USB_InitControlRead
002978  EB0100     CLR W2
00297A  370010     BRA 0x299C
00297C  200032     MOV #0x3, W2
00297E  37000E     BRA 0x299C
703:                   }
704:               
705:                   return USB_SUCCESS;
706:               }
00299C  780002     MOV W2, W0
00299E  78074F     MOV [--W15], W14
0029A0  BE064F     MOV.D [--W15], W12
0029A2  BE054F     MOV.D [--W15], W10
0029A4  BE044F     MOV.D [--W15], W8
0029A6  B1002F     SUB #0x2, W15
0029A8  060000     RETURN
707:               
708:               /****************************************************************************
709:                 Function:
710:                   BYTE USBHostRead( BYTE deviceAddress, BYTE endpoint, BYTE *pData,
711:                                       DWORD size )
712:                 Summary:
713:                   This function initiates a read from the attached device.
714:               
715:                 Description:
716:                   This function initiates a read from the attached device.
717:               
718:                   If the endpoint is isochronous, special conditions apply.  The pData and
719:                   size parameters have slightly different meanings, since multiple buffers
720:                   are required.  Once started, an isochronous transfer will continue with
721:                   no upper layer intervention until USBHostTerminateTransfer() is called.
722:                   The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
723:                   the transfer is terminated.
724:               
725:                   To clarify parameter usage and to simplify casting, use the macro
726:                   USBHostReadIsochronous() when reading from an isochronous endpoint.
727:               
728:                 Precondition:
729:                   None
730:               
731:                 Parameters:
732:                   BYTE deviceAddress  - Device address
733:                   BYTE endpoint       - Endpoint number
734:                   BYTE *pData         - Pointer to where to store the data. If the endpoint
735:                                           is isochronous, this points to an
736:                                           ISOCHRONOUS_DATA_BUFFERS structure, with multiple
737:                                           data buffer pointers.
738:                   DWORD size          - Number of data bytes to read. If the endpoint is
739:                                           isochronous, this is the number of data buffer
740:                                           pointers pointed to by pData.
741:               
742:                 Return Values:
743:                   USB_SUCCESS                     - Read started successfully.
744:                   USB_UNKNOWN_DEVICE              - Device with the specified address not found.
745:                   USB_INVALID_STATE               - We are not in a normal running state.
746:                   USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlRead to read
747:                                                       from a control endpoint.
748:                   USB_ENDPOINT_ILLEGAL_DIRECTION  - Must read from an IN endpoint.
749:                   USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
750:                                                       by the application.
751:                   USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
752:                                                       cleared by the application.
753:                   USB_ENDPOINT_BUSY               - A Read is already in progress.
754:                   USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
755:               
756:                 Remarks:
757:                   None
758:                ***************************************************************************/
759:               
760:               BYTE USBHostRead(BYTE deviceAddress, BYTE endpoint, BYTE *pData, DWORD size) {
0029AA  BE9F88     MOV.D W8, [W15++]
0029AC  781F8A     MOV W10, [W15++]
0029AE  784181     MOV.B W1, W3
0029B0  780502     MOV W2, W10
0029B2  BE0404     MOV.D W4, W8
761:                   USB_ENDPOINT_INFO *ep;
762:               
763:                   // Find the required device
764:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
0029B4  200062     MOV #0x6, W2
0029B6  E34ED3     CP.B 0xED3
0029B8  3A0026     BRA NZ, 0x2A06
765:                       return USB_UNKNOWN_DEVICE;
766:                   }
767:               
768:                   // If we are not in a normal user running state, we cannot do this.
769:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING) {
0029BA  807640     MOV usbHostState, W0
0029BC  20F001     MOV #0xF00, W1
0029BE  600001     AND W0, W1, W0
0029C0  200012     MOV #0x1, W2
0029C2  204001     MOV #0x400, W1
0029C4  500F81     SUB W0, W1, [W15]
0029C6  3A001F     BRA NZ, 0x2A06
770:                       return USB_INVALID_STATE;
771:                   }
772:               
773:                   ep = _USB_FindEndpoint(endpoint);
0029C8  784003     MOV.B W3, W0
0029CA  07062B     RCALL _USB_FindEndpoint
0029CC  780180     MOV W0, W3
774:                   if (ep) {
0029CE  200142     MOV #0x14, W2
0029D0  E00000     CP0 W0
0029D2  320019     BRA Z, 0x2A06
775:                       if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL) {
0029D4  900850     MOV [W0+26], W0
0029D6  B23000     AND #0x300, W0
0029D8  200182     MOV #0x18, W2
0029DA  320015     BRA Z, 0x2A06
776:                           // Must not be a control endpoint.
777:                           return USB_ENDPOINT_ILLEGAL_TYPE;
778:                       }
779:               
780:                       if (!(ep->bEndpointAddress & 0x80)) {
0029DC  905823     MOV.B [W3+26], W0
0029DE  200152     MOV #0x15, W2
0029E0  E00400     CP0.B W0
0029E2  3D0011     BRA GE, 0x2A06
781:                           // Trying to do an IN with an OUT endpoint.
782:                           return USB_ENDPOINT_ILLEGAL_DIRECTION;
783:                       }
784:               
785:                       if (ep->status.bfStalled) {
0029E4  904023     MOV.B [W3+2], W0
0029E6  200112     MOV #0x11, W2
0029E8  A35800     BTST.Z W0, #5
0029EA  3A000D     BRA NZ, 0x2A06
786:                           // The endpoint is stalled.  It must be restarted before a write
787:                           // can be performed.
788:                           return USB_ENDPOINT_STALLED;
789:                       }
790:               
791:                       if (ep->status.bfError) {
0029EC  904023     MOV.B [W3+2], W0
0029EE  200122     MOV #0x12, W2
0029F0  A36800     BTST.Z W0, #6
0029F2  3A0009     BRA NZ, 0x2A06
792:                           // The endpoint has errored.  The error must be cleared before a
793:                           // write can be performed.
794:                           return USB_ENDPOINT_ERROR;
795:                       }
796:               
797:                       if (!ep->status.bfTransferComplete) {
0029F4  904033     MOV.B [W3+3], W0
0029F6  200102     MOV #0x10, W2
0029F8  A31800     BTST.Z W0, #1
0029FA  320005     BRA Z, 0x2A06
798:                           // We are already processing a request for this endpoint.
799:                           return USB_ENDPOINT_BUSY;
800:                       }
801:               
802:                       _USB_InitRead(ep, pData, size);
0029FC  780108     MOV W8, W2
0029FE  78008A     MOV W10, W1
002A00  780003     MOV W3, W0
002A02  070AC9     RCALL _USB_InitRead
002A04  EB0100     CLR W2
803:               
804:                       return USB_SUCCESS;
805:                   }
806:                   return USB_ENDPOINT_NOT_FOUND; // Endpoint not found
807:               }
002A06  780002     MOV W2, W0
002A08  78054F     MOV [--W15], W10
002A0A  BE044F     MOV.D [--W15], W8
002A0C  060000     RETURN
808:               
809:               /****************************************************************************
810:                 Function:
811:                   BYTE USBHostResetDevice( BYTE deviceAddress )
812:               
813:                 Summary:
814:                   This function resets an attached device.
815:               
816:                 Description:
817:                   This function places the device back in the RESET state, to issue RESET
818:                   signaling.  It can be called only if the state machine is not in the
819:                   DETACHED state.
820:               
821:                 Precondition:
822:                   None
823:               
824:                 Parameters:
825:                   BYTE deviceAddress  - Device address
826:               
827:                 Return Values:
828:                   USB_SUCCESS         - Success
829:                   USB_UNKNOWN_DEVICE  - Device not found
830:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
831:               
832:                 Remarks:
833:                   In order to do a full clean-up, the state is set back to STATE_DETACHED
834:                   rather than a reset state.  The ATTACH interrupt will automatically be
835:                   triggered when the module is re-enabled, and the proper reset will be
836:                   performed.
837:                ***************************************************************************/
838:               
839:               BYTE USBHostResetDevice(BYTE deviceAddress) {
840:                   // Find the required device
841:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
002A0E  200061     MOV #0x6, W1
002A10  E34ED3     CP.B 0xED3
002A12  3A0008     BRA NZ, 0x2A24
842:                       return USB_UNKNOWN_DEVICE;
843:                   }
844:               
845:                   if ((usbHostState & STATE_MASK) == STATE_DETACHED) {
002A14  807640     MOV usbHostState, W0
002A16  20F001     MOV #0xF00, W1
002A18  600001     AND W0, W1, W0
002A1A  200031     MOV #0x3, W1
002A1C  320003     BRA Z, 0x2A24
846:                       return USB_ILLEGAL_REQUEST;
847:                   }
848:               
849:                   usbHostState = STATE_DETACHED;
002A1E  EB0000     CLR W0
002A20  887640     MOV W0, usbHostState
002A22  780080     MOV W0, W1
850:               
851:                   return USB_SUCCESS;
852:               }
002A24  780001     MOV W1, W0
002A26  060000     RETURN
853:               
854:               /****************************************************************************
855:                 Function:
856:                   BYTE USBHostResumeDevice( BYTE deviceAddress )
857:               
858:                 Summary:
859:                   This function issues a RESUME to the attached device.
860:               
861:                 Description:
862:                   This function issues a RESUME to the attached device.  It can called only
863:                   if the state machine is in the suspend state.
864:               
865:                 Precondition:
866:                   None
867:               
868:                 Parameters:
869:                   BYTE deviceAddress  - Device address
870:               
871:                 Return Values:
872:                   USB_SUCCESS         - Success
873:                   USB_UNKNOWN_DEVICE  - Device not found
874:                   USB_ILLEGAL_REQUEST - Device cannot RESUME unless it is suspended
875:               
876:                 Remarks:
877:                   None
878:                ***************************************************************************/
879:               
880:               BYTE USBHostResumeDevice(BYTE deviceAddress) {
881:                   // Find the required device
882:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
002A28  200062     MOV #0x6, W2
002A2A  E34ED3     CP.B 0xED3
002A2C  3A0007     BRA NZ, 0x2A3C
883:                       return USB_UNKNOWN_DEVICE;
884:                   }
885:               
886:                   if (usbHostState != (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND)) {
002A2E  807641     MOV usbHostState, W1
002A30  200032     MOV #0x3, W2
002A32  204100     MOV #0x410, W0
002A34  508F80     SUB W1, W0, [W15]
002A36  3A0002     BRA NZ, 0x2A3C
887:                       return USB_ILLEGAL_REQUEST;
888:                   }
889:               
890:                   // Advance the state machine to issue resume signalling.
891:                   _USB_SetNextSubSubState();
002A38  EC2EC8     INC usbHostState
002A3A  EB0100     CLR W2
892:               
893:                   return USB_SUCCESS;
894:               }
002A3C  780002     MOV W2, W0
002A3E  060000     RETURN
895:               
896:               /****************************************************************************
897:                 Function:
898:                   BYTE USBHostSetDeviceConfiguration( BYTE deviceAddress, BYTE configuration )
899:               
900:                 Summary:
901:                   This function changes the device's configuration.
902:               
903:                 Description:
904:                   This function is used by the application to change the device's
905:                   Configuration.  This function must be used instead of
906:                   USBHostIssueDeviceRequest(), because the endpoint definitions may change.
907:               
908:                   To see when the reconfiguration is complete, use the USBHostDeviceStatus()
909:                   function.  If configuration is still in progress, this function will
910:                   return USB_DEVICE_ENUMERATING.
911:               
912:                 Precondition:
913:                   The host state machine should be in the running state, and no reads or
914:                   writes should be in progress.
915:               
916:                 Parameters:
917:                   BYTE deviceAddress  - Device address
918:                   BYTE configuration  - Index of the new configuration
919:               
920:                 Return Values:
921:                   USB_SUCCESS         - Process of changing the configuration was started
922:                                           successfully.
923:                   USB_UNKNOWN_DEVICE  - Device not found
924:                   USB_INVALID_STATE   - This function cannot be called during enumeration
925:                                           or while performing a device request.
926:                   USB_BUSY            - No IN or OUT transfers may be in progress.
927:               
928:                 Example:
929:                   <code>
930:                   rc = USBHostSetDeviceConfiguration( attachedDevice, configuration );
931:                   if (rc)
932:                   {
933:                       // Error - cannot set configuration.
934:                   }
935:                   else
936:                   {
937:                       while (USBHostDeviceStatus( attachedDevice ) == USB_DEVICE_ENUMERATING)
938:                       {
939:                           USBHostTasks();
940:                       }
941:                   }
942:                   if (USBHostDeviceStatus( attachedDevice ) != USB_DEVICE_ATTACHED)
943:                   {
944:                       // Error - cannot set configuration.
945:                   }
946:                   </code>
947:               
948:                 Remarks:
949:                   If an invalid configuration is specified, this function cannot return
950:                   an error.  Instead, the event USB_UNSUPPORTED_DEVICE will the sent to the
951:                   application layer and the device will be placed in a holding state with a
952:                   USB_HOLDING_UNSUPPORTED_DEVICE error returned by USBHostDeviceStatus().
953:                ***************************************************************************/
954:               
955:               BYTE USBHostSetDeviceConfiguration(BYTE deviceAddress, BYTE configuration) {
002A40  781F88     MOV W8, [W15++]
002A42  784401     MOV.B W1, W8
956:                   // Find the required device
957:                   if (deviceAddress != usbDeviceInfo.deviceAddress) {
002A44  200062     MOV #0x6, W2
002A46  E34ED3     CP.B 0xED3
002A48  3A0013     BRA NZ, 0x2A70
958:                       return USB_UNKNOWN_DEVICE;
959:                   }
960:               
961:                   // If we are not in a normal user running state, we cannot do this.
962:                   if ((usbHostState & STATE_MASK) != STATE_RUNNING) {
002A4A  807640     MOV usbHostState, W0
002A4C  20F001     MOV #0xF00, W1
002A4E  600001     AND W0, W1, W0
002A50  200012     MOV #0x1, W2
002A52  204001     MOV #0x400, W1
002A54  500F81     SUB W0, W1, [W15]
002A56  3A000C     BRA NZ, 0x2A70
963:                       return USB_INVALID_STATE;
964:                   }
965:               
966:                   // Make sure no other reads or writes are in progress.
967:                   if (_USB_TransferInProgress()) {
002A58  070D46     RCALL _USB_TransferInProgress
002A5A  200022     MOV #0x2, W2
002A5C  E00000     CP0 W0
002A5E  3A0008     BRA NZ, 0x2A70
968:                       return USB_BUSY;
969:                   }
970:               
971:                   // Set the new device configuration.
972:                   usbDeviceInfo.currentConfiguration = configuration;
002A60  780008     MOV W8, W0
002A62  B7EED0     MOV.B WREG, 0xED0
973:               
974:                   // We're going to be sending Endpoint 0 commands, so be sure the
975:                   // client driver indicates the host driver, so we do not send events up
976:                   // to a client driver.
977:                   usbDeviceInfo.pEndpoint0->clientDriver = CLIENT_DRIVER_HOST;
002A64  EBC000     SETM.B W0
002A66  8076E1     MOV 0xEDC, W1
002A68  985890     MOV.B W0, [W1+25]
978:               
979:                   // Set the state back to configure the device.  This will destroy the
980:                   // endpoint list and terminate any current transactions.  We already have
981:                   // the configuration, so we can jump into the Select Configuration state.
982:                   // If the configuration value is invalid, the state machine will error and
983:                   // put the device into a holding state.
984:                   usbHostState = STATE_CONFIGURING | SUBSTATE_SELECT_CONFIGURATION;
002A6A  203300     MOV #0x330, W0
002A6C  887640     MOV W0, usbHostState
002A6E  EB0100     CLR W2
985:               
986:                   return USB_SUCCESS;
987:               }
002A70  780002     MOV W2, W0
002A72  78044F     MOV [--W15], W8
002A74  060000     RETURN
988:               
989:               /****************************************************************************
990:                 Function:
991:                   BYTE USBHostSetNAKTimeout( BYTE deviceAddress, BYTE endpoint, WORD flags,
992:                               WORD timeoutCount )
993:               
994:                 Summary:
995:                   This function specifies NAK timeout capability.
996:               
997:                 Description:
998:                   This function is used to set whether or not an endpoint on a device
999:                   should time out a transaction based on the number of NAKs received, and
1000:                  if so, how many NAKs are allowed before the timeout.
1001:              
1002:                Precondition:
1003:                  None
1004:              
1005:                Parameters:
1006:                  BYTE deviceAddress  - Device address
1007:                  BYTE endpoint       - Endpoint number to configure
1008:                  WORD flags          - Bit 0:
1009:               * 0 = disable NAK timeout
1010:               * 1 = enable NAK timeout
1011:                  WORD timeoutCount   - Number of NAKs allowed before a timeout
1012:              
1013:                Return Values:
1014:                  USB_SUCCESS             - NAK timeout was configured successfully.
1015:                  USB_UNKNOWN_DEVICE      - Device not found.
1016:                  USB_ENDPOINT_NOT_FOUND  - The specified endpoint was not found.
1017:              
1018:                Remarks:
1019:                  None
1020:               ***************************************************************************/
1021:              
1022:              BYTE USBHostSetNAKTimeout(BYTE deviceAddress, BYTE endpoint, WORD flags, WORD timeoutCount) {
002A76  BE9F88     MOV.D W8, [W15++]
002A78  BE0402     MOV.D W2, W8
1023:                  USB_ENDPOINT_INFO *ep;
1024:              
1025:                  // Find the required device
1026:                  if (deviceAddress != usbDeviceInfo.deviceAddress) {
002A7A  200062     MOV #0x6, W2
002A7C  E34ED3     CP.B 0xED3
002A7E  3A000E     BRA NZ, 0x2A9C
1027:                      return USB_UNKNOWN_DEVICE;
1028:                  }
1029:              
1030:                  ep = _USB_FindEndpoint(endpoint);
002A80  784001     MOV.B W1, W0
002A82  0705CF     RCALL _USB_FindEndpoint
002A84  780180     MOV W0, W3
1031:                  if (ep) {
002A86  200142     MOV #0x14, W2
002A88  E00000     CP0 W0
002A8A  320008     BRA Z, 0x2A9C
1032:                      ep->status.bfNAKTimeoutEnabled = flags & 0x01;
002A8C  6440E1     AND.B W8, #0x1, W1
002A8E  DD08C5     SL W1, #5, W1
002A90  904030     MOV.B [W0+3], W0
002A92  A15400     BCLR.B W0, #5
002A94  704001     IOR.B W0, W1, W0
002A96  9841B0     MOV.B W0, [W3+3]
1033:                      ep->timeoutNAKs = timeoutCount;
002A98  981189     MOV W9, [W3+32]
002A9A  EB0100     CLR W2
1034:              
1035:                      return USB_SUCCESS;
1036:                  }
1037:                  return USB_ENDPOINT_NOT_FOUND;
1038:              }
002A9C  780002     MOV W2, W0
002A9E  BE044F     MOV.D [--W15], W8
002AA0  060000     RETURN
1039:              
1040:              /****************************************************************************
1041:                Function:
1042:                  void USBHostShutdown( void )
1043:              
1044:                Description:
1045:                  This function turns off the USB module and frees all unnecessary memory.
1046:                  This routine can be called by the application layer to shut down all
1047:                  USB activity, which effectively detaches all devices.  The event
1048:                  EVENT_DETACH will be sent to the client drivers for the attached device,
1049:                  and the event EVENT_VBUS_RELEASE_POWER will be sent to the application
1050:                  layer.
1051:              
1052:                Precondition:
1053:                  None
1054:              
1055:                Parameters:
1056:                  None - None
1057:              
1058:                Returns:
1059:                  None
1060:              
1061:                Remarks:
1062:                  None
1063:               ***************************************************************************/
1064:              
1065:              void USBHostShutdown(void) {
002AA2  FA0002     LNK #0x2
1066:                  // Shut off the power to the module first, in case we are in an
1067:                  // overcurrent situation.
1068:              
1069:              #ifdef  USB_SUPPORT_OTG
1070:                  if (!USBOTGHnpIsActive()) {
1071:                      // If we currently have an attached device, notify the higher layers that
1072:                      // the device is being removed.
1073:                      if (usbDeviceInfo.deviceAddress) {
1074:                          USB_VBUS_POWER_EVENT_DATA powerRequest;
1075:              
1076:                          powerRequest.port = 0; // Currently was have only one port.
1077:              
1078:                          USB_HOST_APP_EVENT_HANDLER(usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
1079:                                  &powerRequest, sizeof (USB_VBUS_POWER_EVENT_DATA));
1080:                          _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
1081:                                  &usbDeviceInfo.deviceAddress, sizeof (BYTE));
1082:              
1083:              
1084:                      }
1085:                  }
1086:              #else
1087:                  U1PWRC = USB_NORMAL_OPERATION | USB_DISABLED; //MR - Turning off Module will cause unwanted Suspends in OTG
002AA4  EB0080     CLR W1
002AA6  882441     MOV W1, U1PWRC
1088:              
1089:                  // If we currently have an attached device, notify the higher layers that
1090:                  // the device is being removed.
1091:                  if (usbDeviceInfo.deviceAddress) {
002AA8  BFCED3     MOV.B 0xED3, WREG
002AAA  32000B     BRA Z, 0x2AC2
1092:                      USB_VBUS_POWER_EVENT_DATA powerRequest;
1093:              
1094:                      powerRequest.port = 0; // Currently was have only one port.
002AAC  9FFFE1     MOV.B W1, [W15-2]
1095:              
1096:                      USB_HOST_APP_EVENT_HANDLER(usbDeviceInfo.deviceAddress, EVENT_VBUS_RELEASE_POWER,
002AAE  200024     MOV #0x2, W4
002AB0  200005     MOV #0x0, W5
002AB2  E9810F     DEC2 W15, W2
002AB4  2006A1     MOV #0x6A, W1
002AB6  072863     RCALL USB_ApplicationEventHandler
1097:                              &powerRequest, sizeof (USB_VBUS_POWER_EVENT_DATA));
1098:                      _USB_NotifyClients(usbDeviceInfo.deviceAddress, EVENT_DETACH,
002AB8  BFCED3     MOV.B 0xED3, WREG
002ABA  200013     MOV #0x1, W3
002ABC  20ED32     MOV #0xED3, W2
002ABE  200711     MOV #0x71, W1
002AC0  070AC8     RCALL _USB_NotifyClients
1099:                              &usbDeviceInfo.deviceAddress, sizeof (BYTE));
1100:              
1101:              
1102:                  }
1103:              #endif
1104:              
1105:                  // Free all extra allocated memory, initialize variables, and reset the
1106:                  // state machine.
1107:                  USBHostInit(0);
002AC2  B80060     MUL.UU W0, #0, W0
002AC4  07FED0     RCALL USBHostInit
1108:              }
002AC6  FA8000     ULNK
002AC8  060000     RETURN
1109:              
1110:              /****************************************************************************
1111:                Function:
1112:                  BYTE USBHostSuspendDevice( BYTE deviceAddress )
1113:              
1114:                Summary:
1115:                  This function suspends a device.
1116:              
1117:                Description:
1118:                  This function put a device into an IDLE state.  It can only be called
1119:                  while the state machine is in normal running mode.  After 3ms, the
1120:                  attached device should go into SUSPEND mode.
1121:              
1122:                Precondition:
1123:                  None
1124:              
1125:                Parameters:
1126:                  BYTE deviceAddress  - Device to suspend
1127:              
1128:                Return Values:
1129:                  USB_SUCCESS         - Success
1130:                  USB_UNKNOWN_DEVICE  - Device not found
1131:                  USB_ILLEGAL_REQUEST - Cannot suspend unless device is in normal run mode
1132:              
1133:                Remarks:
1134:                  None
1135:               ***************************************************************************/
1136:              
1137:              BYTE USBHostSuspendDevice(BYTE deviceAddress) {
1138:                  // Find the required device
1139:                  if (deviceAddress != usbDeviceInfo.deviceAddress) {
002ACA  200062     MOV #0x6, W2
002ACC  E34ED3     CP.B 0xED3
002ACE  3A0009     BRA NZ, 0x2AE2
1140:                      return USB_UNKNOWN_DEVICE;
1141:                  }
1142:              
1143:                  if (usbHostState != (STATE_RUNNING | SUBSTATE_NORMAL_RUN)) {
002AD0  807641     MOV usbHostState, W1
002AD2  200032     MOV #0x3, W2
002AD4  204000     MOV #0x400, W0
002AD6  508F80     SUB W1, W0, [W15]
002AD8  3A0004     BRA NZ, 0x2AE2
1144:                      return USB_ILLEGAL_REQUEST;
1145:                  }
1146:              
1147:                  // Turn off SOF's, so the bus is idle.
1148:                  U1CONbits.SOFEN = 0;
002ADA  A90494     BCLR U1CON, #0
1149:              
1150:                  // Put the state machine in suspend mode.
1151:                  usbHostState = STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME | SUBSUBSTATE_SUSPEND;
002ADC  204100     MOV #0x410, W0
002ADE  887640     MOV W0, usbHostState
002AE0  EB0100     CLR W2
1152:              
1153:                  return USB_SUCCESS;
1154:              }
002AE2  780002     MOV W2, W0
002AE4  060000     RETURN
1155:              
1156:              /****************************************************************************
1157:                Function:
1158:                  void USBHostTasks( void )
1159:              
1160:                Summary:
1161:                  This function executes the host tasks for USB host operation.
1162:              
1163:                Description:
1164:                  This function executes the host tasks for USB host operation.  It must be
1165:                  executed on a regular basis to keep everything functioning.
1166:              
1167:                  The primary purpose of this function is to handle device attach/detach
1168:                  and enumeration.  It does not handle USB packet transmission or
1169:                  reception; that must be done in the USB interrupt handler to ensure
1170:                  timely operation.
1171:              
1172:                  This routine should be called on a regular basis, but there is no
1173:                  specific time requirement.  Devices will still be able to attach,
1174:                  enumerate, and detach, but the operations will occur more slowly as the
1175:                  calling interval increases.
1176:              
1177:                Precondition:
1178:                  USBHostInit() has been called.
1179:              
1180:                Parameters:
1181:                  None
1182:              
1183:                Returns:
1184:                  None
1185:              
1186:                Remarks:
1187:                  None
1188:               ***************************************************************************/
1189:              
1190:              void USBHostTasks(void) {
002AE6  FA0002     LNK #0x2
002AE8  BE9F88     MOV.D W8, [W15++]
1191:                  static USB_CONFIGURATION *pCurrentConfigurationNode; //MR - made static for OTG
1192:                  USB_INTERFACE_INFO *pCurrentInterface;
1193:                  BYTE *pTemp;
1194:                  BYTE temp;
1195:                  USB_VBUS_POWER_EVENT_DATA powerRequest;
1196:              
1197:              #ifdef DEBUG_MODE
1198:                  //        UART2PutChar('<');
1199:                  //        UART2PutHex( usbHostState>>8 );
1200:                  //        UART2PutHex( usbHostState & 0xff );
1201:                  //        UART2PutChar('-');
1202:                  //        UART2PutHex( pCurrentEndpoint->transferState );
1203:                  //        UART2PutChar('>');
1204:              #endif
1205:              
1206:                  // The PIC32MX detach interrupt is not reliable.  If we are not in one of
1207:                  // the detached states, we'll do a check here to see if we've detached.
1208:                  // If the ATTACH bit is 0, we have detached.
1209:              #ifdef __PIC32MX__
1210:              #ifdef USE_MANUAL_DETACH_DETECT
1211:                  if (((usbHostState & STATE_MASK) != STATE_DETACHED) && !U1IRbits.ATTACHIF) {
1212:              #ifdef DEBUG_MODE
1213:                      UART2PutChar('>');
1214:                      UART2PutChar(']');
1215:              #endif
1216:                      usbHostState = STATE_DETACHED;
1217:                  }
1218:              #endif
1219:              #endif
1220:              
1221:                  // Send any queued events to the client and application layers.
1222:              #if defined ( USB_ENABLE_TRANSFER_EVENT )
1223:                  {
1224:                      USB_EVENT_DATA *item;
1225:              #if defined( __C30__ )
1226:                      WORD interrupt_mask;
1227:              #elif defined( __PIC32MX__ )
1228:                      UINT32 interrupt_mask;
1229:              #else
1230:              #error Cannot save interrupt status
1231:              #endif
1232:              
1233:                      while (StructQueueIsNotEmpty(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
002AEA  E20EE4     CP0 0xEE4
002AEC  32001F     BRA Z, 0x2B2C
002B28  E20EE4     CP0 0xEE4
002B2A  3AFFE1     BRA NZ, 0x2AEE
1234:                          item = StructQueuePeekTail(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
002AEE  807710     MOV 0xEE2, W0
002AF0  20EE62     MOV #0xEE6, W2
002AF2  500FE2     SUB W0, #0x2, [W15]
002AF4  3C0003     BRA GT, 0x2AFC
002AF6  B9006C     MUL.SU W0, #12, W0
002AF8  20EF22     MOV #0xEF2, W2
002AFA  410100     ADD W2, W0, W2
1235:              
1236:                          switch (item->event) {
002AFC  780092     MOV [W2], W1
002AFE  200720     MOV #0x72, W0
002B00  508F80     SUB W1, W0, [W15]
002B02  320003     BRA Z, 0x2B0A
002B04  27FFF0     MOV #0x7FFF, W0
002B06  508F80     SUB W1, W0, [W15]
002B08  3A0004     BRA NZ, 0x2B12
1237:                              case EVENT_TRANSFER:
1238:                              case EVENT_BUS_ERROR:
1239:                                  _USB_NotifyClients(usbDeviceInfo.deviceAddress, item->event, &item->TransferData, sizeof (HOST_TRANSFER_DATA));
002B0A  E88102     INC2 W2, W2
002B0C  BFCED3     MOV.B 0xED3, WREG
002B0E  2000A3     MOV #0xA, W3
002B10  070AA0     RCALL _USB_NotifyClients
1240:                                  break;
1241:                              default:
1242:                                  break;
1243:                          }
1244:              
1245:                          // Guard against USB interrupts
1246:                          interrupt_mask = U1IE;
002B12  802461     MOV U1IE, W1
1247:                          U1IE = 0;
002B14  EF248C     CLR U1IE
1248:              
1249:                          item = StructQueueRemove(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
002B16  ED2EE4     DEC 0xEE4
002B18  807710     MOV 0xEE2, W0
002B1A  500FE2     SUB W0, #0x2, [W15]
002B1C  3C0003     BRA GT, 0x2B24
002B1E  E80000     INC W0, W0
002B20  887710     MOV W0, 0xEE2
002B22  370001     BRA 0x2B26
002B24  EF2EE2     CLR 0xEE2
1250:              
1251:                          // Re-enable USB interrupts
1252:                          U1IE = interrupt_mask;
002B26  882461     MOV W1, U1IE
1253:                      }
1254:                  }
1255:              #endif
1256:              
1257:                  // See if we got an interrupt to change our state.
1258:                  if (usbOverrideHostState != NO_STATE) {
002B2C  8078C0     MOV usbOverrideHostState, W0
002B2E  400FE1     ADD W0, #0x1, [W15]
002B30  320003     BRA Z, 0x2B38
1259:              #ifdef DEBUG_MODE
1260:                      UART2PutChar('>');
1261:              #endif
1262:                      usbHostState = usbOverrideHostState;
002B32  8078C0     MOV usbOverrideHostState, W0
002B34  887640     MOV W0, usbHostState
1263:                      usbOverrideHostState = NO_STATE;
002B36  EFAF18     SETM usbOverrideHostState
1264:                  }
1265:              
1266:                  //-------------------------------------------------------------------------
1267:                  // Main State Machine
1268:              
1269:                  switch (usbHostState & STATE_MASK) {
002B38  807641     MOV usbHostState, W1
002B3A  20F000     MOV #0xF00, W0
002B3C  608080     AND W1, W0, W1
002B3E  202000     MOV #0x200, W0
002B40  508F80     SUB W1, W0, [W15]
002B42  3201BA     BRA Z, 0x2EB8
002B44  3E0006     BRA GTU, 0x2B52
002B46  E00001     CP0 W1
002B48  32000E     BRA Z, 0x2B66
002B4A  201000     MOV #0x100, W0
002B4C  508F80     SUB W1, W0, [W15]
002B4E  3A041B     BRA NZ, 0x3386
002B50  37008B     BRA 0x2C68
002B52  204000     MOV #0x400, W0
002B54  508F80     SUB W1, W0, [W15]
002B56  3203BD     BRA Z, 0x32D2
002B58  B01000     ADD #0x100, W0
002B5A  508F80     SUB W1, W0, [W15]
002B5C  3203DA     BRA Z, 0x3312
002B5E  203000     MOV #0x300, W0
002B60  508F80     SUB W1, W0, [W15]
002B62  3A0411     BRA NZ, 0x3386
002B64  3701EA     BRA 0x2F3A
1270:                      case STATE_DETACHED:
1271:                          switch (usbHostState & SUBSTATE_MASK) {
002B66  807648     MOV usbHostState, W8
002B68  B20F08     AND #0xF0, W8
002B6A  540FF0     SUB W8, #0x10, [W15]
002B6C  320056     BRA Z, 0x2C1A
002B6E  200209     MOV #0x20, W9
002B70  540F89     SUB W8, W9, [W15]
002B72  32005B     BRA Z, 0x2C2A
002B74  E00008     CP0 W8
002B76  3A0407     BRA NZ, 0x3386
1272:                              case SUBSTATE_INITIALIZE:
1273:                                  // We got here either from initialization or from the user
1274:                                  // unplugging the device at any point in time.
1275:              
1276:                                  // Turn off the module and free up memory.
1277:                                  USBHostShutdown();
002B78  07FF94     RCALL USBHostShutdown
1278:              
1279:              #ifdef DEBUG_MODE
1280:                                  UART2PrintString("HOST: Initializing DETACHED state.\r\n");
1281:              #endif
1282:              
1283:                                  // Initialize Endpoint 0 attributes.
1284:                                  usbDeviceInfo.pEndpoint0->next = NULL;
002B7A  8076E0     MOV 0xEDC, W0
002B7C  780808     MOV W8, [W0]
1285:                                  usbDeviceInfo.pEndpoint0->status.val = 0x00;
002B7E  8076E0     MOV 0xEDC, W0
002B80  980018     MOV W8, [W0+2]
1286:                                  usbDeviceInfo.pEndpoint0->status.bfUseDTS = 1;
002B82  8076E1     MOV 0xEDC, W1
002B84  904031     MOV.B [W1+3], W0
002B86  A02400     BSET.B W0, #2
002B88  9840B0     MOV.B W0, [W1+3]
1287:                                  usbDeviceInfo.pEndpoint0->status.bfTransferComplete = 1; // Initialize to success to allow preprocessing loops.
002B8A  8076E1     MOV 0xEDC, W1
002B8C  904031     MOV.B [W1+3], W0
002B8E  A01400     BSET.B W0, #1
002B90  9840B0     MOV.B W0, [W1+3]
1288:                                  usbDeviceInfo.pEndpoint0->status.bfNAKTimeoutEnabled = 1; // So we can catch devices that NAK forever during enumeration
002B92  8076E1     MOV 0xEDC, W1
002B94  904031     MOV.B [W1+3], W0
002B96  704009     IOR.B W0, W9, W0
002B98  9840B0     MOV.B W0, [W1+3]
1289:                                  usbDeviceInfo.pEndpoint0->timeoutNAKs = USB_NUM_CONTROL_NAKS;
002B9A  207D01     MOV #0x7D0, W1
002B9C  8076E0     MOV 0xEDC, W0
002B9E  981001     MOV W1, [W0+32]
1290:                                  usbDeviceInfo.pEndpoint0->wMaxPacketSize = 64;
002BA0  200401     MOV #0x40, W1
002BA2  8076E0     MOV 0xEDC, W0
002BA4  980041     MOV W1, [W0+8]
1291:                                  usbDeviceInfo.pEndpoint0->dataCount = 0; // Initialize to 0 since we set bfTransferComplete.
002BA6  B80060     MUL.UU W0, #0, W0
002BA8  8076E2     MOV 0xEDC, W2
002BAA  980900     MOV W0, [W2+16]
002BAC  980911     MOV W1, [W2+18]
1292:                                  usbDeviceInfo.pEndpoint0->bEndpointAddress = 0;
002BAE  8076E0     MOV 0xEDC, W0
002BB0  985828     MOV.B W8, [W0+26]
1293:                                  usbDeviceInfo.pEndpoint0->transferState = TSTATE_IDLE;
002BB2  8076E0     MOV 0xEDC, W0
002BB4  985808     MOV.B W8, [W0+24]
1294:                                  usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType = USB_TRANSFER_TYPE_CONTROL;
002BB6  8076E2     MOV 0xEDC, W2
002BB8  900852     MOV [W2+26], W0
002BBA  2FCFF1     MOV #0xFCFF, W1
002BBC  600001     AND W0, W1, W0
002BBE  980950     MOV W0, [W2+26]
1295:                                  usbDeviceInfo.pEndpoint0->clientDriver = CLIENT_DRIVER_HOST;
002BC0  EBC080     SETM.B W1
002BC2  8076E0     MOV 0xEDC, W0
002BC4  985811     MOV.B W1, [W0+25]
1296:              
1297:                                  // Initialize any device specific information.
1298:                                  numEnumerationTries = USB_NUM_ENUMERATION_TRIES;
002BC6  B3C030     MOV.B #0x3, W0
002BC8  B7EEC2     MOV.B WREG, numEnumerationTries
1299:                                  usbDeviceInfo.currentConfiguration = 0; // Will be overwritten by config process or the user later
002BCA  FD0400     EXCH W0, W8
002BCC  B7EED0     MOV.B WREG, 0xED0
002BCE  B7EED1     MOV.B WREG, 0xED1
002BD0  B7EED2     MOV.B WREG, 0xED2
002BD2  FD0400     EXCH W0, W8
1300:                                  usbDeviceInfo.attributesOTG = 0;
1301:                                  usbDeviceInfo.deviceAddressAndSpeed = 0;
1302:                                  usbDeviceInfo.flags.val = 0;
002BD4  8876F8     MOV W8, 0xEDE
1303:                                  usbDeviceInfo.pInterfaceList = NULL;
002BD6  8876D8     MOV W8, 0xEDA
1304:                                  usbBusInfo.flags.val = 0;
002BD8  887658     MOV W8, usbBusInfo
1305:              
1306:                                  // Set up the hardware.
1307:                                  U1IE = 0; // Clear and turn off interrupts.
002BDA  882468     MOV W8, U1IE
1308:                                  U1IR = 0xFF;
002BDC  200FF1     MOV #0xFF, W1
002BDE  882451     MOV W1, U1IR
1309:                                  U1OTGIE &= 0x8C;
002BE0  2008C0     MOV #0x8C, W0
002BE2  B62482     AND U1OTGIE
1310:                                  U1OTGIR = 0x7D;
002BE4  50006F     SUB W0, #0xF, W0
002BE6  882400     MOV W0, U1OTGIR
1311:                                  U1EIE = 0;
002BE8  882488     MOV W8, U1EIE
1312:                                  U1EIR = 0xFF;
002BEA  882471     MOV W1, U1EIR
1313:              
1314:                                  // Initialize the Buffer Descriptor Table pointer.
1315:              #if defined(__C30__)
1316:                                  U1BDTP1 = (WORD) (&BDT) >> 8;
002BEC  210000     MOV #0x1000, W0
002BEE  DE0048     LSR W0, #8, W0
002BF0  8824C0     MOV W0, U1BDTP1
1317:              #elif defined(__PIC32MX__)
1318:                                  U1BDTP1 = ((DWORD) KVA_TO_PA(&BDT) & 0x0000FF00) >> 8;
1319:                                  U1BDTP2 = ((DWORD) KVA_TO_PA(&BDT) & 0x00FF0000) >> 16;
1320:                                  U1BDTP3 = ((DWORD) KVA_TO_PA(&BDT) & 0xFF000000) >> 24;
1321:              #else
1322:              #error Cannot set up the Buffer Descriptor Table pointer.
1323:              #endif
1324:              
1325:                                  // Configure the module
1326:                                  U1CON = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE; // Turn of SOF's to cut down noise
002BF2  200081     MOV #0x8, W1
002BF4  8824A1     MOV W1, U1CON
1327:                                  U1CON = USB_HOST_MODE_ENABLE | USB_PINGPONG_RESET | USB_SOF_DISABLE; // Reset the ping-pong buffers
002BF6  2000A0     MOV #0xA, W0
002BF8  8824A0     MOV W0, U1CON
1328:                                  U1CON = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE; // Release the ping-pong buffers
002BFA  8824A1     MOV W1, U1CON
1329:              #ifdef  USB_SUPPORT_OTG
1330:                                  U1OTGCON |= USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE | USB_OTG_ENABLE; // Pull down D+ and D-
1331:              #else
1332:                                  U1OTGCON = USB_DPLUS_PULLDOWN_ENABLE | USB_DMINUS_PULLDOWN_ENABLE; // Pull down D+ and D-
002BFC  200300     MOV #0x30, W0
002BFE  882430     MOV W0, U1OTGCON
1333:              #endif
1334:              
1335:              #if defined(__PIC32MX__)
1336:                                  U1OTGCON |= USB_VBUS_ON;
1337:              #endif
1338:              
1339:                                  U1CNFG1 = USB_PING_PONG_MODE;
002C00  200020     MOV #0x2, W0
002C02  882530     MOV W0, U1CNFG1
1340:              #if defined(__C30__)
1341:                                  U1CNFG2 = USB_VBUS_BOOST_ENABLE | USB_VBUS_COMPARE_ENABLE | USB_ONCHIP_ENABLE;
002C04  882548     MOV W8, U1CNFG2
1342:              #endif
1343:                                  U1ADDR = 0; // Set default address and LSPDEN to 0
002C06  8824B8     MOV W8, U1ADDR
1344:                                  U1EP0bits.LSPD = 0;
002C08  A9E4AA     BCLR U1EP0, #7
1345:                                  U1SOF = USB_SOF_THRESHOLD_64; // Maximum EP0 packet size
002C0A  2004A0     MOV #0x4A, W0
002C0C  882500     MOV W0, U1SOF
1346:              
1347:                                  // Set the next substate.  We do this before we enable
1348:                                  // interrupts in case the interrupt changes states.
1349:                                  _USB_SetNextSubState();
002C0E  807640     MOV usbHostState, W0
002C10  20FF01     MOV #0xFF0, W1
002C12  600001     AND W0, W1, W0
002C14  400070     ADD W0, #0x10, W0
002C16  887640     MOV W0, usbHostState
002C18  3703B6     BRA 0x3386
1350:                                  break;
1351:              
1352:                              case SUBSTATE_WAIT_FOR_POWER:
1353:                                  // We will wait here until the application tells us we can
1354:                                  // turn on power.
1355:                                  if (usbRootHubInfo.flags.bPowerGoodPort0) {
002C1A  AB0F16     BTST usbRootHubInfo, #0
002C1C  3203B4     BRA Z, 0x3386
1356:                                      _USB_SetNextSubState();
002C1E  807640     MOV usbHostState, W0
002C20  20FF01     MOV #0xFF0, W1
002C22  600001     AND W0, W1, W0
002C24  400070     ADD W0, #0x10, W0
002C26  887640     MOV W0, usbHostState
002C28  3703AE     BRA 0x3386
1357:                                  }
1358:                                  break;
1359:              
1360:                              case SUBSTATE_TURN_ON_POWER:
1361:                                  powerRequest.port = 0;
002C2A  EB4080     CLR.B W1
002C2C  9FFFA1     MOV.B W1, [W15-6]
1362:                                  powerRequest.current = USB_INITIAL_VBUS_CURRENT;
002C2E  B3C320     MOV.B #0x32, W0
002C30  9FFFB0     MOV.B W0, [W15-5]
1363:                                  if (USB_HOST_APP_EVENT_HANDLER(USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
002C32  200024     MOV #0x2, W4
002C34  200005     MOV #0x0, W5
002C36  578166     SUB W15, #0x6, W2
002C38  200691     MOV #0x69, W1
002C3A  EBC000     SETM.B W0
002C3C  0727A0     RCALL USB_ApplicationEventHandler
002C3E  E00000     CP0 W0
002C40  32000F     BRA Z, 0x2C60
1364:                                          &powerRequest, sizeof (USB_VBUS_POWER_EVENT_DATA))) {
1365:                                      // Power on the module
1366:                                      U1PWRC = USB_NORMAL_OPERATION | USB_ENABLED;
002C42  200010     MOV #0x1, W0
002C44  882440     MOV W0, U1PWRC
1367:              
1368:              #if defined( __C30__ )
1369:                                      IFS5 &= 0xFFBF;
002C46  A9C08E     BCLR IFS5, #6
1370:                                      IPC21 &= 0xF0FF;
002C48  2F0FF0     MOV #0xF0FF, W0
002C4A  B620CE     AND IPC21
1371:                                      IPC21 |= 0x0600;
002C4C  206000     MOV #0x600, W0
002C4E  B720CE     IOR IPC21
1372:                                      IEC5 |= 0x0040;
002C50  A8C09E     BSET IEC5, #6
1373:              #elif defined( __PIC32MX__ )
1374:                                      // Enable the USB interrupt.
1375:                                      IFS1CLR = _IFS1_USBIF_MASK;
1376:              #if defined(_IPC11_USBIP_MASK)
1377:                                      IPC11CLR = _IPC11_USBIP_MASK | _IPC11_USBIS_MASK;
1378:                                      IPC11SET = _IPC11_USBIP_MASK & (0x00000004 << _IPC11_USBIP_POSITION);
1379:              #elif defined(_IPC7_USBIP_MASK)
1380:                                      IPC7CLR = _IPC7_USBIP_MASK | _IPC7_USBIS_MASK;
1381:                                      IPC7SET = _IPC7_USBIP_MASK & (0x00000004 << _IPC7_USBIP_POSITION);
1382:              #else
1383:              #error "The selected PIC32 device is not currently supported by usb_host.c."
1384:              #endif
1385:                                      IEC1SET = _IEC1_USBIE_MASK;
1386:              #else
1387:              #error Cannot enable USB interrupt.
1388:              #endif
1389:              
1390:                                      // Set the next substate.  We do this before we enable
1391:                                      // interrupts in case the interrupt changes states.
1392:                                      _USB_SetNextSubState();
002C52  807640     MOV usbHostState, W0
002C54  20FF01     MOV #0xFF0, W1
002C56  600001     AND W0, W1, W0
002C58  400070     ADD W0, #0x10, W0
002C5A  887640     MOV W0, usbHostState
1393:              
1394:                                      // Enable the ATTACH interrupt.
1395:                                      U1IEbits.ATTACHIE = 1;
002C5C  A8C48C     BSET U1IE, #6
002C5E  370393     BRA 0x3386
1396:              
1397:              #if defined(USB_ENABLE_1MS_EVENT)
1398:                                      U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
1399:                                      U1OTGIEbits.T1MSECIE = 1;
1400:              #endif
1401:                                  } else {
1402:                                      usbRootHubInfo.flags.bPowerGoodPort0 = 0;
002C60  A90F16     BCLR usbRootHubInfo, #0
1403:                                      usbHostState = STATE_DETACHED | SUBSTATE_WAIT_FOR_POWER;
002C62  200100     MOV #0x10, W0
002C64  887640     MOV W0, usbHostState
002C66  37038F     BRA 0x3386
1404:                                  }
1405:                                  break;
1406:              
1407:                              case SUBSTATE_WAIT_FOR_DEVICE:
1408:                                  // Wait here for the ATTACH interrupt.
1409:              #ifdef  USB_SUPPORT_OTG
1410:                                  U1IEbits.ATTACHIE = 1;
1411:              #endif
1412:                                  break;
1413:                          }
1414:                          break;
1415:              
1416:                      case STATE_ATTACHED:
1417:                          switch (usbHostState & SUBSTATE_MASK) {
002C68  807641     MOV usbHostState, W1
002C6A  B20F01     AND #0xF0, W1
002C6C  200200     MOV #0x20, W0
002C6E  508F80     SUB W1, W0, [W15]
002C70  32007B     BRA Z, 0x2D68
002C72  3E0005     BRA GTU, 0x2C7E
002C74  E00001     CP0 W1
002C76  32000A     BRA Z, 0x2C8C
002C78  508FF0     SUB W1, #0x10, [W15]
002C7A  3A0385     BRA NZ, 0x3386
002C7C  37001D     BRA 0x2CB8
002C7E  200300     MOV #0x30, W0
002C80  508F80     SUB W1, W0, [W15]
002C82  3200D8     BRA Z, 0x2E34
002C84  400070     ADD W0, #0x10, W0
002C86  508F80     SUB W1, W0, [W15]
002C88  3A037E     BRA NZ, 0x3386
002C8A  37010F     BRA 0x2EAA
1418:                              case SUBSTATE_SETTLE:
1419:                                  // Wait 100ms for the insertion process to complete and power
1420:                                  // at the device to be stable.
1421:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002C8C  807640     MOV usbHostState, W0
002C8E  60006F     AND W0, #0xF, W0
002C90  320003     BRA Z, 0x2C98
002C92  500FE2     SUB W0, #0x2, [W15]
002C94  3A0378     BRA NZ, 0x3386
002C96  37000A     BRA 0x2CAC
1422:                                      case SUBSUBSTATE_START_SETTLING_DELAY:
1423:              #ifdef DEBUG_MODE
1424:                                          UART2PrintString("HOST: Starting settling delay.\r\n");
1425:              #endif
1426:              
1427:                                          // Clear and turn on the DETACH interrupt.
1428:                                          U1IR = USB_INTERRUPT_DETACH; // The interrupt is cleared by writing a '1' to the flag.
002C98  200010     MOV #0x1, W0
002C9A  882450     MOV W0, U1IR
1429:                                          U1IEbits.DETACHIE = 1;
002C9C  A8048C     BSET U1IE, #0
1430:              
1431:                                          // Configure and turn on the settling timer - 100ms.
1432:                                          numTimerInterrupts = USB_INSERT_TIME;
002C9E  200FB0     MOV #0xFB, W0
002CA0  887620     MOV W0, numTimerInterrupts
1433:                                          U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
002CA2  200400     MOV #0x40, W0
002CA4  882400     MOV W0, U1OTGIR
1434:                                          U1OTGIEbits.T1MSECIE = 1;
002CA6  A8C482     BSET U1OTGIE, #6
1435:                                          _USB_SetNextSubSubState();
002CA8  EC2EC8     INC usbHostState
002CAA  37036D     BRA 0x3386
1436:                                          break;
1437:              
1438:                                      case SUBSUBSTATE_WAIT_FOR_SETTLING:
1439:                                          // Wait for the timer to finish in the background.
1440:                                          break;
1441:              
1442:                                      case SUBSUBSTATE_SETTLING_DONE:
1443:                                          _USB_SetNextSubState();
002CAC  807640     MOV usbHostState, W0
002CAE  20FF01     MOV #0xFF0, W1
002CB0  600001     AND W0, W1, W0
002CB2  400070     ADD W0, #0x10, W0
002CB4  887640     MOV W0, usbHostState
002CB6  370367     BRA 0x3386
1444:                                          break;
1445:              
1446:                                      default:
1447:                                          // We shouldn't get here.
1448:                                          break;
1449:                                  }
1450:                                  break;
1451:              
1452:                              case SUBSTATE_RESET_DEVICE:
1453:                                  // Reset the device.  We have to do the reset timing ourselves.
1454:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002CB8  807640     MOV usbHostState, W0
002CBA  60046F     AND W0, #0xF, W8
002CBC  540FE2     SUB W8, #0x2, [W15]
002CBE  320041     BRA Z, 0x2D42
002CC0  540FE4     SUB W8, #0x4, [W15]
002CC2  320048     BRA Z, 0x2D54
002CC4  E00008     CP0 W8
002CC6  3A035F     BRA NZ, 0x3386
1455:                                      case SUBSUBSTATE_SET_RESET:
1456:              #ifdef DEBUG_MODE
1457:                                          UART2PrintString("HOST: Resetting the device.\r\n");
1458:              #endif
1459:              
1460:                                          // Prepare a data buffer for us to use.  We'll make it 8 bytes for now,
1461:                                          // which is the minimum wMaxPacketSize for EP0.
1462:                                          if (pEP0Data != NULL) {
002CC8  8075D0     MOV pEP0Data, W0
002CCA  E00000     CP0 W0
002CCC  320002     BRA Z, 0x2CD2
1463:                                              USB_FREE_AND_CLEAR(pEP0Data);
002CCE  07EB9B     RCALL _free
002CD0  8875D8     MOV W8, pEP0Data
1464:                                          }
1465:              
1466:                                          if ((pEP0Data = (BYTE *) USB_MALLOC(8)) == NULL) {
002CD2  200080     MOV #0x8, W0
002CD4  07EB06     RCALL _malloc
002CD6  8875D0     MOV W0, pEP0Data
002CD8  E00000     CP0 W0
002CDA  3A0005     BRA NZ, 0x2CE6
1467:              #ifdef DEBUG_MODE
1468:                                              UART2PrintString("HOST: Error alloc-ing pEP0Data\r\n");
1469:              #endif
1470:                                              _USB_SetErrorCode(USB_HOLDING_OUT_OF_MEMORY);
002CDC  B3C330     MOV.B #0x33, W0
002CDE  B7EED4     MOV.B WREG, 0xED4
1471:                                              _USB_SetHoldState();
002CE0  205000     MOV #0x500, W0
002CE2  887640     MOV W0, usbHostState
002CE4  370350     BRA 0x3386
1472:                                              break;
1473:                                          }
1474:              
1475:                                          // Initialize the USB Device information
1476:                                          usbDeviceInfo.currentConfiguration = 0;
002CE6  EB4000     CLR.B W0
002CE8  B7EED0     MOV.B WREG, 0xED0
002CEA  B7EED1     MOV.B WREG, 0xED1
1477:                                          usbDeviceInfo.attributesOTG = 0;
1478:                                          usbDeviceInfo.flags.val = 0;
002CEC  EB0000     CLR W0
002CEE  8876F0     MOV W0, 0xEDE
1479:              
1480:                                          _USB_InitErrorCounters();
002CF0  B3C031     MOV.B #0x3, W1
002CF2  FD0080     EXCH W0, W1
002CF4  B7EEC1     MOV.B WREG, numCommandTries
002CF6  FD0080     EXCH W0, W1
1481:              
1482:                                          // Disable all EP's except EP0.
1483:                                          U1EP0 = USB_ENDPOINT_CONTROL_SETUP;
002CF8  2000D1     MOV #0xD, W1
002CFA  882551     MOV W1, U1EP0
1484:                                          U1EP1 = USB_DISABLE_ENDPOINT;
002CFC  882560     MOV W0, U1EP1
1485:                                          U1EP2 = USB_DISABLE_ENDPOINT;
002CFE  882570     MOV W0, U1EP2
1486:                                          U1EP3 = USB_DISABLE_ENDPOINT;
002D00  882580     MOV W0, U1EP3
1487:                                          U1EP4 = USB_DISABLE_ENDPOINT;
002D02  882590     MOV W0, U1EP4
1488:                                          U1EP5 = USB_DISABLE_ENDPOINT;
002D04  8825A0     MOV W0, U1EP5
1489:                                          U1EP6 = USB_DISABLE_ENDPOINT;
002D06  8825B0     MOV W0, U1EP6
1490:                                          U1EP7 = USB_DISABLE_ENDPOINT;
002D08  8825C0     MOV W0, U1EP7
1491:                                          U1EP8 = USB_DISABLE_ENDPOINT;
002D0A  8825D0     MOV W0, U1EP8
1492:                                          U1EP9 = USB_DISABLE_ENDPOINT;
002D0C  8825E0     MOV W0, U1EP9
1493:                                          U1EP10 = USB_DISABLE_ENDPOINT;
002D0E  8825F0     MOV W0, U1EP10
1494:                                          U1EP11 = USB_DISABLE_ENDPOINT;
002D10  882600     MOV W0, U1EP11
1495:                                          U1EP12 = USB_DISABLE_ENDPOINT;
002D12  882610     MOV W0, U1EP12
1496:                                          U1EP13 = USB_DISABLE_ENDPOINT;
002D14  882620     MOV W0, U1EP13
1497:                                          U1EP14 = USB_DISABLE_ENDPOINT;
002D16  882630     MOV W0, U1EP14
1498:                                          U1EP15 = USB_DISABLE_ENDPOINT;
002D18  882640     MOV W0, U1EP15
1499:              
1500:                                          // See if the device is low speed.
1501:                                          if (!U1CONbits.JSTATE) {
002D1A  E24494     CP0.B U1CON
002D1C  350006     BRA LT, 0x2D2A
1502:              #ifdef DEBUG_MODE
1503:                                              UART2PrintString("HOST: Low Speed!\r\n");
1504:              #endif
1505:                                              usbDeviceInfo.flags.bfIsLowSpeed = 1;
002D1E  A80EDE     BSET 0xEDE, #0
1506:                                              usbDeviceInfo.deviceAddressAndSpeed = 0x80;
002D20  B3C800     MOV.B #0x80, W0
002D22  B7EED2     MOV.B WREG, 0xED2
1507:                                              U1ADDR = 0x80;
002D24  200800     MOV #0x80, W0
002D26  8824B0     MOV W0, U1ADDR
1508:                                              U1EP0bits.LSPD = 1;
002D28  A8E4AA     BSET U1EP0, #7
1509:                                          }
1510:              
1511:                                          // Reset all ping-pong buffers if they are being used.
1512:                                          U1CONbits.PPBRST = 1;
002D2A  A82494     BSET U1CON, #1
1513:                                          U1CONbits.PPBRST = 0;
002D2C  A92494     BCLR U1CON, #1
1514:                                          usbDeviceInfo.flags.bfPingPongIn = 0;
002D2E  A98EDE     BCLR 0xEDE, #4
1515:                                          usbDeviceInfo.flags.bfPingPongOut = 0;
002D30  A9AEDE     BCLR 0xEDE, #5
1516:              
1517:              #ifdef  USB_SUPPORT_OTG
1518:                                          //Disable HNP
1519:                                          USBOTGDisableHnp();
1520:                                          USBOTGDeactivateHnp();
1521:              #endif
1522:              
1523:                                          // Assert reset for 10ms.  Start a timer countdown.
1524:                                          U1CONbits.USBRST = 1;
002D32  A88494     BSET U1CON, #4
1525:                                          numTimerInterrupts = USB_RESET_TIME;
002D34  200330     MOV #0x33, W0
002D36  887620     MOV W0, numTimerInterrupts
1526:                                          //U1OTGIRbits.T1MSECIF                = 1;       // The interrupt is cleared by writing a '1' to the flag.
1527:                                          U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
002D38  40006D     ADD W0, #0xD, W0
002D3A  882400     MOV W0, U1OTGIR
1528:                                          U1OTGIEbits.T1MSECIE = 1;
002D3C  A8C482     BSET U1OTGIE, #6
1529:              
1530:                                          _USB_SetNextSubSubState();
002D3E  EC2EC8     INC usbHostState
002D40  370322     BRA 0x3386
1531:                                          break;
1532:              
1533:                                      case SUBSUBSTATE_RESET_WAIT:
1534:                                          // Wait for the timer to finish in the background.
1535:                                          break;
1536:              
1537:                                      case SUBSUBSTATE_RESET_RECOVERY:
1538:              #ifdef DEBUG_MODE
1539:                                          UART2PrintString("HOST: Reset complete.\r\n");
1540:              #endif
1541:              
1542:                                          // Deassert reset.
1543:                                          U1CONbits.USBRST = 0;
002D42  A98494     BCLR U1CON, #4
1544:              
1545:                                          // Start sending SOF's.
1546:                                          U1CONbits.SOFEN = 1;
002D44  A80494     BSET U1CON, #0
1547:              
1548:                                          // Wait for the reset recovery time.
1549:                                          numTimerInterrupts = USB_RESET_RECOVERY_TIME;
002D46  2000B0     MOV #0xB, W0
002D48  887620     MOV W0, numTimerInterrupts
1550:                                          U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
002D4A  200400     MOV #0x40, W0
002D4C  882400     MOV W0, U1OTGIR
1551:                                          U1OTGIEbits.T1MSECIE = 1;
002D4E  A8C482     BSET U1OTGIE, #6
1552:              
1553:                                          _USB_SetNextSubSubState();
002D50  EC2EC8     INC usbHostState
002D52  370319     BRA 0x3386
1554:                                          break;
1555:              
1556:                                      case SUBSUBSTATE_RECOVERY_WAIT:
1557:                                          // Wait for the timer to finish in the background.
1558:                                          break;
1559:              
1560:                                      case SUBSUBSTATE_RESET_COMPLETE:
1561:              #ifdef DEBUG_MODE
1562:                                          UART2PrintString("HOST: Reset complete.\r\n");
1563:              #endif
1564:              
1565:                                          // Enable USB interrupts
1566:                                          U1IE = USB_INTERRUPT_TRANSFER | USB_INTERRUPT_SOF | USB_INTERRUPT_ERROR | USB_INTERRUPT_DETACH;
002D54  2000F0     MOV #0xF, W0
002D56  882460     MOV W0, U1IE
1567:                                          U1EIE = 0xFF;
002D58  200FF0     MOV #0xFF, W0
002D5A  882480     MOV W0, U1EIE
1568:              
1569:                                          _USB_SetNextSubState();
002D5C  807640     MOV usbHostState, W0
002D5E  20FF01     MOV #0xFF0, W1
002D60  600001     AND W0, W1, W0
002D62  400070     ADD W0, #0x10, W0
002D64  887640     MOV W0, usbHostState
002D66  37030F     BRA 0x3386
1570:                                          break;
1571:              
1572:                                      default:
1573:                                          // We shouldn't get here.
1574:                                          break;
1575:                                  }
1576:                                  break;
1577:              
1578:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE:
1579:                                  // Send the GET DEVICE DESCRIPTOR command to get just the size
1580:                                  // of the descriptor and the max packet size, so we can allocate
1581:                                  // a large enough buffer for getting the whole thing and enough
1582:                                  // buffer space for each piece.
1583:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002D68  807640     MOV usbHostState, W0
002D6A  60006F     AND W0, #0xF, W0
002D6C  500FE1     SUB W0, #0x1, [W15]
002D6E  320026     BRA Z, 0x2DBC
002D70  390003     BRA NC, 0x2D78
002D72  500FE2     SUB W0, #0x2, [W15]
002D74  3A0308     BRA NZ, 0x3386
002D76  370036     BRA 0x2DE4
1584:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR_SIZE:
1585:              #ifdef DEBUG_MODE
1586:                                          UART2PrintString("HOST: Getting Device Descriptor size.\r\n");
1587:              #endif
1588:              
1589:                                          // Set up and send GET DEVICE DESCRIPTOR
1590:                                          if (pDeviceDescriptor != NULL) {
002D78  8078E0     MOV 0xF1C, W0
002D7A  E00000     CP0 W0
002D7C  320002     BRA Z, 0x2D82
1591:                                              USB_FREE_AND_CLEAR(pDeviceDescriptor);
002D7E  07EB43     RCALL _free
002D80  EF2F1C     CLR 0xF1C
1592:                                          }
1593:              
1594:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
002D82  B3C801     MOV.B #0x80, W1
002D84  8075D0     MOV pEP0Data, W0
002D86  784801     MOV.B W1, [W0]
1595:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
002D88  B3C061     MOV.B #0x6, W1
002D8A  8075D0     MOV pEP0Data, W0
002D8C  984011     MOV.B W1, [W0+1]
1596:                                          pEP0Data[2] = 0; // Index
002D8E  EB4100     CLR.B W2
002D90  8075D0     MOV pEP0Data, W0
002D92  984022     MOV.B W2, [W0+2]
1597:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
002D94  B3C011     MOV.B #0x1, W1
002D96  8075D0     MOV pEP0Data, W0
002D98  984031     MOV.B W1, [W0+3]
1598:                                          pEP0Data[4] = 0;
002D9A  8075D0     MOV pEP0Data, W0
002D9C  984042     MOV.B W2, [W0+4]
1599:                                          pEP0Data[5] = 0;
002D9E  8075D0     MOV pEP0Data, W0
002DA0  984052     MOV.B W2, [W0+5]
1600:                                          pEP0Data[6] = 8;
002DA2  B3C081     MOV.B #0x8, W1
002DA4  8075D0     MOV pEP0Data, W0
002DA6  984061     MOV.B W1, [W0+6]
1601:                                          pEP0Data[7] = 0;
002DA8  8075D0     MOV pEP0Data, W0
002DAA  984072     MOV.B W2, [W0+7]
1602:              
1603:                                          _USB_InitControlRead(usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8);
002DAC  8075D1     MOV pEP0Data, W1
002DAE  8076E0     MOV 0xEDC, W0
002DB0  200084     MOV #0x8, W4
002DB2  780181     MOV W1, W3
002DB4  780104     MOV W4, W2
002DB6  07089F     RCALL _USB_InitControlRead
1604:                                          _USB_SetNextSubSubState();
002DB8  EC2EC8     INC usbHostState
002DBA  3702E5     BRA 0x3386
1605:                                          break;
1606:              
1607:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR_SIZE:
1608:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
002DBC  8076E1     MOV 0xEDC, W1
002DBE  904031     MOV.B [W1+3], W0
002DC0  A31800     BTST.Z W0, #1
002DC2  3202E1     BRA Z, 0x3386
1609:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
002DC4  904031     MOV.B [W1+3], W0
002DC6  A30800     BTST.Z W0, #0
002DC8  32000B     BRA Z, 0x2DE0
1610:              #ifndef USB_HUB_SUPPORT_INCLUDED
1611:                                                  // See if a hub is attached.  Hubs are not supported.
1612:                                                  if (pEP0Data[4] == USB_HUB_CLASSCODE) // bDeviceClass
002DCA  8075D0     MOV pEP0Data, W0
002DCC  904040     MOV.B [W0+4], W0
002DCE  504FE9     SUB.B W0, #0x9, [W15]
002DD0  3A0005     BRA NZ, 0x2DDC
1613:                                                  {
1614:                                                      _USB_SetErrorCode(USB_HOLDING_UNSUPPORTED_HUB);
002DD2  B3C350     MOV.B #0x35, W0
002DD4  B7EED4     MOV.B WREG, 0xED4
1615:                                                      _USB_SetHoldState();
002DD6  205000     MOV #0x500, W0
002DD8  887640     MOV W0, usbHostState
002DDA  3702D5     BRA 0x3386
1616:                                                  } else {
1617:                                                      _USB_SetNextSubSubState();
002DDC  EC2EC8     INC usbHostState
002DDE  3702D3     BRA 0x3386
1618:                                                  }
1619:              #else
1620:                                                  _USB_SetNextSubSubState();
1621:              #endif
1622:                                              } else {
1623:                                                  // We are here because of either a STALL or a NAK.  See if
1624:                                                  // we have retries left to try the command again or try to
1625:                                                  // enumerate again.
1626:                                                  _USB_CheckCommandAndEnumerationAttempts();
002DE0  070358     RCALL _USB_CheckCommandAndEnumerationAttempts
002DE2  3702D1     BRA 0x3386
1627:                                              }
1628:                                          }
1629:                                          break;
1630:              
1631:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_SIZE_COMPLETE:
1632:                                          // Allocate a buffer for the entire Device Descriptor
1633:                                          if ((pDeviceDescriptor = (BYTE *) USB_MALLOC(*pEP0Data)) == NULL) {
002DE4  8075D0     MOV pEP0Data, W0
002DE6  FB8010     ZE [W0], W0
002DE8  07EA7C     RCALL _malloc
002DEA  780080     MOV W0, W1
002DEC  8878E0     MOV W0, 0xF1C
002DEE  E00000     CP0 W0
002DF0  3A0005     BRA NZ, 0x2DFC
1634:                                              // We cannot continue.  Freeze until the device is removed.
1635:                                              _USB_SetErrorCode(USB_HOLDING_OUT_OF_MEMORY);
002DF2  B3C330     MOV.B #0x33, W0
002DF4  B7EED4     MOV.B WREG, 0xED4
1636:                                              _USB_SetHoldState();
002DF6  205000     MOV #0x500, W0
002DF8  887640     MOV W0, usbHostState
002DFA  3702C5     BRA 0x3386
1637:                                              break;
1638:                                          }
1639:                                          // Save the descriptor size in the descriptor (bLength)
1640:                                          *pDeviceDescriptor = *pEP0Data;
002DFC  8075D0     MOV pEP0Data, W0
002DFE  784890     MOV.B [W0], [W1]
1641:              
1642:                                          // Set the EP0 packet size.
1643:                                          usbDeviceInfo.pEndpoint0->wMaxPacketSize = ((USB_DEVICE_DESCRIPTOR *) pEP0Data)->bMaxPacketSize0;
002E00  904070     MOV.B [W0+7], W0
002E02  FB8000     ZE W0, W0
002E04  8076E1     MOV 0xEDC, W1
002E06  9800C0     MOV W0, [W1+8]
1644:              
1645:                                          // Make our pEP0Data buffer the size of the max packet.
1646:                                          USB_FREE_AND_CLEAR(pEP0Data);
002E08  8075D0     MOV pEP0Data, W0
002E0A  07EAFD     RCALL _free
002E0C  EF2EBA     CLR pEP0Data
1647:                                          if ((pEP0Data = (BYTE *) USB_MALLOC(usbDeviceInfo.pEndpoint0->wMaxPacketSize)) == NULL) {
002E0E  8076E0     MOV 0xEDC, W0
002E10  900040     MOV [W0+8], W0
002E12  07EA67     RCALL _malloc
002E14  8875D0     MOV W0, pEP0Data
002E16  E00000     CP0 W0
002E18  3A0005     BRA NZ, 0x2E24
1648:                                              // We cannot continue.  Freeze until the device is removed.
1649:              #ifdef DEBUG_MODE
1650:                                              UART2PrintString("HOST: Error re-alloc-ing pEP0Data\r\n");
1651:              #endif
1652:                                              _USB_SetErrorCode(USB_HOLDING_OUT_OF_MEMORY);
002E1A  B3C330     MOV.B #0x33, W0
002E1C  B7EED4     MOV.B WREG, 0xED4
1653:                                              _USB_SetHoldState();
002E1E  205000     MOV #0x500, W0
002E20  887640     MOV W0, usbHostState
002E22  3702B1     BRA 0x3386
1654:                                              break;
1655:                                          }
1656:              
1657:                                          // Clean up and advance to the next substate.
1658:                                          _USB_InitErrorCounters();
002E24  B3C030     MOV.B #0x3, W0
002E26  B7EEC1     MOV.B WREG, numCommandTries
1659:                                          _USB_SetNextSubState();
002E28  807640     MOV usbHostState, W0
002E2A  20FF01     MOV #0xFF0, W1
002E2C  600001     AND W0, W1, W0
002E2E  400070     ADD W0, #0x10, W0
002E30  887640     MOV W0, usbHostState
002E32  3702A9     BRA 0x3386
1660:                                          break;
1661:              
1662:                                      default:
1663:                                          break;
1664:                                  }
1665:                                  break;
1666:              
1667:                              case SUBSTATE_GET_DEVICE_DESCRIPTOR:
1668:                                  // Send the GET DEVICE DESCRIPTOR command and receive the response
1669:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002E34  807640     MOV usbHostState, W0
002E36  60006F     AND W0, #0xF, W0
002E38  500FE1     SUB W0, #0x1, [W15]
002E3A  320024     BRA Z, 0x2E84
002E3C  390003     BRA NC, 0x2E44
002E3E  500FE2     SUB W0, #0x2, [W15]
002E40  3A02A2     BRA NZ, 0x3386
002E42  37002B     BRA 0x2E9A
1670:                                      case SUBSUBSTATE_SEND_GET_DEVICE_DESCRIPTOR:
1671:              #ifdef DEBUG_MODE
1672:                                          UART2PrintString("HOST: Getting device descriptor.\r\n");
1673:              #endif
1674:              
1675:                                          // If we are currently sending a token, we cannot do anything.
1676:                                          if (usbBusInfo.flags.bfTokenAlreadyWritten) //(U1CONbits.TOKBUSY)
002E44  BFCECA     MOV.B usbBusInfo, WREG
002E46  604170     AND.B W0, #0x10, W2
002E48  3A029E     BRA NZ, 0x3386
1677:                                              break;
1678:              
1679:                                          // Set up and send GET DEVICE DESCRIPTOR
1680:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
002E4A  B3C801     MOV.B #0x80, W1
002E4C  8075D0     MOV pEP0Data, W0
002E4E  784801     MOV.B W1, [W0]
1681:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
002E50  B3C061     MOV.B #0x6, W1
002E52  8075D0     MOV pEP0Data, W0
002E54  984011     MOV.B W1, [W0+1]
1682:                                          pEP0Data[2] = 0; // Index
002E56  8075D0     MOV pEP0Data, W0
002E58  984022     MOV.B W2, [W0+2]
1683:                                          pEP0Data[3] = USB_DESCRIPTOR_DEVICE; // Type
002E5A  B3C011     MOV.B #0x1, W1
002E5C  8075D0     MOV pEP0Data, W0
002E5E  984031     MOV.B W1, [W0+3]
1684:                                          pEP0Data[4] = 0;
002E60  8075D0     MOV pEP0Data, W0
002E62  984042     MOV.B W2, [W0+4]
1685:                                          pEP0Data[5] = 0;
002E64  8075D0     MOV pEP0Data, W0
002E66  984052     MOV.B W2, [W0+5]
1686:                                          pEP0Data[6] = *pDeviceDescriptor;
002E68  8078E1     MOV 0xF1C, W1
002E6A  8075D0     MOV pEP0Data, W0
002E6C  784091     MOV.B [W1], W1
002E6E  984061     MOV.B W1, [W0+6]
1687:                                          pEP0Data[7] = 0;
002E70  8075D0     MOV pEP0Data, W0
002E72  984072     MOV.B W2, [W0+7]
1688:                                          _USB_InitControlRead(usbDeviceInfo.pEndpoint0, pEP0Data, 8, pDeviceDescriptor, *pDeviceDescriptor);
002E74  8078E3     MOV 0xF1C, W3
002E76  8075D1     MOV pEP0Data, W1
002E78  8076E0     MOV 0xEDC, W0
002E7A  FB8213     ZE [W3], W4
002E7C  200082     MOV #0x8, W2
002E7E  07083B     RCALL _USB_InitControlRead
1689:                                          _USB_SetNextSubSubState();
002E80  EC2EC8     INC usbHostState
002E82  370281     BRA 0x3386
1690:                                          break;
1691:              
1692:                                      case SUBSUBSTATE_WAIT_FOR_GET_DEVICE_DESCRIPTOR:
1693:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
002E84  8076E1     MOV 0xEDC, W1
002E86  904031     MOV.B [W1+3], W0
002E88  A31800     BTST.Z W0, #1
002E8A  32027D     BRA Z, 0x3386
1694:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
002E8C  904031     MOV.B [W1+3], W0
002E8E  A30800     BTST.Z W0, #0
002E90  320002     BRA Z, 0x2E96
1695:                                                  _USB_SetNextSubSubState();
002E92  EC2EC8     INC usbHostState
002E94  370278     BRA 0x3386
1696:                                              } else {
1697:                                                  // We are here because of either a STALL or a NAK.  See if
1698:                                                  // we have retries left to try the command again or try to
1699:                                                  // enumerate again.
1700:                                                  _USB_CheckCommandAndEnumerationAttempts();
002E96  0702FD     RCALL _USB_CheckCommandAndEnumerationAttempts
002E98  370276     BRA 0x3386
1701:                                              }
1702:                                          }
1703:                                          break;
1704:              
1705:                                      case SUBSUBSTATE_GET_DEVICE_DESCRIPTOR_COMPLETE:
1706:                                          // Clean up and advance to the next substate.
1707:                                          _USB_InitErrorCounters();
002E9A  B3C030     MOV.B #0x3, W0
002E9C  B7EEC1     MOV.B WREG, numCommandTries
1708:                                          _USB_SetNextSubState();
002E9E  807640     MOV usbHostState, W0
002EA0  20FF01     MOV #0xFF0, W1
002EA2  600001     AND W0, W1, W0
002EA4  400070     ADD W0, #0x10, W0
002EA6  887640     MOV W0, usbHostState
002EA8  37026E     BRA 0x3386
1709:                                          break;
1710:              
1711:                                      default:
1712:                                          break;
1713:                                  }
1714:                                  break;
1715:              
1716:                              case SUBSTATE_VALIDATE_VID_PID:
1717:              #ifdef DEBUG_MODE
1718:                                  UART2PrintString("HOST: Validating VID and PID.\r\n");
1719:              #endif
1720:              
1721:                                  // Search the TPL for the device's VID & PID.  If a client driver is
1722:                                  // available for the over-all device, use it.  Otherwise, we'll search
1723:                                  // again later for an appropriate class driver.
1724:                                  _USB_FindDeviceLevelClientDriver();
002EAA  070350     RCALL _USB_FindDeviceLevelClientDriver
1725:              
1726:                                  // Advance to the next state to assign an address to the device.
1727:                                  //
1728:                                  // Note: We assign an address to all devices and hold later if
1729:                                  // we can't find a supported configuration.
1730:                                  _USB_SetNextState();
002EAC  807640     MOV usbHostState, W0
002EAE  20F001     MOV #0xF00, W1
002EB0  600001     AND W0, W1, W0
002EB2  B01000     ADD #0x100, W0
002EB4  887640     MOV W0, usbHostState
002EB6  370267     BRA 0x3386
1731:                                  break;
1732:                          }
1733:                          break;
1734:              
1735:                      case STATE_ADDRESSING:
1736:                          switch (usbHostState & SUBSTATE_MASK) {
002EB8  807640     MOV usbHostState, W0
002EBA  B20F00     AND #0xF0, W0
002EBC  3A0264     BRA NZ, 0x3386
1737:                              case SUBSTATE_SET_DEVICE_ADDRESS:
1738:                                  // Send the SET ADDRESS command.  We can't set the device address
1739:                                  // in hardware until the entire transaction is complete.
1740:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002EBE  807640     MOV usbHostState, W0
002EC0  60006F     AND W0, #0xF, W0
002EC2  500FE1     SUB W0, #0x1, [W15]
002EC4  320022     BRA Z, 0x2F0A
002EC6  390003     BRA NC, 0x2ECE
002EC8  500FE2     SUB W0, #0x2, [W15]
002ECA  3A025D     BRA NZ, 0x3386
002ECC  370029     BRA 0x2F20
1741:                                      case SUBSUBSTATE_SEND_SET_DEVICE_ADDRESS:
1742:              #ifdef DEBUG_MODE
1743:                                          UART2PrintString("HOST: Setting device address.\r\n");
1744:              #endif
1745:              
1746:                                          // Select an address for the device.  Store it so we can access it again
1747:                                          // easily.  We'll put the low speed indicator on later.
1748:                                          // This has been broken out so when we allow multiple devices, we have
1749:                                          // a single interface point to allocate a new address.
1750:                                          usbDeviceInfo.deviceAddress = USB_SINGLE_DEVICE_ADDRESS;
002ECE  B3C010     MOV.B #0x1, W0
002ED0  B7EED3     MOV.B WREG, 0xED3
1751:              
1752:                                          // Set up and send SET ADDRESS
1753:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
002ED2  EB4100     CLR.B W2
002ED4  8075D0     MOV pEP0Data, W0
002ED6  784802     MOV.B W2, [W0]
1754:                                          pEP0Data[1] = USB_REQUEST_SET_ADDRESS;
002ED8  B3C051     MOV.B #0x5, W1
002EDA  8075D0     MOV pEP0Data, W0
002EDC  984011     MOV.B W1, [W0+1]
1755:                                          pEP0Data[2] = usbDeviceInfo.deviceAddress;
002EDE  8075D0     MOV pEP0Data, W0
002EE0  20ED31     MOV #0xED3, W1
002EE2  784091     MOV.B [W1], W1
002EE4  984021     MOV.B W1, [W0+2]
1756:                                          pEP0Data[3] = 0;
002EE6  8075D0     MOV pEP0Data, W0
002EE8  984032     MOV.B W2, [W0+3]
1757:                                          pEP0Data[4] = 0;
002EEA  8075D0     MOV pEP0Data, W0
002EEC  984042     MOV.B W2, [W0+4]
1758:                                          pEP0Data[5] = 0;
002EEE  8075D0     MOV pEP0Data, W0
002EF0  984052     MOV.B W2, [W0+5]
1759:                                          pEP0Data[6] = 0;
002EF2  8075D0     MOV pEP0Data, W0
002EF4  984062     MOV.B W2, [W0+6]
1760:                                          pEP0Data[7] = 0;
002EF6  8075D0     MOV pEP0Data, W0
002EF8  984072     MOV.B W2, [W0+7]
1761:                                          _USB_InitControlWrite(usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0);
002EFA  8075D1     MOV pEP0Data, W1
002EFC  8076E0     MOV 0xEDC, W0
002EFE  EB0200     CLR W4
002F00  780184     MOV W4, W3
002F02  200082     MOV #0x8, W2
002F04  07081C     RCALL _USB_InitControlWrite
1762:                                          _USB_SetNextSubSubState();
002F06  EC2EC8     INC usbHostState
002F08  37023E     BRA 0x3386
1763:                                          break;
1764:              
1765:                                      case SUBSUBSTATE_WAIT_FOR_SET_DEVICE_ADDRESS:
1766:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
002F0A  8076E1     MOV 0xEDC, W1
002F0C  904031     MOV.B [W1+3], W0
002F0E  A31800     BTST.Z W0, #1
002F10  32023A     BRA Z, 0x3386
1767:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
002F12  904031     MOV.B [W1+3], W0
002F14  A30800     BTST.Z W0, #0
002F16  320002     BRA Z, 0x2F1C
1768:                                                  _USB_SetNextSubSubState();
002F18  EC2EC8     INC usbHostState
002F1A  370235     BRA 0x3386
1769:                                              } else {
1770:                                                  // We are here because of either a STALL or a NAK.  See if
1771:                                                  // we have retries left to try the command again or try to
1772:                                                  // enumerate again.
1773:                                                  _USB_CheckCommandAndEnumerationAttempts();
002F1C  0702BA     RCALL _USB_CheckCommandAndEnumerationAttempts
002F1E  370233     BRA 0x3386
1774:                                              }
1775:                                          }
1776:                                          break;
1777:              
1778:                                      case SUBSUBSTATE_SET_DEVICE_ADDRESS_COMPLETE:
1779:                                          // Set the device's address here.
1780:                                          usbDeviceInfo.deviceAddressAndSpeed = (usbDeviceInfo.flags.bfIsLowSpeed << 7) | usbDeviceInfo.deviceAddress;
002F20  BFCEDE     MOV.B 0xEDE, WREG
002F22  600061     AND W0, #0x1, W0
002F24  DD0047     SL W0, #7, W0
002F26  B74ED3     IOR.B 0xED3, WREG
002F28  B7EED2     MOV.B WREG, 0xED2
1781:              
1782:                                          // Clean up and advance to the next state.
1783:                                          _USB_InitErrorCounters();
002F2A  B3C030     MOV.B #0x3, W0
002F2C  B7EEC1     MOV.B WREG, numCommandTries
1784:                                          _USB_SetNextState();
002F2E  807640     MOV usbHostState, W0
002F30  20F001     MOV #0xF00, W1
002F32  600001     AND W0, W1, W0
002F34  B01000     ADD #0x100, W0
002F36  887640     MOV W0, usbHostState
002F38  370226     BRA 0x3386
1785:                                          break;
1786:              
1787:                                      default:
1788:                                          break;
1789:                                  }
1790:                                  break;
1791:                          }
1792:                          break;
1793:              
1794:                      case STATE_CONFIGURING:
1795:                          switch (usbHostState & SUBSTATE_MASK) {
002F3A  807641     MOV usbHostState, W1
002F3C  B20F01     AND #0xF0, W1
002F3E  200200     MOV #0x20, W0
002F40  508F80     SUB W1, W0, [W15]
002F42  32008A     BRA Z, 0x3058
002F44  3E0005     BRA GTU, 0x2F50
002F46  E00001     CP0 W1
002F48  32000A     BRA Z, 0x2F5E
002F4A  508FF0     SUB W1, #0x10, [W15]
002F4C  3A021C     BRA NZ, 0x3386
002F4E  37001E     BRA 0x2F8C
002F50  200300     MOV #0x30, W0
002F52  508F80     SUB W1, W0, [W15]
002F54  3200CB     BRA Z, 0x30EC
002F56  400070     ADD W0, #0x10, W0
002F58  508F80     SUB W1, W0, [W15]
002F5A  3A0215     BRA NZ, 0x3386
002F5C  370151     BRA 0x3200
1796:                              case SUBSTATE_INIT_CONFIGURATION:
1797:                                  // Delete the old list of configuration descriptors and
1798:                                  // initialize the counter.  We will request the descriptors
1799:                                  // from highest to lowest so the lowest will be first in
1800:                                  // the list.
1801:                                  countConfigurations = ((USB_DEVICE_DESCRIPTOR *) pDeviceDescriptor)->bNumConfigurations;
002F5E  8078E0     MOV 0xF1C, W0
002F60  905010     MOV.B [W0+17], W0
002F62  B7EEC0     MOV.B WREG, countConfigurations
1802:                                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL) {
002F64  8076C0     MOV 0xED8, W0
002F66  E00000     CP0 W0
002F68  32000B     BRA Z, 0x2F80
002F7C  E00008     CP0 W8
002F7E  3AFFF5     BRA NZ, 0x2F6A
1803:                                      pTemp = (BYTE *) usbDeviceInfo.pConfigurationDescriptorList->next;
002F6A  900410     MOV [W0+2], W8
1804:                                      USB_FREE_AND_CLEAR(usbDeviceInfo.pConfigurationDescriptorList->descriptor);
002F6C  780010     MOV [W0], W0
002F6E  07EA4B     RCALL _free
002F70  8076C0     MOV 0xED8, W0
002F72  EB0800     CLR [W0]
1805:                                      USB_FREE_AND_CLEAR(usbDeviceInfo.pConfigurationDescriptorList);
002F74  8076C0     MOV 0xED8, W0
002F76  07EA47     RCALL _free
1806:                                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *) pTemp;
002F78  780008     MOV W8, W0
002F7A  8876C8     MOV W8, 0xED8
1807:                                  }
1808:                                  _USB_SetNextSubState();
002F80  807640     MOV usbHostState, W0
002F82  20FF01     MOV #0xFF0, W1
002F84  600001     AND W0, W1, W0
002F86  400070     ADD W0, #0x10, W0
002F88  887640     MOV W0, usbHostState
002F8A  3701FD     BRA 0x3386
1809:                                  break;
1810:              
1811:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE:
1812:                                  // Get the size of the Configuration Descriptor for the current configuration
1813:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
002F8C  807640     MOV usbHostState, W0
002F8E  60006F     AND W0, #0xF, W0
002F90  500FE1     SUB W0, #0x1, [W15]
002F92  320023     BRA Z, 0x2FDA
002F94  390003     BRA NC, 0x2F9C
002F96  500FE2     SUB W0, #0x2, [W15]
002F98  3A01F6     BRA NZ, 0x3386
002F9A  37002A     BRA 0x2FF0
1814:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR_SIZE:
1815:              #ifdef DEBUG_MODE
1816:                                          UART2PrintString("HOST: Getting Config Descriptor size.\r\n");
1817:              #endif
1818:              
1819:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR with a length of 8
1820:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
002F9C  B3C801     MOV.B #0x80, W1
002F9E  8075D0     MOV pEP0Data, W0
002FA0  784801     MOV.B W1, [W0]
1821:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
002FA2  B3C061     MOV.B #0x6, W1
002FA4  8075D0     MOV pEP0Data, W0
002FA6  984011     MOV.B W1, [W0+1]
1822:                                          pEP0Data[2] = countConfigurations - 1; // USB 2.0 - range is 0 - count-1
002FA8  ED4EC0     DEC.B countConfigurations, WREG
002FAA  784080     MOV.B W0, W1
002FAC  8075D0     MOV pEP0Data, W0
002FAE  984021     MOV.B W1, [W0+2]
1823:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
002FB0  B3C021     MOV.B #0x2, W1
002FB2  8075D0     MOV pEP0Data, W0
002FB4  984031     MOV.B W1, [W0+3]
1824:                                          pEP0Data[4] = 0;
002FB6  EB4100     CLR.B W2
002FB8  8075D0     MOV pEP0Data, W0
002FBA  984042     MOV.B W2, [W0+4]
1825:                                          pEP0Data[5] = 0;
002FBC  8075D0     MOV pEP0Data, W0
002FBE  984052     MOV.B W2, [W0+5]
1826:                                          pEP0Data[6] = 8;
002FC0  B3C081     MOV.B #0x8, W1
002FC2  8075D0     MOV pEP0Data, W0
002FC4  984061     MOV.B W1, [W0+6]
1827:                                          pEP0Data[7] = 0;
002FC6  8075D0     MOV pEP0Data, W0
002FC8  984072     MOV.B W2, [W0+7]
1828:                                          _USB_InitControlRead(usbDeviceInfo.pEndpoint0, pEP0Data, 8, pEP0Data, 8);
002FCA  8075D1     MOV pEP0Data, W1
002FCC  8076E0     MOV 0xEDC, W0
002FCE  200084     MOV #0x8, W4
002FD0  780181     MOV W1, W3
002FD2  780104     MOV W4, W2
002FD4  070790     RCALL _USB_InitControlRead
1829:                                          _USB_SetNextSubSubState();
002FD6  EC2EC8     INC usbHostState
002FD8  3701D6     BRA 0x3386
1830:                                          break;
1831:              
1832:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR_SIZE:
1833:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
002FDA  8076E1     MOV 0xEDC, W1
002FDC  904031     MOV.B [W1+3], W0
002FDE  A31800     BTST.Z W0, #1
002FE0  3201D2     BRA Z, 0x3386
1834:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
002FE2  904031     MOV.B [W1+3], W0
002FE4  A30800     BTST.Z W0, #0
002FE6  320002     BRA Z, 0x2FEC
1835:                                                  _USB_SetNextSubSubState();
002FE8  EC2EC8     INC usbHostState
002FEA  3701CD     BRA 0x3386
1836:                                              } else {
1837:                                                  // We are here because of either a STALL or a NAK.  See if
1838:                                                  // we have retries left to try the command again or try to
1839:                                                  // enumerate again.
1840:                                                  _USB_CheckCommandAndEnumerationAttempts();
002FEC  070252     RCALL _USB_CheckCommandAndEnumerationAttempts
002FEE  3701CB     BRA 0x3386
1841:                                              }
1842:                                          }
1843:                                          break;
1844:              
1845:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_SIZECOMPLETE:
1846:                                          // Allocate a buffer for an entry in the configuration descriptor list.
1847:                                          if ((pTemp = (BYTE *) USB_MALLOC(sizeof (USB_CONFIGURATION))) == NULL) {
002FF0  200060     MOV #0x6, W0
002FF2  07E977     RCALL _malloc
002FF4  E00000     CP0 W0
002FF6  3A0005     BRA NZ, 0x3002
1848:                                              // We cannot continue.  Freeze until the device is removed.
1849:                                              _USB_SetErrorCode(USB_HOLDING_OUT_OF_MEMORY);
002FF8  B3C330     MOV.B #0x33, W0
002FFA  B7EED4     MOV.B WREG, 0xED4
1850:                                              _USB_SetHoldState();
002FFC  205000     MOV #0x500, W0
002FFE  887640     MOV W0, usbHostState
003000  3701C2     BRA 0x3386
1851:                                              break;
1852:                                          }
1853:              
1854:                                          // Allocate a buffer for the entire Configuration Descriptor
1855:                                          if ((((USB_CONFIGURATION *) pTemp)->descriptor = (BYTE *) USB_MALLOC(((WORD) pEP0Data[3] << 8) + (WORD) pEP0Data[2])) == NULL) {
003002  780400     MOV W0, W8
003004  8075D1     MOV pEP0Data, W1
003006  904031     MOV.B [W1+3], W0
003008  DD0048     SL W0, #8, W0
00300A  9040A1     MOV.B [W1+2], W1
00300C  FB8081     ZE W1, W1
00300E  400001     ADD W0, W1, W0
003010  07E968     RCALL _malloc
003012  780100     MOV W0, W2
003014  780C00     MOV W0, [W8]
003016  E00000     CP0 W0
003018  3A0007     BRA NZ, 0x3028
1856:                                              // Not enough memory for the descriptor!
1857:                                              USB_FREE_AND_CLEAR(pTemp);
00301A  780008     MOV W8, W0
00301C  07E9F4     RCALL _free
1858:              
1859:                                              // We cannot continue.  Freeze until the device is removed.
1860:                                              _USB_SetErrorCode(USB_HOLDING_OUT_OF_MEMORY);
00301E  B3C330     MOV.B #0x33, W0
003020  B7EED4     MOV.B WREG, 0xED4
1861:                                              _USB_SetHoldState();
003022  205000     MOV #0x500, W0
003024  887640     MOV W0, usbHostState
003026  3701AF     BRA 0x3386
1862:                                              break;
1863:                                          }
1864:              
1865:                                          // Save wTotalLength
1866:                                          ((USB_CONFIGURATION_DESCRIPTOR *) ((USB_CONFIGURATION *) pTemp)->descriptor)->wTotalLength =
003028  8075D0     MOV pEP0Data, W0
00302A  9040B0     MOV.B [W0+3], W1
00302C  DD08C8     SL W1, #8, W1
00302E  904020     MOV.B [W0+2], W0
003030  FB8000     ZE W0, W0
003032  408080     ADD W1, W0, W1
003034  984121     MOV.B W1, [W2+2]
003036  DE08C8     LSR W1, #8, W1
003038  984131     MOV.B W1, [W2+3]
1867:                                                  ((WORD) pEP0Data[3] << 8) + (WORD) pEP0Data[2];
1868:              
1869:                                          // Put the new node at the front of the list.
1870:                                          ((USB_CONFIGURATION *) pTemp)->next = usbDeviceInfo.pConfigurationDescriptorList;
00303A  8076C1     MOV 0xED8, W1
00303C  980411     MOV W1, [W8+2]
1871:                                          usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *) pTemp;
00303E  8876C8     MOV W8, 0xED8
1872:              
1873:                                          // Save the configuration descriptor pointer and number
1874:                                          pCurrentConfigurationDescriptor = ((USB_CONFIGURATION *) pTemp)->descriptor;
003040  780118     MOV [W8], W2
003042  8878D2     MOV W2, 0xF1A
1875:                                          ((USB_CONFIGURATION *) pTemp)->configNumber = countConfigurations;
003044  BFCEC0     MOV.B countConfigurations, WREG
003046  984440     MOV.B W0, [W8+4]
1876:              
1877:                                          // Clean up and advance to the next state.
1878:                                          _USB_InitErrorCounters();
003048  B3C030     MOV.B #0x3, W0
00304A  B7EEC1     MOV.B WREG, numCommandTries
1879:                                          _USB_SetNextSubState();
00304C  807640     MOV usbHostState, W0
00304E  20FF01     MOV #0xFF0, W1
003050  600001     AND W0, W1, W0
003052  400070     ADD W0, #0x10, W0
003054  887640     MOV W0, usbHostState
003056  370197     BRA 0x3386
1880:                                          break;
1881:              
1882:                                      default:
1883:                                          break;
1884:                                  }
1885:                                  break;
1886:              
1887:                              case SUBSTATE_GET_CONFIG_DESCRIPTOR:
1888:                                  // Get the entire Configuration Descriptor for this configuration
1889:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
003058  807640     MOV usbHostState, W0
00305A  60006F     AND W0, #0xF, W0
00305C  500FE1     SUB W0, #0x1, [W15]
00305E  32002D     BRA Z, 0x30BA
003060  390003     BRA NC, 0x3068
003062  500FE2     SUB W0, #0x2, [W15]
003064  3A0190     BRA NZ, 0x3386
003066  370034     BRA 0x30D0
1890:                                      case SUBSUBSTATE_SEND_GET_CONFIG_DESCRIPTOR:
1891:              #ifdef DEBUG_MODE
1892:                                          UART2PrintString("HOST: Getting Config Descriptor.\r\n");
1893:              #endif
1894:              
1895:                                          // Set up and send GET CONFIGURATION (n) DESCRIPTOR.
1896:                                          pEP0Data[0] = USB_SETUP_DEVICE_TO_HOST | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
003068  B3C801     MOV.B #0x80, W1
00306A  8075D0     MOV pEP0Data, W0
00306C  784801     MOV.B W1, [W0]
1897:                                          pEP0Data[1] = USB_REQUEST_GET_DESCRIPTOR;
00306E  B3C061     MOV.B #0x6, W1
003070  8075D0     MOV pEP0Data, W0
003072  984011     MOV.B W1, [W0+1]
1898:                                          pEP0Data[2] = countConfigurations - 1;
003074  ED4EC0     DEC.B countConfigurations, WREG
003076  784080     MOV.B W0, W1
003078  8075D0     MOV pEP0Data, W0
00307A  984021     MOV.B W1, [W0+2]
1899:                                          pEP0Data[3] = USB_DESCRIPTOR_CONFIGURATION;
00307C  B3C021     MOV.B #0x2, W1
00307E  8075D0     MOV pEP0Data, W0
003080  984031     MOV.B W1, [W0+3]
1900:                                          pEP0Data[4] = 0;
003082  EB4080     CLR.B W1
003084  8075D0     MOV pEP0Data, W0
003086  984041     MOV.B W1, [W0+4]
1901:                                          pEP0Data[5] = 0;
003088  8075D0     MOV pEP0Data, W0
00308A  984051     MOV.B W1, [W0+5]
1902:                                          pEP0Data[6] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[2]; // wTotalLength
00308C  8076C0     MOV 0xED8, W0
00308E  780090     MOV [W0], W1
003090  8075D0     MOV pEP0Data, W0
003092  9040A1     MOV.B [W1+2], W1
003094  984061     MOV.B W1, [W0+6]
1903:                                          pEP0Data[7] = usbDeviceInfo.pConfigurationDescriptorList->descriptor[3];
003096  8076C0     MOV 0xED8, W0
003098  780090     MOV [W0], W1
00309A  8075D0     MOV pEP0Data, W0
00309C  9040B1     MOV.B [W1+3], W1
00309E  984071     MOV.B W1, [W0+7]
1904:                                          _USB_InitControlRead(usbDeviceInfo.pEndpoint0, pEP0Data, 8, usbDeviceInfo.pConfigurationDescriptorList->descriptor,
0030A0  8076C0     MOV 0xED8, W0
0030A2  780190     MOV [W0], W3
0030A4  904123     MOV.B [W3+2], W2
0030A6  FB8102     ZE W2, W2
0030A8  904233     MOV.B [W3+3], W4
0030AA  DD2248     SL W4, #8, W4
0030AC  8075D1     MOV pEP0Data, W1
0030AE  8076E0     MOV 0xEDC, W0
0030B0  720202     IOR W4, W2, W4
0030B2  200082     MOV #0x8, W2
0030B4  070720     RCALL _USB_InitControlRead
1905:                                                  ((USB_CONFIGURATION_DESCRIPTOR *) usbDeviceInfo.pConfigurationDescriptorList->descriptor)->wTotalLength);
1906:                                          _USB_SetNextSubSubState();
0030B6  EC2EC8     INC usbHostState
0030B8  370166     BRA 0x3386
1907:                                          break;
1908:              
1909:                                      case SUBSUBSTATE_WAIT_FOR_GET_CONFIG_DESCRIPTOR:
1910:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
0030BA  8076E1     MOV 0xEDC, W1
0030BC  904031     MOV.B [W1+3], W0
0030BE  A31800     BTST.Z W0, #1
0030C0  320162     BRA Z, 0x3386
1911:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
0030C2  904031     MOV.B [W1+3], W0
0030C4  A30800     BTST.Z W0, #0
0030C6  320002     BRA Z, 0x30CC
1912:                                                  _USB_SetNextSubSubState();
0030C8  EC2EC8     INC usbHostState
0030CA  37015D     BRA 0x3386
1913:                                              } else {
1914:                                                  // We are here because of either a STALL or a NAK.  See if
1915:                                                  // we have retries left to try the command again or try to
1916:                                                  // enumerate again.
1917:                                                  _USB_CheckCommandAndEnumerationAttempts();
0030CC  0701E2     RCALL _USB_CheckCommandAndEnumerationAttempts
0030CE  37015B     BRA 0x3386
1918:                                              }
1919:                                          }
1920:                                          break;
1921:              
1922:                                      case SUBSUBSTATE_GET_CONFIG_DESCRIPTOR_COMPLETE:
1923:                                          // Clean up and advance to the next state.  Keep the data for later use.
1924:                                          _USB_InitErrorCounters();
0030D0  B3C030     MOV.B #0x3, W0
0030D2  B7EEC1     MOV.B WREG, numCommandTries
1925:                                          countConfigurations--;
0030D4  ED4EC0     DEC.B countConfigurations, WREG
0030D6  B7EEC0     MOV.B WREG, countConfigurations
1926:                                          if (countConfigurations) {
0030D8  320003     BRA Z, 0x30E0
1927:                                              // There are more descriptors that we need to get.
1928:                                              usbHostState = STATE_CONFIGURING | SUBSTATE_GET_CONFIG_DESCRIPTOR_SIZE;
0030DA  203100     MOV #0x310, W0
0030DC  887640     MOV W0, usbHostState
0030DE  370153     BRA 0x3386
1929:                                          } else {
1930:                                              // Start configuring the device.
1931:                                              _USB_SetNextSubState();
0030E0  807640     MOV usbHostState, W0
0030E2  20FF01     MOV #0xFF0, W1
0030E4  600001     AND W0, W1, W0
0030E6  400070     ADD W0, #0x10, W0
0030E8  887640     MOV W0, usbHostState
0030EA  37014D     BRA 0x3386
1932:                                          }
1933:                                          break;
1934:              
1935:                                      default:
1936:                                          break;
1937:                                  }
1938:                                  break;
1939:              
1940:                              case SUBSTATE_SELECT_CONFIGURATION:
1941:                                  // Set the OTG configuration of the device
1942:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
0030EC  807640     MOV usbHostState, W0
0030EE  60006F     AND W0, #0xF, W0
0030F0  500FE1     SUB W0, #0x1, [W15]
0030F2  32003F     BRA Z, 0x3172
0030F4  390005     BRA NC, 0x3100
0030F6  500FE2     SUB W0, #0x2, [W15]
0030F8  320067     BRA Z, 0x31C8
0030FA  500FE3     SUB W0, #0x3, [W15]
0030FC  3A0144     BRA NZ, 0x3386
0030FE  37006F     BRA 0x31DE
1943:                                      case SUBSUBSTATE_SELECT_CONFIGURATION:
1944:                                          // Free the old configuration (if any)
1945:                                          _USB_FreeConfigMemory();
003100  0706AC     RCALL _USB_FreeConfigMemory
1946:              
1947:                                          // If the configuration wasn't selected based on the VID & PID
1948:                                          if (usbDeviceInfo.currentConfiguration == 0) {
003102  20ED02     MOV #0xED0, W2
003104  784112     MOV.B [W2], W2
003106  E00402     CP0.B W2
003108  3A0010     BRA NZ, 0x312A
1949:                                              // Search for a supported class-specific configuration.
1950:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00310A  8076C0     MOV 0xED8, W0
00310C  8875F0     MOV W0, pCurrentConfigurationNode
1951:                                              while (pCurrentConfigurationNode) {
00310E  E00000     CP0 W0
003110  320022     BRA Z, 0x3156
003124  E00000     CP0 W0
003126  320017     BRA Z, 0x3156
003128  37FFF4     BRA 0x3112
1952:                                                  pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
003112  780010     MOV [W0], W0
003114  8878D0     MOV W0, 0xF1A
1953:                                                  if (_USB_ParseConfigurationDescriptor()) {
003116  0707E8     RCALL _USB_ParseConfigurationDescriptor
003118  E00000     CP0 W0
00311A  3A001D     BRA NZ, 0x3156
1954:                                                      break;
1955:                                                  } else {
1956:                                                      // Free the memory allocated and
1957:                                                      // advance to  next configuration
1958:                                                      _USB_FreeConfigMemory();
00311C  07069E     RCALL _USB_FreeConfigMemory
1959:                                                      pCurrentConfigurationNode = pCurrentConfigurationNode->next;
00311E  8075F0     MOV pCurrentConfigurationNode, W0
003120  900010     MOV [W0+2], W0
003122  8875F0     MOV W0, pCurrentConfigurationNode
1960:                                                  }
1961:                                              }
1962:                                          } else {
1963:                                              // Configuration selected by VID & PID, initialize data structures
1964:                                              pCurrentConfigurationNode = usbDeviceInfo.pConfigurationDescriptorList;
00312A  8076C1     MOV 0xED8, W1
00312C  8875F1     MOV W1, pCurrentConfigurationNode
1965:                                              while (pCurrentConfigurationNode && pCurrentConfigurationNode->configNumber != usbDeviceInfo.currentConfiguration) {
00312E  E00001     CP0 W1
003130  3A0126     BRA NZ, 0x337E
003132  370009     BRA 0x3146
003134  8875F1     MOV W1, pCurrentConfigurationNode
003136  370007     BRA 0x3146
00313A  E00001     CP0 W1
00313C  32FFFB     BRA Z, 0x3134
00313E  904041     MOV.B [W1+4], W0
003140  514F80     SUB.B W2, W0, [W15]
003142  3AFFFA     BRA NZ, 0x3138
003144  8875F1     MOV W1, pCurrentConfigurationNode
00337E  904041     MOV.B [W1+4], W0
003380  514F80     SUB.B W2, W0, [W15]
003382  3AFEDA     BRA NZ, 0x3138
003384  37FEE0     BRA 0x3146
1966:                                                  pCurrentConfigurationNode = pCurrentConfigurationNode->next;
003138  900091     MOV [W1+2], W1
1967:                                              }
1968:                                              pCurrentConfigurationDescriptor = pCurrentConfigurationNode->descriptor;
003146  780091     MOV [W1], W1
003148  8878D1     MOV W1, 0xF1A
1969:                                              if (!_USB_ParseConfigurationDescriptor()) {
00314A  0707CE     RCALL _USB_ParseConfigurationDescriptor
00314C  780400     MOV W0, W8
00314E  E00000     CP0 W0
003150  3A0002     BRA NZ, 0x3156
1970:                                                  // Free the memory allocated, config attempt failed.
1971:                                                  _USB_FreeConfigMemory();
003152  070683     RCALL _USB_FreeConfigMemory
1972:                                                  pCurrentConfigurationNode = NULL;
003154  8875F8     MOV W8, pCurrentConfigurationNode
1973:                                              }
1974:                                          }
1975:              
1976:                                          //If No OTG Then
1977:                                          if (usbDeviceInfo.flags.bfConfiguredOTG) {
003156  BFCEDE     MOV.B 0xEDE, WREG
003158  A32800     BTST.Z W0, #2
00315A  320009     BRA Z, 0x316E
1978:                                              // Did we fail to configure?
1979:                                              if (pCurrentConfigurationNode == NULL) {
00315C  E20EBE     CP0 pCurrentConfigurationNode
00315E  3A0005     BRA NZ, 0x316A
1980:                                                  // Failed to find a supported configuration.
1981:                                                  _USB_SetErrorCode(USB_HOLDING_UNSUPPORTED_DEVICE);
003160  B3C340     MOV.B #0x34, W0
003162  B7EED4     MOV.B WREG, 0xED4
1982:                                                  _USB_SetHoldState();
003164  205000     MOV #0x500, W0
003166  887640     MOV W0, usbHostState
003168  37010E     BRA 0x3386
1983:                                              } else {
1984:                                                  _USB_SetNextSubSubState();
00316A  EC2EC8     INC usbHostState
00316C  37010C     BRA 0x3386
1985:                                              }
1986:                                          } else {
1987:                                              _USB_SetNextSubSubState();
00316E  EC2EC8     INC usbHostState
003170  37010A     BRA 0x3386
1988:                                          }
1989:                                          break;
1990:              
1991:                                      case SUBSUBSTATE_SEND_SET_OTG:
1992:              #ifdef DEBUG_MODE
1993:                                          UART2PrintString("HOST: Determine OTG capability.\r\n");
1994:              #endif
1995:              
1996:                                          // If the device does not support OTG, or
1997:                                          // if the device has already been configured, bail.
1998:                                          // Otherwise, send SET FEATURE to configure it.
1999:                                          if (!usbDeviceInfo.flags.bfConfiguredOTG) {
003172  BFCEDE     MOV.B 0xEDE, WREG
003174  6040E4     AND.B W0, #0x4, W1
003176  3A0022     BRA NZ, 0x31BC
2000:              #ifdef DEBUG_MODE
2001:                                              UART2PrintString("HOST: ...OTG needs configuring.\r\n");
2002:              #endif
2003:                                              usbDeviceInfo.flags.bfConfiguredOTG = 1;
003178  A84EDE     BSET 0xEDE, #2
2004:              
2005:                                              // Send SET FEATURE
2006:                                              pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
00317A  8075D0     MOV pEP0Data, W0
00317C  784801     MOV.B W1, [W0]
2007:                                              pEP0Data[1] = USB_REQUEST_SET_FEATURE;
00317E  B3C031     MOV.B #0x3, W1
003180  8075D0     MOV pEP0Data, W0
003182  984011     MOV.B W1, [W0+1]
2008:                                              if (usbDeviceInfo.flags.bfAllowHNP) // Needs to be set by the user
003184  BFCEDE     MOV.B 0xEDE, WREG
003186  A33800     BTST.Z W0, #3
003188  320003     BRA Z, 0x3190
2009:                                              {
2010:                                                  pEP0Data[2] = OTG_FEATURE_B_HNP_ENABLE;
00318A  8075D0     MOV pEP0Data, W0
00318C  984021     MOV.B W1, [W0+2]
00318E  370003     BRA 0x3196
2011:                                              } else {
2012:                                                  pEP0Data[2] = OTG_FEATURE_A_HNP_SUPPORT;
003190  B3C041     MOV.B #0x4, W1
003192  8075D0     MOV pEP0Data, W0
003194  984021     MOV.B W1, [W0+2]
2013:                                              }
2014:                                              pEP0Data[3] = 0;
003196  EB4080     CLR.B W1
003198  8075D0     MOV pEP0Data, W0
00319A  984031     MOV.B W1, [W0+3]
2015:                                              pEP0Data[4] = 0;
00319C  8075D0     MOV pEP0Data, W0
00319E  984041     MOV.B W1, [W0+4]
2016:                                              pEP0Data[5] = 0;
0031A0  8075D0     MOV pEP0Data, W0
0031A2  984051     MOV.B W1, [W0+5]
2017:                                              pEP0Data[6] = 0;
0031A4  8075D0     MOV pEP0Data, W0
0031A6  984061     MOV.B W1, [W0+6]
2018:                                              pEP0Data[7] = 0;
0031A8  8075D0     MOV pEP0Data, W0
0031AA  984071     MOV.B W1, [W0+7]
2019:                                              _USB_InitControlWrite(usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0);
0031AC  8075D1     MOV pEP0Data, W1
0031AE  8076E0     MOV 0xEDC, W0
0031B0  EB0200     CLR W4
0031B2  780184     MOV W4, W3
0031B4  200082     MOV #0x8, W2
0031B6  0706C3     RCALL _USB_InitControlWrite
2020:                                              _USB_SetNextSubSubState();
0031B8  EC2EC8     INC usbHostState
0031BA  3700E5     BRA 0x3386
2021:                                          } else {
2022:              #ifdef DEBUG_MODE
2023:                                              UART2PrintString("HOST: ...No OTG.\r\n");
2024:              #endif
2025:                                              _USB_SetNextSubState();
0031BC  807640     MOV usbHostState, W0
0031BE  20FF01     MOV #0xFF0, W1
0031C0  600001     AND W0, W1, W0
0031C2  400070     ADD W0, #0x10, W0
0031C4  887640     MOV W0, usbHostState
0031C6  3700DF     BRA 0x3386
2026:                                          }
2027:                                          break;
2028:              
2029:                                      case SUBSUBSTATE_WAIT_FOR_SET_OTG_DONE:
2030:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
0031C8  8076E1     MOV 0xEDC, W1
0031CA  904031     MOV.B [W1+3], W0
0031CC  A31800     BTST.Z W0, #1
0031CE  3200DB     BRA Z, 0x3386
2031:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
0031D0  904031     MOV.B [W1+3], W0
0031D2  A30800     BTST.Z W0, #0
0031D4  320002     BRA Z, 0x31DA
2032:              #ifdef  USB_SUPPORT_OTG
2033:                                                  if (usbDeviceInfo.flags.bfAllowHNP) {
2034:                                                      USBOTGEnableHnp();
2035:                                                  }
2036:              #endif
2037:                                                  _USB_SetNextSubSubState();
0031D6  EC2EC8     INC usbHostState
0031D8  3700D6     BRA 0x3386
2038:                                              } else {
2039:              #ifdef  USB_SUPPORT_OTG
2040:                                                  USBOTGDisableHnp();
2041:              #endif
2042:                                                  // We are here because of either a STALL or a NAK.  See if
2043:                                                  // we have retries left to try the command again or try to
2044:                                                  // enumerate again.
2045:                                                  _USB_CheckCommandAndEnumerationAttempts();
0031DA  07015B     RCALL _USB_CheckCommandAndEnumerationAttempts
0031DC  3700D4     BRA 0x3386
2046:              
2047:              #if defined(DEBUG_MODE) && defined(USB_SUPPORT_OTG)
2048:                                                  UART2PrintString("\r\n***** USB OTG Error - Set Feature B_HNP_ENABLE Stalled - Device Not Responding *****\r\n");
2049:              #endif
2050:                                              }
2051:                                          }
2052:                                          break;
2053:              
2054:                                      case SUBSUBSTATE_SET_OTG_COMPLETE:
2055:                                          // Clean up and advance to the next state.
2056:                                          _USB_InitErrorCounters();
0031DE  B3C030     MOV.B #0x3, W0
0031E0  B7EEC1     MOV.B WREG, numCommandTries
2057:              
2058:                                          //MR - Moved For OTG Set Feature Support For Unsupported Devices
2059:                                          // Did we fail to configure?
2060:                                          if (pCurrentConfigurationNode == NULL) {
0031E2  E20EBE     CP0 pCurrentConfigurationNode
0031E4  3A0005     BRA NZ, 0x31F0
2061:                                              // Failed to find a supported configuration.
2062:                                              _USB_SetErrorCode(USB_HOLDING_UNSUPPORTED_DEVICE);
0031E6  B3C340     MOV.B #0x34, W0
0031E8  B7EED4     MOV.B WREG, 0xED4
2063:                                              _USB_SetHoldState();
0031EA  205000     MOV #0x500, W0
0031EC  887640     MOV W0, usbHostState
0031EE  3700CB     BRA 0x3386
2064:                                          } else {
2065:                                              //_USB_SetNextSubSubState();
2066:                                              _USB_InitErrorCounters();
0031F0  B3C030     MOV.B #0x3, W0
0031F2  B7EEC1     MOV.B WREG, numCommandTries
2067:                                              _USB_SetNextSubState();
0031F4  807640     MOV usbHostState, W0
0031F6  20FF01     MOV #0xFF0, W1
0031F8  600001     AND W0, W1, W0
0031FA  400070     ADD W0, #0x10, W0
0031FC  887640     MOV W0, usbHostState
0031FE  3700C3     BRA 0x3386
2068:                                          }
2069:                                          break;
2070:              
2071:                                      default:
2072:                                          break;
2073:                                  }
2074:                                  break;
2075:              
2076:                              case SUBSTATE_SET_CONFIGURATION:
2077:                                  // Set the configuration to the one specified for this device
2078:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
003200  807640     MOV usbHostState, W0
003202  60006F     AND W0, #0xF, W0
003204  500FE1     SUB W0, #0x1, [W15]
003206  320022     BRA Z, 0x324C
003208  390005     BRA NC, 0x3214
00320A  500FE2     SUB W0, #0x2, [W15]
00320C  32002A     BRA Z, 0x3262
00320E  500FE3     SUB W0, #0x3, [W15]
003210  3A00BA     BRA NZ, 0x3386
003212  37002B     BRA 0x326A
2079:                                      case SUBSUBSTATE_SEND_SET_CONFIGURATION:
2080:              #ifdef DEBUG_MODE
2081:                                          UART2PrintString("HOST: Set configuration.\r\n");
2082:              #endif
2083:              
2084:                                          // Set up and send SET CONFIGURATION.
2085:                                          pEP0Data[0] = USB_SETUP_HOST_TO_DEVICE | USB_SETUP_TYPE_STANDARD | USB_SETUP_RECIPIENT_DEVICE;
003214  EB4100     CLR.B W2
003216  8075D0     MOV pEP0Data, W0
003218  784802     MOV.B W2, [W0]
2086:                                          pEP0Data[1] = USB_REQUEST_SET_CONFIGURATION;
00321A  B3C091     MOV.B #0x9, W1
00321C  8075D0     MOV pEP0Data, W0
00321E  984011     MOV.B W1, [W0+1]
2087:                                          pEP0Data[2] = usbDeviceInfo.currentConfiguration;
003220  8075D0     MOV pEP0Data, W0
003222  20ED01     MOV #0xED0, W1
003224  784091     MOV.B [W1], W1
003226  984021     MOV.B W1, [W0+2]
2088:                                          pEP0Data[3] = 0;
003228  8075D0     MOV pEP0Data, W0
00322A  984032     MOV.B W2, [W0+3]
2089:                                          pEP0Data[4] = 0;
00322C  8075D0     MOV pEP0Data, W0
00322E  984042     MOV.B W2, [W0+4]
2090:                                          pEP0Data[5] = 0;
003230  8075D0     MOV pEP0Data, W0
003232  984052     MOV.B W2, [W0+5]
2091:                                          pEP0Data[6] = 0;
003234  8075D0     MOV pEP0Data, W0
003236  984062     MOV.B W2, [W0+6]
2092:                                          pEP0Data[7] = 0;
003238  8075D0     MOV pEP0Data, W0
00323A  984072     MOV.B W2, [W0+7]
2093:                                          _USB_InitControlWrite(usbDeviceInfo.pEndpoint0, pEP0Data, 8, NULL, 0);
00323C  8075D1     MOV pEP0Data, W1
00323E  8076E0     MOV 0xEDC, W0
003240  EB0200     CLR W4
003242  780184     MOV W4, W3
003244  200082     MOV #0x8, W2
003246  07067B     RCALL _USB_InitControlWrite
2094:                                          _USB_SetNextSubSubState();
003248  EC2EC8     INC usbHostState
00324A  37009D     BRA 0x3386
2095:                                          break;
2096:              
2097:                                      case SUBSUBSTATE_WAIT_FOR_SET_CONFIGURATION:
2098:                                          if (usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
00324C  8076E1     MOV 0xEDC, W1
00324E  904031     MOV.B [W1+3], W0
003250  A31800     BTST.Z W0, #1
003252  320099     BRA Z, 0x3386
2099:                                              if (usbDeviceInfo.pEndpoint0->status.bfTransferSuccessful) {
003254  904031     MOV.B [W1+3], W0
003256  A30800     BTST.Z W0, #0
003258  320002     BRA Z, 0x325E
2100:                                                  _USB_SetNextSubSubState();
00325A  EC2EC8     INC usbHostState
00325C  370094     BRA 0x3386
2101:                                              } else {
2102:                                                  // We are here because of either a STALL or a NAK.  See if
2103:                                                  // we have retries left to try the command again or try to
2104:                                                  // enumerate again.
2105:                                                  _USB_CheckCommandAndEnumerationAttempts();
00325E  070119     RCALL _USB_CheckCommandAndEnumerationAttempts
003260  370092     BRA 0x3386
2106:                                              }
2107:                                          }
2108:                                          break;
2109:              
2110:                                      case SUBSUBSTATE_SET_CONFIGURATION_COMPLETE:
2111:                                          // Clean up and advance to the next state.
2112:                                          _USB_InitErrorCounters();
003262  B3C030     MOV.B #0x3, W0
003264  B7EEC1     MOV.B WREG, numCommandTries
2113:                                          _USB_SetNextSubSubState();
003266  EC2EC8     INC usbHostState
003268  37008E     BRA 0x3386
2114:                                          break;
2115:              
2116:                                      case SUBSUBSTATE_INIT_CLIENT_DRIVERS:
2117:              #ifdef DEBUG_MODE
2118:                                          UART2PrintString("HOST: Initializing client drivers...\r\n");
2119:              #endif
2120:                                          _USB_SetNextState();
00326A  807640     MOV usbHostState, W0
00326C  20F001     MOV #0xF00, W1
00326E  600001     AND W0, W1, W0
003270  B01000     ADD #0x100, W0
003272  887640     MOV W0, usbHostState
2121:                                          // Initialize client driver(s) for this configuration.
2122:                                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver) {
003274  BFCEDE     MOV.B 0xEDE, WREG
003276  A36800     BTST.Z W0, #6
003278  320014     BRA Z, 0x32A2
2123:                                              // We have a device that requires only one client driver.  Make sure
2124:                                              // that client driver can initialize this device.  If the client
2125:                                              // driver initialization fails, we cannot enumerate this device.
2126:              #ifdef DEBUG_MODE
2127:                                              UART2PrintString("HOST: Using device client driver.\r\n");
2128:              #endif
2129:                                              temp = usbDeviceInfo.deviceClientDriver;
00327A  20ED51     MOV #0xED5, W1
00327C  784091     MOV.B [W1], W1
2130:                                              if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp)) {
00327E  784001     MOV.B W1, W0
003280  B3C0A2     MOV.B #0xA, W2
003282  BC4004     MUL.B WREG2
003284  780182     MOV W2, W3
003286  20DF62     MOV #0xDF6, W2
003288  418202     ADD W3, W2, W4
00328A  BFCED3     MOV.B 0xED3, WREG
00328C  7902E3     MOV [W3+W2], W5
00328E  900134     MOV [W4+6], W2
003290  9001C4     MOV [W4+8], W3
003292  010005     CALL W5
003294  E00000     CP0 W0
003296  3A0077     BRA NZ, 0x3386
2131:                                                  _USB_SetErrorCode(USB_HOLDING_CLIENT_INIT_ERROR);
003298  B3C390     MOV.B #0x39, W0
00329A  B7EED4     MOV.B WREG, 0xED4
2132:                                                  _USB_SetHoldState();
00329C  205000     MOV #0x500, W0
00329E  887640     MOV W0, usbHostState
0032A0  370072     BRA 0x3386
2133:                                              }
2134:                                          } else {
2135:                                              // We have a device that requires multiple client drivers.  Make sure
2136:                                              // every required client driver can initialize this device.  If any
2137:                                              // client driver initialization fails, we cannot enumerate the device.
2138:              #ifdef DEBUG_MODE
2139:                                              UART2PrintString("HOST: Scanning interfaces.\r\n");
2140:              #endif
2141:                                              pCurrentInterface = usbDeviceInfo.pInterfaceList;
0032A2  8076D8     MOV 0xEDA, W8
2142:                                              while (pCurrentInterface) {
0032A4  E00008     CP0 W8
0032A6  32006F     BRA Z, 0x3386
0032A8  20DF69     MOV #0xDF6, W9
0032CC  E00008     CP0 W8
0032CE  32005B     BRA Z, 0x3386
0032D0  37FFEC     BRA 0x32AA
2143:                                                  temp = pCurrentInterface->clientDriver;
0032AA  9040F8     MOV.B [W8+7], W1
2144:                                                  if (!usbClientDrvTable[temp].Initialize(usbDeviceInfo.deviceAddress, usbClientDrvTable[temp].flags, temp)) {
0032AC  784001     MOV.B W1, W0
0032AE  B3C0A2     MOV.B #0xA, W2
0032B0  BC4004     MUL.B WREG2
0032B2  410189     ADD W2, W9, W3
0032B4  BFCED3     MOV.B 0xED3, WREG
0032B6  7C8262     MOV [W2+W9], W4
0032B8  900133     MOV [W3+6], W2
0032BA  9001C3     MOV [W3+8], W3
0032BC  010004     CALL W4
0032BE  E00000     CP0 W0
0032C0  3A0004     BRA NZ, 0x32CA
2145:                                                      _USB_SetErrorCode(USB_HOLDING_CLIENT_INIT_ERROR);
0032C2  B3C390     MOV.B #0x39, W0
0032C4  B7EED4     MOV.B WREG, 0xED4
2146:                                                      _USB_SetHoldState();
0032C6  205000     MOV #0x500, W0
0032C8  887640     MOV W0, usbHostState
2147:                                                  }
2148:                                                  pCurrentInterface = pCurrentInterface->next;
0032CA  780418     MOV [W8], W8
2149:                                              }
2150:                                          }
2151:                                          break;
2152:              
2153:                                      default:
2154:                                          break;
2155:                                  }
2156:                                  break;
2157:                          }
2158:                          break;
2159:              
2160:                      case STATE_RUNNING:
2161:                          switch (usbHostState & SUBSTATE_MASK) {
0032D2  807640     MOV usbHostState, W0
0032D4  B20F00     AND #0xF0, W0
0032D6  500FF0     SUB W0, #0x10, [W15]
0032D8  3A0056     BRA NZ, 0x3386
2162:                              case SUBSTATE_NORMAL_RUN:
2163:                                  break;
2164:              
2165:                              case SUBSTATE_SUSPEND_AND_RESUME:
2166:                                  switch (usbHostState & SUBSUBSTATE_MASK) {
0032DA  807640     MOV usbHostState, W0
0032DC  60006F     AND W0, #0xF, W0
0032DE  500FE3     SUB W0, #0x3, [W15]
0032E0  32000C     BRA Z, 0x32FA
0032E2  500FE5     SUB W0, #0x5, [W15]
0032E4  320013     BRA Z, 0x330C
0032E6  500FE1     SUB W0, #0x1, [W15]
0032E8  3A004E     BRA NZ, 0x3386
2167:                                      case SUBSUBSTATE_SUSPEND:
2168:                                          // The IDLE state has already been set.  We need to wait here
2169:                                          // until the application decides to RESUME.
2170:                                          break;
2171:              
2172:                                      case SUBSUBSTATE_RESUME:
2173:                                          // Issue a RESUME.
2174:                                          U1CONbits.RESUME = 1;
0032EA  A84494     BSET U1CON, #2
2175:              
2176:                                          // Wait for the RESUME time.
2177:                                          numTimerInterrupts = USB_RESUME_TIME;
0032EC  200150     MOV #0x15, W0
0032EE  887620     MOV W0, numTimerInterrupts
2178:                                          U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
0032F0  200400     MOV #0x40, W0
0032F2  882400     MOV W0, U1OTGIR
2179:                                          U1OTGIEbits.T1MSECIE = 1;
0032F4  A8C482     BSET U1OTGIE, #6
2180:              
2181:                                          _USB_SetNextSubSubState();
0032F6  EC2EC8     INC usbHostState
0032F8  370046     BRA 0x3386
2182:                                          break;
2183:              
2184:                                      case SUBSUBSTATE_RESUME_WAIT:
2185:                                          // Wait here until the timer expires.
2186:                                          break;
2187:              
2188:                                      case SUBSUBSTATE_RESUME_RECOVERY:
2189:                                          // Turn off RESUME.
2190:                                          U1CONbits.RESUME = 0;
0032FA  A94494     BCLR U1CON, #2
2191:              
2192:                                          // Start sending SOF's, so the device doesn't go back into the SUSPEND state.
2193:                                          U1CONbits.SOFEN = 1;
0032FC  A80494     BSET U1CON, #0
2194:              
2195:                                          // Wait for the RESUME recovery time.
2196:                                          numTimerInterrupts = USB_RESUME_RECOVERY_TIME;
0032FE  2000B0     MOV #0xB, W0
003300  887620     MOV W0, numTimerInterrupts
2197:                                          U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
003302  200400     MOV #0x40, W0
003304  882400     MOV W0, U1OTGIR
2198:                                          U1OTGIEbits.T1MSECIE = 1;
003306  A8C482     BSET U1OTGIE, #6
2199:              
2200:                                          _USB_SetNextSubSubState();
003308  EC2EC8     INC usbHostState
00330A  37003D     BRA 0x3386
2201:                                          break;
2202:              
2203:                                      case SUBSUBSTATE_RESUME_RECOVERY_WAIT:
2204:                                          // Wait here until the timer expires.
2205:                                          break;
2206:              
2207:                                      case SUBSUBSTATE_RESUME_COMPLETE:
2208:                                          // Go back to normal running.
2209:                                          usbHostState = STATE_RUNNING | SUBSTATE_NORMAL_RUN;
00330C  204000     MOV #0x400, W0
00330E  887640     MOV W0, usbHostState
003310  37003A     BRA 0x3386
2210:                                          break;
2211:                                  }
2212:                          }
2213:                          break;
2214:              
2215:                      case STATE_HOLDING:
2216:                          switch (usbHostState & SUBSTATE_MASK) {
003312  807642     MOV usbHostState, W2
003314  B20F02     AND #0xF0, W2
003316  3A0037     BRA NZ, 0x3386
2217:                              case SUBSTATE_HOLD_INIT:
2218:                                  // We're here because we cannot communicate with the current device
2219:                                  // that is plugged in.  Turn off SOF's and all interrupts except
2220:                                  // the DETACH interrupt.
2221:              #ifdef DEBUG_MODE
2222:                                  UART2PrintString("HOST: Holding.\r\n");
2223:              #endif
2224:                                  U1CON = USB_HOST_MODE_ENABLE | USB_SOF_DISABLE; // Turn of SOF's to cut down noise
003318  200080     MOV #0x8, W0
00331A  8824A0     MOV W0, U1CON
2225:                                  U1IE = 0;
00331C  882462     MOV W2, U1IE
2226:                                  U1IR = 0xFF;
00331E  200FF1     MOV #0xFF, W1
003320  882451     MOV W1, U1IR
2227:                                  U1OTGIE &= 0x8C;
003322  2008C0     MOV #0x8C, W0
003324  B62482     AND U1OTGIE
2228:                                  U1OTGIR = 0x7D;
003326  50006F     SUB W0, #0xF, W0
003328  882400     MOV W0, U1OTGIR
2229:                                  U1EIE = 0;
00332A  882482     MOV W2, U1EIE
2230:                                  U1EIR = 0xFF;
00332C  882471     MOV W1, U1EIR
2231:                                  U1IEbits.DETACHIE = 1;
00332E  A8048C     BSET U1IE, #0
2232:              
2233:              #if defined(USB_ENABLE_1MS_EVENT)
2234:                                  U1OTGIR = USB_INTERRUPT_T1MSECIF; // The interrupt is cleared by writing a '1' to the flag.
2235:                                  U1OTGIEbits.T1MSECIE = 1;
2236:              #endif
2237:              
2238:                                  switch (usbDeviceInfo.errorCode) {
003330  20ED42     MOV #0xED4, W2
003332  784112     MOV.B [W2], W2
003334  B3C340     MOV.B #0x34, W0
003338  514F80     SUB.B W2, W0, [W15]
00333A  320015     BRA Z, 0x3366
00333C  3E0007     BRA GTU, 0x334C
003340  514FE7     SUB.B W2, #0x7, [W15]
003342  320011     BRA Z, 0x3366
003344  E94000     DEC.B W0, W0
003346  514F80     SUB.B W2, W0, [W15]
003348  3A000B     BRA NZ, 0x3360
00334A  370008     BRA 0x335C
00334C  B3C651     MOV.B #0x65, W1
00334E  B3C350     MOV.B #0x35, W0
003350  514F80     SUB.B W2, W0, [W15]
003352  320009     BRA Z, 0x3366
003354  404064     ADD.B W0, #0x4, W0
003356  514F80     SUB.B W2, W0, [W15]
003358  3A0003     BRA NZ, 0x3360
00335A  370004     BRA 0x3364
00335C  B3C6F1     MOV.B #0x6F, W1
00335E  370003     BRA 0x3366
003360  B3C701     MOV.B #0x70, W1
003362  370001     BRA 0x3366
2239:                                      case USB_HOLDING_UNSUPPORTED_HUB:
2240:                                          temp = EVENT_HUB_ATTACH;
2241:                                          break;
003336  B3C6C1     MOV.B #0x6C, W1
2242:              
2243:                                      case USB_HOLDING_UNSUPPORTED_DEVICE:
2244:                                          temp = EVENT_UNSUPPORTED_DEVICE;
2245:              
2246:              #ifdef  USB_SUPPORT_OTG
2247:                                          //Abort HNP
2248:                                          USB_OTGEventHandler(0, OTG_EVENT_HNP_ABORT, 0, 0);
2249:              #endif
2250:              
2251:                                          break;
00333E  E84081     INC.B W1, W1
2252:              
2253:                                      case USB_CANNOT_ENUMERATE:
2254:                                          temp = EVENT_CANNOT_ENUMERATE;
2255:                                          break;
003364  B3C6E1     MOV.B #0x6E, W1
2256:              
2257:                                      case USB_HOLDING_CLIENT_INIT_ERROR:
2258:                                          temp = EVENT_CLIENT_INIT_ERROR;
2259:                                          break;
2260:              
2261:                                      case USB_HOLDING_OUT_OF_MEMORY:
2262:                                          temp = EVENT_OUT_OF_MEMORY;
2263:                                          break;
2264:              
2265:                                      default:
2266:                                          temp = EVENT_UNSPECIFIED_ERROR; // This should never occur
2267:                                          break;
2268:                                  }
2269:              
2270:                                  // Report the problem to the application.
2271:                                  USB_HOST_APP_EVENT_HANDLER(usbDeviceInfo.deviceAddress, temp, &usbDeviceInfo.currentConfigurationPower, 1);
003366  FB8081     ZE W1, W1
003368  BFCED3     MOV.B 0xED3, WREG
00336A  200014     MOV #0x1, W4
00336C  200005     MOV #0x0, W5
00336E  20ED62     MOV #0xED6, W2
003370  072406     RCALL USB_ApplicationEventHandler
2272:              
2273:                                  _USB_SetNextSubState();
003372  807640     MOV usbHostState, W0
003374  20FF01     MOV #0xFF0, W1
003376  600001     AND W0, W1, W0
003378  400070     ADD W0, #0x10, W0
00337A  887640     MOV W0, usbHostState
00337C  370004     BRA 0x3386
2274:                                  break;
2275:              
2276:                              case SUBSTATE_HOLD:
2277:                                  // Hold here until a DETACH interrupt frees us.
2278:                                  break;
2279:              
2280:                              default:
2281:                                  break;
2282:                          }
2283:                          break;
2284:                  }
2285:              
2286:              }
003386  BE044F     MOV.D [--W15], W8
003388  FA8000     ULNK
00338A  060000     RETURN
2287:              
2288:              /****************************************************************************
2289:                Function:
2290:                  void USBHostTerminateTransfer( BYTE deviceAddress, BYTE endpoint )
2291:              
2292:              
2293:                Summary:
2294:                  This function terminates the current transfer for the given endpoint.
2295:              
2296:                Description:
2297:                  This function terminates the current transfer for the given endpoint.  It
2298:                  can be used to terminate reads or writes that the device is not
2299:                  responding to.  It is also the only way to terminate an isochronous
2300:                  transfer.
2301:              
2302:                Precondition:
2303:                  None
2304:              
2305:                Parameters:
2306:                  BYTE deviceAddress  - Device address
2307:                  BYTE endpoint       - Endpoint number
2308:              
2309:                Returns:
2310:                  None
2311:              
2312:                Remarks:
2313:                  None
2314:               ***************************************************************************/
2315:              
2316:              void USBHostTerminateTransfer(BYTE deviceAddress, BYTE endpoint) {
2317:                  USB_ENDPOINT_INFO *ep;
2318:              
2319:                  // Find the required device
2320:                  if (deviceAddress != usbDeviceInfo.deviceAddress) {
00338C  E34ED3     CP.B 0xED3
00338E  3A000B     BRA NZ, 0x33A6
2321:                      return; // USB_UNKNOWN_DEVICE;
2322:                  }
2323:              
2324:                  ep = _USB_FindEndpoint(endpoint);
003390  784001     MOV.B W1, W0
003392  070147     RCALL _USB_FindEndpoint
003394  780080     MOV W0, W1
2325:                  if (ep != NULL) {
003396  E00000     CP0 W0
003398  320006     BRA Z, 0x33A6
2326:                      ep->status.bfUserAbort = 1;
00339A  904020     MOV.B [W0+2], W0
00339C  A07400     BSET.B W0, #7
00339E  9840A0     MOV.B W0, [W1+2]
2327:                      ep->status.bfTransferComplete = 1;
0033A0  904031     MOV.B [W1+3], W0
0033A2  A01400     BSET.B W0, #1
0033A4  9840B0     MOV.B W0, [W1+3]
2328:                  }
2329:              }
0033A6  060000     RETURN
2330:              
2331:              /****************************************************************************
2332:                Function:
2333:                  BOOL USBHostTransferIsComplete( BYTE deviceAddress, BYTE endpoint,
2334:                                      BYTE *errorCode, DWORD *byteCount )
2335:              
2336:                Summary:
2337:                  This function initiates whether or not the last endpoint transaction is
2338:                  complete.
2339:              
2340:                Description:
2341:                  This function initiates whether or not the last endpoint transaction is
2342:                  complete.  If it is complete, an error code and the number of bytes
2343:                  transferred are returned.
2344:              
2345:                  For isochronous transfers, byteCount is not valid.  Instead, use the
2346:                  returned byte counts for each EVENT_TRANSFER event that was generated
2347:                  during the transfer.
2348:              
2349:                Precondition:
2350:                  None
2351:              
2352:                Parameters:
2353:                  BYTE deviceAddress  - Device address
2354:                  BYTE endpoint       - Endpoint number
2355:                  BYTE *errorCode     - Error code indicating the status of the transfer.
2356:                                          Only valid if the transfer is complete.
2357:                  DWORD *byteCount    - The number of bytes sent or received.  Invalid
2358:                                          for isochronous transfers.
2359:              
2360:                Return Values:
2361:                  TRUE    - Transfer is complete.
2362:                  FALSE   - Transfer is not complete.
2363:              
2364:                Remarks:
2365:                  Possible values for errorCode are:
2366:               * USB_SUCCESS                     - Transfer successful
2367:               * USB_UNKNOWN_DEVICE              - Device not attached
2368:               * USB_ENDPOINT_STALLED            - Endpoint STALL'd
2369:               * USB_ENDPOINT_ERROR_ILLEGAL_PID  - Illegal PID returned
2370:               * USB_ENDPOINT_ERROR_BIT_STUFF
2371:               * USB_ENDPOINT_ERROR_DMA
2372:               * USB_ENDPOINT_ERROR_TIMEOUT
2373:               * USB_ENDPOINT_ERROR_DATA_FIELD
2374:               * USB_ENDPOINT_ERROR_CRC16
2375:               * USB_ENDPOINT_ERROR_END_OF_FRAME
2376:               * USB_ENDPOINT_ERROR_PID_CHECK
2377:               * USB_ENDPOINT_ERROR              - Other error
2378:               ***************************************************************************/
2379:              
2380:              BOOL USBHostTransferIsComplete(BYTE deviceAddress, BYTE endpoint, BYTE *errorCode,
2381:                      DWORD *byteCount) {
0033A8  BE9F88     MOV.D W8, [W15++]
0033AA  BE0402     MOV.D W2, W8
2382:                  USB_ENDPOINT_INFO *ep;
2383:                  BYTE transferComplete;
2384:              
2385:                  // Find the required device
2386:                  if (deviceAddress != usbDeviceInfo.deviceAddress) {
0033AC  E34ED3     CP.B 0xED3
0033AE  320006     BRA Z, 0x33BC
2387:                      *errorCode = USB_UNKNOWN_DEVICE;
0033B0  B3C060     MOV.B #0x6, W0
0033B2  784900     MOV.B W0, [W2]
2388:                      *byteCount = 0;
0033B4  EB0980     CLR [W3]
0033B6  7811B3     MOV [W3++], [W3--]
0033B8  200010     MOV #0x1, W0
0033BA  370023     BRA 0x3402
2389:                      return TRUE;
2390:                  }
2391:              
2392:                  ep = _USB_FindEndpoint(endpoint);
0033BC  784001     MOV.B W1, W0
0033BE  070131     RCALL _USB_FindEndpoint
0033C0  780080     MOV W0, W1
2393:                  if (ep != NULL) {
0033C2  E00000     CP0 W0
0033C4  32001B     BRA Z, 0x33FC
2394:                      // bfTransferComplete, the status flags, and byte count can be
2395:                      // changed in an interrupt service routine.  Therefore, we'll
2396:                      // grab it first, save it locally, and then determine the rest of
2397:                      // the information.  It is better to say that the transfer is not
2398:                      // yet complete, since the caller will simply try again.
2399:              
2400:                      // Save off the Transfer Complete status.  That way, we won't
2401:                      // load up bad values and then say the transfer is complete.
2402:                      transferComplete = ep->status.bfTransferComplete;
0033C6  904030     MOV.B [W0+3], W0
0033C8  D10000     LSR W0, W0
0033CA  604161     AND.B W0, #0x1, W2
2403:              
2404:                      // Set up error code.  This is only valid if the transfer is complete.
2405:                      if (ep->status.bfTransferSuccessful) {
0033CC  904031     MOV.B [W1+3], W0
0033CE  A30800     BTST.Z W0, #0
0033D0  320005     BRA Z, 0x33DC
2406:                          *errorCode = USB_SUCCESS;
0033D2  EB4C00     CLR.B [W8]
2407:                          *byteCount = ep->dataCount;
0033D4  900A01     MOV [W1+16], W4
0033D6  900A91     MOV [W1+18], W5
0033D8  BE8C84     MOV.D W4, [W9]
0033DA  37000E     BRA 0x33F8
2408:                      } else if (ep->status.bfStalled) {
0033DC  904021     MOV.B [W1+2], W0
0033DE  A35800     BTST.Z W0, #5
0033E0  320003     BRA Z, 0x33E8
2409:                          *errorCode = USB_ENDPOINT_STALLED;
0033E2  B3C110     MOV.B #0x11, W0
0033E4  784C00     MOV.B W0, [W8]
0033E6  370008     BRA 0x33F8
2410:                      } else if (ep->status.bfError) {
0033E8  904021     MOV.B [W1+2], W0
0033EA  A36800     BTST.Z W0, #6
0033EC  320003     BRA Z, 0x33F4
2411:                          *errorCode = ep->bErrorCode;
0033EE  9058C1     MOV.B [W1+28], W1
0033F0  784C01     MOV.B W1, [W8]
0033F2  370002     BRA 0x33F8
2412:                      } else {
2413:                          *errorCode = USB_ENDPOINT_UNRESOLVED_STATE;
0033F4  B3C190     MOV.B #0x19, W0
0033F6  784C00     MOV.B W0, [W8]
2414:                      }
2415:              
2416:                      return transferComplete;
0033F8  FB8002     ZE W2, W0
0033FA  370003     BRA 0x3402
2417:                  }
2418:              
2419:                  // The endpoint was not found.  Return TRUE so we can return a valid error code.
2420:                  *errorCode = USB_ENDPOINT_NOT_FOUND;
0033FC  B3C140     MOV.B #0x14, W0
0033FE  784C00     MOV.B W0, [W8]
003400  200010     MOV #0x1, W0
2421:                  return TRUE;
2422:              }
003402  BE044F     MOV.D [--W15], W8
003404  060000     RETURN
2423:              
2424:              /****************************************************************************
2425:                Function:
2426:                  BYTE  USBHostVbusEvent( USB_EVENT vbusEvent, BYTE hubAddress,
2427:                                                      BYTE portNumber)
2428:              
2429:                Summary:
2430:                  This function handles Vbus events that are detected by the application.
2431:              
2432:                Description:
2433:                  This function handles Vbus events that are detected by the application.
2434:                  Since Vbus management is application dependent, the application is
2435:                  responsible for monitoring Vbus and detecting overcurrent conditions
2436:                  and removal of the overcurrent condition.  If the application detects
2437:                  an overcurrent condition, it should call this function with the event
2438:                  EVENT_VBUS_OVERCURRENT with the address of the hub and port number that
2439:                  has the condition.  When a port returns to normal operation, the
2440:                  application should call this function with the event
2441:                  EVENT_VBUS_POWER_AVAILABLE so the stack knows that it can allow devices
2442:                  to attach to that port.
2443:              
2444:                Precondition:
2445:                  None
2446:              
2447:                Parameters:
2448:                  USB_EVENT vbusEvent     - Vbus event that occured.  Valid events:
2449:               * EVENT_VBUS_OVERCURRENT
2450:               * EVENT_VBUS_POWER_AVAILABLE
2451:                  BYTE hubAddress         - Address of the hub device (USB_ROOT_HUB for the
2452:                                              root hub)
2453:                  BYTE portNumber         - Number of the physical port on the hub (0 - based)
2454:              
2455:                Return Values:
2456:                  USB_SUCCESS             - Event handled
2457:                  USB_ILLEGAL_REQUEST     - Invalid event, hub, or port
2458:              
2459:                Remarks:
2460:                  None
2461:               ***************************************************************************/
2462:              
2463:              BYTE USBHostVbusEvent(USB_EVENT vbusEvent, BYTE hubAddress, BYTE portNumber) {
003406  780180     MOV W0, W3
2464:                  if ((hubAddress == USB_ROOT_HUB) &&
003408  40CFE1     ADD.B W1, #0x1, [W15]
00340A  3A000F     BRA NZ, 0x342A
00340C  E00402     CP0.B W2
00340E  3A000D     BRA NZ, 0x342A
2465:                          (portNumber == 0)) {
2466:                      if (vbusEvent == EVENT_VBUS_OVERCURRENT) {
003410  200680     MOV #0x68, W0
003412  518F80     SUB W3, W0, [W15]
003414  3A0004     BRA NZ, 0x341E
2467:                          USBHostShutdown();
003416  07FB45     RCALL USBHostShutdown
2468:                          usbRootHubInfo.flags.bPowerGoodPort0 = 0;
003418  A90F16     BCLR usbRootHubInfo, #0
00341A  EB0000     CLR W0
00341C  370007     BRA 0x342C
2469:                          return USB_SUCCESS;
2470:                      }
2471:                      if (vbusEvent == EVENT_VBUS_POWER_AVAILABLE) {
00341E  2006B0     MOV #0x6B, W0
003420  518F80     SUB W3, W0, [W15]
003422  3A0003     BRA NZ, 0x342A
2472:                          usbRootHubInfo.flags.bPowerGoodPort0 = 1;
003424  A80F16     BSET usbRootHubInfo, #0
003426  EB0000     CLR W0
003428  370001     BRA 0x342C
2473:                          return USB_SUCCESS;
00342A  200030     MOV #0x3, W0
2474:                      }
2475:                  }
2476:              
2477:                  return USB_ILLEGAL_REQUEST;
2478:              }
00342C  060000     RETURN
2479:              
2480:              /****************************************************************************
2481:                Function:
2482:                  BYTE USBHostWrite( BYTE deviceAddress, BYTE endpoint, BYTE *data,
2483:                                      DWORD size )
2484:              
2485:                Summary:
2486:                  This function initiates a write to the attached device.
2487:              
2488:                Description:
2489:                  This function initiates a write to the attached device.  The data buffer
2490:                  pointed to by *data must remain valid during the entire time that the
2491:                  write is taking place; the data is not buffered by the stack.
2492:              
2493:                  If the endpoint is isochronous, special conditions apply.  The pData and
2494:                  size parameters have slightly different meanings, since multiple buffers
2495:                  are required.  Once started, an isochronous transfer will continue with
2496:                  no upper layer intervention until USBHostTerminateTransfer() is called.
2497:                  The ISOCHRONOUS_DATA_BUFFERS structure should not be manipulated until
2498:                  the transfer is terminated.
2499:              
2500:                  To clarify parameter usage and to simplify casting, use the macro
2501:                  USBHostWriteIsochronous() when writing to an isochronous endpoint.
2502:              
2503:                Precondition:
2504:                  None
2505:              
2506:                Parameters:
2507:                  BYTE deviceAddress  - Device address
2508:                  BYTE endpoint       - Endpoint number
2509:                  BYTE *data          - Pointer to where the data is stored. If the endpoint
2510:                                          is isochronous, this points to an
2511:                                          ISOCHRONOUS_DATA_BUFFERS structure, with multiple
2512:                                          data buffer pointers.
2513:                  DWORD size          - Number of data bytes to send. If the endpoint is
2514:                                          isochronous, this is the number of data buffer
2515:                                          pointers pointed to by pData.
2516:              
2517:                Return Values:
2518:                  USB_SUCCESS                     - Write started successfully.
2519:                  USB_UNKNOWN_DEVICE              - Device with the specified address not found.
2520:                  USB_INVALID_STATE               - We are not in a normal running state.
2521:                  USB_ENDPOINT_ILLEGAL_TYPE       - Must use USBHostControlWrite to write
2522:                                                      to a control endpoint.
2523:                  USB_ENDPOINT_ILLEGAL_DIRECTION  - Must write to an OUT endpoint.
2524:                  USB_ENDPOINT_STALLED            - Endpoint is stalled.  Must be cleared
2525:                                                      by the application.
2526:                  USB_ENDPOINT_ERROR              - Endpoint has too many errors.  Must be
2527:                                                      cleared by the application.
2528:                  USB_ENDPOINT_BUSY               - A Write is already in progress.
2529:                  USB_ENDPOINT_NOT_FOUND          - Invalid endpoint.
2530:              
2531:                Remarks:
2532:                  None
2533:               ***************************************************************************/
2534:              
2535:              BYTE USBHostWrite(BYTE deviceAddress, BYTE endpoint, BYTE *data, DWORD size) {
00342E  BE9F88     MOV.D W8, [W15++]
003430  781F8A     MOV W10, [W15++]
003432  784181     MOV.B W1, W3
003434  780502     MOV W2, W10
003436  BE0404     MOV.D W4, W8
2536:                  USB_ENDPOINT_INFO *ep;
2537:              
2538:                  // Find the required device
2539:                  if (deviceAddress != usbDeviceInfo.deviceAddress) {
003438  200062     MOV #0x6, W2
00343A  E34ED3     CP.B 0xED3
00343C  3A0026     BRA NZ, 0x348A
2540:                      return USB_UNKNOWN_DEVICE;
2541:                  }
2542:              
2543:                  // If we are not in a normal user running state, we cannot do this.
2544:                  if ((usbHostState & STATE_MASK) != STATE_RUNNING) {
00343E  807640     MOV usbHostState, W0
003440  20F001     MOV #0xF00, W1
003442  600001     AND W0, W1, W0
003444  200012     MOV #0x1, W2
003446  204001     MOV #0x400, W1
003448  500F81     SUB W0, W1, [W15]
00344A  3A001F     BRA NZ, 0x348A
2545:                      return USB_INVALID_STATE;
2546:                  }
2547:              
2548:                  ep = _USB_FindEndpoint(endpoint);
00344C  784003     MOV.B W3, W0
00344E  0700E9     RCALL _USB_FindEndpoint
003450  780180     MOV W0, W3
2549:                  if (ep != NULL) {
003452  200142     MOV #0x14, W2
003454  E00000     CP0 W0
003456  320019     BRA Z, 0x348A
2550:                      if (ep->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL) {
003458  900850     MOV [W0+26], W0
00345A  B23000     AND #0x300, W0
00345C  200182     MOV #0x18, W2
00345E  320015     BRA Z, 0x348A
2551:                          // Must not be a control endpoint.
2552:                          return USB_ENDPOINT_ILLEGAL_TYPE;
2553:                      }
2554:              
2555:                      if (ep->bEndpointAddress & 0x80) {
003460  905823     MOV.B [W3+26], W0
003462  200152     MOV #0x15, W2
003464  E00400     CP0.B W0
003466  350011     BRA LT, 0x348A
2556:                          // Trying to do an OUT with an IN endpoint.
2557:                          return USB_ENDPOINT_ILLEGAL_DIRECTION;
2558:                      }
2559:              
2560:                      if (ep->status.bfStalled) {
003468  904023     MOV.B [W3+2], W0
00346A  200112     MOV #0x11, W2
00346C  A35800     BTST.Z W0, #5
00346E  3A000D     BRA NZ, 0x348A
2561:                          // The endpoint is stalled.  It must be restarted before a write
2562:                          // can be performed.
2563:                          return USB_ENDPOINT_STALLED;
2564:                      }
2565:              
2566:                      if (ep->status.bfError) {
003470  904023     MOV.B [W3+2], W0
003472  200122     MOV #0x12, W2
003474  A36800     BTST.Z W0, #6
003476  3A0009     BRA NZ, 0x348A
2567:                          // The endpoint has errored.  The error must be cleared before a
2568:                          // write can be performed.
2569:                          return USB_ENDPOINT_ERROR;
2570:                      }
2571:              
2572:                      if (!ep->status.bfTransferComplete) {
003478  904033     MOV.B [W3+3], W0
00347A  200102     MOV #0x10, W2
00347C  A31800     BTST.Z W0, #1
00347E  320005     BRA Z, 0x348A
2573:                          // We are already processing a request for this endpoint.
2574:                          return USB_ENDPOINT_BUSY;
2575:                      }
2576:              
2577:                      _USB_InitWrite(ep, data, size);
003480  780108     MOV W8, W2
003482  78008A     MOV W10, W1
003484  780003     MOV W3, W0
003486  0705B6     RCALL _USB_InitWrite
003488  EB0100     CLR W2
2578:              
2579:                      return USB_SUCCESS;
2580:                  }
2581:                  return USB_ENDPOINT_NOT_FOUND; // Endpoint not found
2582:              }
00348A  780002     MOV W2, W0
00348C  78054F     MOV [--W15], W10
00348E  BE044F     MOV.D [--W15], W8
003490  060000     RETURN
2583:              
2584:              
2585:              // *****************************************************************************
2586:              // *****************************************************************************
2587:              // Section: Internal Functions
2588:              // *****************************************************************************
2589:              // *****************************************************************************
2590:              
2591:              /****************************************************************************
2592:                Function:
2593:                  void _USB_CheckCommandAndEnumerationAttempts( void )
2594:              
2595:                Summary:
2596:                  This function is called when we've received a STALL or a NAK when trying
2597:                  to enumerate.
2598:              
2599:                Description:
2600:                  This function is called when we've received a STALL or a NAK when trying
2601:                  to enumerate.  We allow so many attempts at each command, and so many
2602:                  attempts at enumeration.  If the command fails and there are more command
2603:                  attempts, we try the command again.  If the command fails and there are
2604:                  more enumeration attempts, we reset and try to enumerate again.
2605:                  Otherwise, we go to the holding state.
2606:              
2607:                Precondition:
2608:                  usbHostState != STATE_RUNNING
2609:              
2610:                Parameters:
2611:                  None - None
2612:              
2613:                Returns:
2614:                  None
2615:              
2616:                Remarks:
2617:                  None
2618:               ***************************************************************************/
2619:              
2620:              void _USB_CheckCommandAndEnumerationAttempts(void) {
2621:              #ifdef DEBUG_MODE
2622:                  UART2PutChar('=');
2623:              #endif
2624:              
2625:                  // Clear the error and stall flags.  A stall here does not require
2626:                  // host intervention to clear.
2627:                  pCurrentEndpoint->status.bfError = 0;
003492  807631     MOV pCurrentEndpoint, W1
003494  904021     MOV.B [W1+2], W0
003496  A16400     BCLR.B W0, #6
003498  9840A0     MOV.B W0, [W1+2]
2628:                  pCurrentEndpoint->status.bfStalled = 0;
00349A  807631     MOV pCurrentEndpoint, W1
00349C  904021     MOV.B [W1+2], W0
00349E  A15400     BCLR.B W0, #5
0034A0  9840A0     MOV.B W0, [W1+2]
2629:              
2630:                  numCommandTries--;
0034A2  ED4EC1     DEC.B numCommandTries, WREG
0034A4  B7EEC1     MOV.B WREG, numCommandTries
2631:                  if (numCommandTries != 0) {
0034A6  320003     BRA Z, 0x34AE
2632:                      // We still have retries left on this command.  Try again.
2633:                      usbHostState &= ~SUBSUBSTATE_MASK;
0034A8  2FFF00     MOV #0xFFF0, W0
0034AA  B62EC8     AND usbHostState
0034AC  37000A     BRA 0x34C2
2634:                  } else {
2635:                      // This command has timed out.
2636:                      // We are enumerating.  See if we can try to enumerate again.
2637:                      numEnumerationTries--;
0034AE  ED4EC2     DEC.B numEnumerationTries, WREG
0034B0  B7EEC2     MOV.B WREG, numEnumerationTries
2638:                      if (numEnumerationTries != 0) {
0034B2  320003     BRA Z, 0x34BA
2639:                          // We still have retries left to try to enumerate.  Reset and try again.
2640:                          usbHostState = STATE_ATTACHED | SUBSTATE_RESET_DEVICE;
0034B4  201100     MOV #0x110, W0
0034B6  887640     MOV W0, usbHostState
0034B8  370004     BRA 0x34C2
2641:                      } else {
2642:                          // Give up.  The device is not responding properly.
2643:                          _USB_SetErrorCode(USB_CANNOT_ENUMERATE);
0034BA  B3C070     MOV.B #0x7, W0
0034BC  B7EED4     MOV.B WREG, 0xED4
2644:                          _USB_SetHoldState();
0034BE  205000     MOV #0x500, W0
0034C0  887640     MOV W0, usbHostState
2645:                      }
2646:                  }
2647:              }
0034C2  060000     RETURN
2648:              
2649:              /****************************************************************************
2650:                Function:
2651:                  BOOL _USB_FindClassDriver( BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv )
2652:              
2653:                Summary:
2654:              
2655:              
2656:                Description:
2657:                  This routine scans the TPL table looking for the entry with
2658:                              the given class, subclass, and protocol values.
2659:              
2660:                Precondition:
2661:                  usbTPL must be define by the application.
2662:              
2663:                Parameters:
2664:                  bClass      - The class of the desired entry
2665:                  bSubClass   - The subclass of the desired entry
2666:                  bProtocol   - The protocol of the desired entry
2667:                  pbClientDrv - Returned index to the client driver in the client driver
2668:                                  table.
2669:              
2670:                Return Values:
2671:                  TRUE    - A class driver was found.
2672:                  FALSE   - A class driver was not found.
2673:              
2674:                Remarks:
2675:                  None
2676:               ***************************************************************************/
2677:              
2678:              BOOL _USB_FindClassDriver(BYTE bClass, BYTE bSubClass, BYTE bProtocol, BYTE *pbClientDrv) {
0034C4  4787EE     ADD W15, #0xE, W15
0034C6  BE9F88     MOV.D W8, [W15++]
0034C8  BE9F8A     MOV.D W10, [W15++]
0034CA  BE9F8C     MOV.D W12, [W15++]
0034CC  781F8E     MOV W14, [W15++]
0034CE  784600     MOV.B W0, W12
0034D0  784701     MOV.B W1, W14
0034D2  9FEFE2     MOV.B W2, [W15-18]
0034D4  9FBF83     MOV W3, [W15-16]
2679:                  USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA eventData;
2680:                  int i;
2681:                  USB_DEVICE_DESCRIPTOR *pDesc = (USB_DEVICE_DESCRIPTOR *) pDeviceDescriptor;
0034D6  8078ED     MOV 0xF1C, W13
0034D8  EB0400     CLR W8
0034DA  20E169     MOV #0xE16, W9
0034DC  20E14B     MOV #0xE14, W11
2682:              
2683:                  i = 0;
2684:                  while (i < NUM_TPL_ENTRIES) {
00353A  540FE6     SUB W8, #0x6, [W15]
00353C  3AFFD0     BRA NZ, 0x34DE
00353E  EB0000     CLR W0
2685:                      if ((usbTPL[i].flags.bfIsClassDriver == 1) &&
0034DE  DD4543     SL W8, #3, W10
0034E0  450066     ADD W10, #0x6, W0
0034E2  7D8060     MOV [W0+W11], W0
0034E4  A31800     BTST.Z W0, #1
0034E6  320027     BRA Z, 0x3536
0034E8  97F869     MOV.B [W9-2], W0
0034EA  504F8C     SUB.B W0, W12, [W15]
0034EC  3A0024     BRA NZ, 0x3536
0034EE  97F879     MOV.B [W9-1], W0
0034F0  504F8E     SUB.B W0, W14, [W15]
0034F2  3A0021     BRA NZ, 0x3536
0034F4  97E86F     MOV.B [W15-18], W0
0034F6  104F99     SUBR.B W0, [W9], [W15]
0034F8  3A001E     BRA NZ, 0x3536
2686:                              (usbTPL[i].device.bClass == bClass) &&
2687:                              (usbTPL[i].device.bSubClass == bSubClass) &&
2688:                              (usbTPL[i].device.bProtocol == bProtocol)) {
2689:                          // Make sure the application layer does not have a problem with the selection.
2690:                          // If the application layer returns FALSE, which it should if the event is not
2691:                          // defined, then accept the selection.
2692:                          eventData.idVendor = pDesc->idVendor;
0034FA  90488D     MOV.B [W13+8], W1
0034FC  FB8081     ZE W1, W1
0034FE  90481D     MOV.B [W13+9], W0
003500  DD0048     SL W0, #8, W0
003502  700081     IOR W0, W1, W1
003504  9FB7B1     MOV W1, [W15-26]
2693:                          eventData.idProduct = pDesc->idProduct;
003506  9048AD     MOV.B [W13+10], W1
003508  FB8081     ZE W1, W1
00350A  90483D     MOV.B [W13+11], W0
00350C  DD0048     SL W0, #8, W0
00350E  700001     IOR W0, W1, W0
003510  9FB7C0     MOV W0, [W15-24]
2694:                          eventData.bDeviceClass = bClass;
003512  9FEFAC     MOV.B W12, [W15-22]
2695:                          eventData.bDeviceSubClass = bSubClass;
003514  9FEFBE     MOV.B W14, [W15-21]
2696:                          eventData.bDeviceProtocol = bProtocol;
003516  97E8EF     MOV.B [W15-18], W1
003518  9FEFC1     MOV.B W1, [W15-20]
2697:              
2698:                          if (!USB_HOST_APP_EVENT_HANDLER(USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
00351A  200084     MOV #0x8, W4
00351C  200005     MOV #0x0, W5
00351E  57817A     SUB W15, #0x1A, W2
003520  200791     MOV #0x79, W1
003522  EBC000     SETM.B W0
003524  07232C     RCALL USB_ApplicationEventHandler
003526  E00000     CP0 W0
003528  3A0006     BRA NZ, 0x3536
2699:                                  &eventData, sizeof (USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA))) {
2700:                              *pbClientDrv = usbTPL[i].ClientDriver;
00352A  45800A     ADD W11, W10, W0
00352C  904050     MOV.B [W0+5], W0
00352E  97B88F     MOV [W15-16], W1
003530  784880     MOV.B W0, [W1]
003532  200010     MOV #0x1, W0
003534  370005     BRA 0x3540
2701:              #ifdef DEBUG_MODE
2702:                              UART2PrintString("HOST: Client driver found.\r\n");
2703:              #endif
2704:                              return TRUE;
2705:                          }
2706:                      }
2707:                      i++;
003536  E80408     INC W8, W8
003538  4484E8     ADD W9, #0x8, W9
2708:                  }
2709:              
2710:              #ifdef DEBUG_MODE
2711:                  UART2PrintString("HOST: Client driver NOT found.\r\n");
2712:              #endif
2713:                  return FALSE;
2714:              
2715:              } // _USB_FindClassDriver
003540  78074F     MOV [--W15], W14
003542  BE064F     MOV.D [--W15], W12
003544  BE054F     MOV.D [--W15], W10
003546  BE044F     MOV.D [--W15], W8
003548  B100EF     SUB #0xE, W15
00354A  060000     RETURN
2716:              
2717:              /****************************************************************************
2718:                Function:
2719:                  BOOL _USB_FindDeviceLevelClientDriver( void )
2720:              
2721:                Description:
2722:                  This function searches the TPL to try to find a device-level client
2723:                  driver.
2724:              
2725:                Precondition:
2726:               * usbHostState == STATE_ATTACHED|SUBSTATE_VALIDATE_VID_PID
2727:               * usbTPL must be define by the application.
2728:              
2729:                Parameters:
2730:                  None - None
2731:              
2732:                Return Values:
2733:                  TRUE    - Client driver found
2734:                  FALSE   - Client driver not found
2735:              
2736:                Remarks:
2737:                  If successful, this function preserves the client's index from the client
2738:                  driver table and sets flags indicating that the device should use a
2739:                  single client driver.
2740:               ***************************************************************************/
2741:              
2742:              BOOL _USB_FindDeviceLevelClientDriver(void) {
00354C  FA0008     LNK #0x8
00354E  BE9F88     MOV.D W8, [W15++]
003550  BE9F8A     MOV.D W10, [W15++]
003552  781F8C     MOV W12, [W15++]
2743:                  WORD i;
2744:                  USB_DEVICE_DESCRIPTOR *pDesc = (USB_DEVICE_DESCRIPTOR *) pDeviceDescriptor;
003554  8078E8     MOV 0xF1C, W8
2745:              
2746:                  // Scan TPL
2747:                  i = 0;
2748:                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 0;
003556  A9CEDE     BCLR 0xEDE, #6
003558  EB0500     CLR W10
00355A  20E169     MOV #0xE16, W9
00355C  20E14B     MOV #0xE14, W11
00355E  78060B     MOV W11, W12
2749:                  while (i < NUM_TPL_ENTRIES) {
003610  550FE6     SUB W10, #0x6, [W15]
003612  3AFFA6     BRA NZ, 0x3560
003614  EB0080     CLR W1
2750:                      if (usbTPL[i].flags.bfIsClassDriver) {
003560  DD5043     SL W10, #3, W0
003562  400066     ADD W0, #0x6, W0
003564  7E0060     MOV [W0+W12], W0
003566  A31800     BTST.Z W0, #1
003568  32000C     BRA Z, 0x3582
2751:                          // Check for a device-class client driver
2752:                          if ((usbTPL[i].device.bClass == pDesc->bDeviceClass) &&
00356A  904048     MOV.B [W8+4], W0
00356C  104F9B     SUBR.B W0, [W11], [W15]
00356E  3A0039     BRA NZ, 0x35E2
003570  97F8F9     MOV.B [W9-1], W1
003572  904058     MOV.B [W8+5], W0
003574  50CF80     SUB.B W1, W0, [W15]
003576  3A0035     BRA NZ, 0x35E2
003578  904068     MOV.B [W8+6], W0
00357A  104F99     SUBR.B W0, [W9], [W15]
00357C  3A0032     BRA NZ, 0x35E2
2753:                                  (usbTPL[i].device.bSubClass == pDesc->bDeviceSubClass) &&
2754:                                  (usbTPL[i].device.bProtocol == pDesc->bDeviceProtocol)) {
2755:              #ifdef DEBUG_MODE
2756:                              UART2PrintString("HOST: Device validated by class\r\n");
2757:              #endif
2758:                              usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
00357E  A8CEDE     BSET 0xEDE, #6
003580  370030     BRA 0x35E2
2759:                          }
2760:                      } else {
2761:                          // Check for a device-specific client driver by VID & PID
2762:                          if ((usbTPL[i].device.idVendor == pDesc->idVendor) &&
003582  78019B     MOV [W11], W3
003584  904888     MOV.B [W8+8], W1
003586  FB8081     ZE W1, W1
003588  904818     MOV.B [W8+9], W0
00358A  DD0048     SL W0, #8, W0
00358C  700001     IOR W0, W1, W0
00358E  518F80     SUB W3, W0, [W15]
003590  3A0008     BRA NZ, 0x35A2
003592  9048A8     MOV.B [W8+10], W1
003594  FB8081     ZE W1, W1
003596  904838     MOV.B [W8+11], W0
003598  DD0048     SL W0, #8, W0
00359A  700001     IOR W0, W1, W0
00359C  100F99     SUBR W0, [W9], [W15]
00359E  3A0001     BRA NZ, 0x35A2
2763:                                  (usbTPL[i].device.idProduct == pDesc->idProduct)) {
2764:              #ifdef DEBUG_MODE
2765:                              UART2PrintString("HOST: Device validated by VID/PID\r\n");
2766:              #endif
2767:                              usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
0035A0  A8CEDE     BSET 0xEDE, #6
2768:                          }
2769:              
2770:              #ifdef ALLOW_GLOBAL_VID_AND_PID
2771:                          if ((usbTPL[i].device.idVendor == 0xFFFF) &&
0035A2  418FE1     ADD W3, #0x1, [W15]
0035A4  3A001E     BRA NZ, 0x35E2
0035A6  EB8000     SETM W0
0035A8  100F99     SUBR W0, [W9], [W15]
0035AA  3A001B     BRA NZ, 0x35E2
2772:                                  (usbTPL[i].device.idProduct == 0xFFFF)) {
2773:                              USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA eventData;
2774:              
2775:                              // Make sure the application layer does not have a problem with the selection.
2776:                              // If the application layer returns FALSE, which it should if the event is not
2777:                              // defined, then accept the selection.
2778:                              eventData.idVendor = pDesc->idVendor;
0035AC  904888     MOV.B [W8+8], W1
0035AE  FB8081     ZE W1, W1
0035B0  904818     MOV.B [W8+9], W0
0035B2  DD0048     SL W0, #8, W0
0035B4  700081     IOR W0, W1, W1
0035B6  9FB7F1     MOV W1, [W15-18]
2779:                              eventData.idProduct = pDesc->idProduct;
0035B8  9048A8     MOV.B [W8+10], W1
0035BA  FB8081     ZE W1, W1
0035BC  904838     MOV.B [W8+11], W0
0035BE  DD0048     SL W0, #8, W0
0035C0  700001     IOR W0, W1, W0
0035C2  9FBF80     MOV W0, [W15-16]
2780:                              eventData.bDeviceClass = usbTPL[i].device.bClass;
0035C4  78401B     MOV.B [W11], W0
0035C6  9FF7A0     MOV.B W0, [W15-14]
2781:                              eventData.bDeviceSubClass = usbTPL[i].device.bSubClass;
0035C8  97F879     MOV.B [W9-1], W0
0035CA  9FF7B0     MOV.B W0, [W15-13]
2782:                              eventData.bDeviceProtocol = usbTPL[i].device.bProtocol;
0035CC  784019     MOV.B [W9], W0
0035CE  9FF7C0     MOV.B W0, [W15-12]
2783:              
2784:                              if (!USB_HOST_APP_EVENT_HANDLER(USB_ROOT_HUB, EVENT_OVERRIDE_CLIENT_DRIVER_SELECTION,
0035D0  200084     MOV #0x8, W4
0035D2  200005     MOV #0x0, W5
0035D4  578172     SUB W15, #0x12, W2
0035D6  200791     MOV #0x79, W1
0035D8  784003     MOV.B W3, W0
0035DA  0722D1     RCALL USB_ApplicationEventHandler
0035DC  E00000     CP0 W0
0035DE  3A0001     BRA NZ, 0x35E2
2785:                                      &eventData, sizeof (USB_OVERRIDE_CLIENT_DRIVER_EVENT_DATA))) {
2786:              #ifdef DEBUG_MODE
2787:                                  UART2PrintString("HOST: Device validated by VID/PID\r\n");
2788:              #endif
2789:                                  usbDeviceInfo.flags.bfUseDeviceClientDriver = 1;
0035E0  A8CEDE     BSET 0xEDE, #6
2790:                              }
2791:                          }
2792:              #endif
2793:                      }
2794:              
2795:                      if (usbDeviceInfo.flags.bfUseDeviceClientDriver) {
0035E2  BFCEDE     MOV.B 0xEDE, WREG
0035E4  A36800     BTST.Z W0, #6
0035E6  320011     BRA Z, 0x360A
2796:                          // Save client driver info
2797:                          usbDeviceInfo.deviceClientDriver = usbTPL[i].ClientDriver;
0035E8  DD5143     SL W10, #3, W2
0035EA  460082     ADD W12, W2, W1
0035EC  904051     MOV.B [W1+5], W0
0035EE  B7EED5     MOV.B WREG, 0xED5
2798:              
2799:                          // Select configuration if it is given in the TPL
2800:                          if (usbTPL[i].flags.bfSetConfiguration) {
0035F0  410066     ADD W2, #0x6, W0
0035F2  7E0060     MOV [W0+W12], W0
0035F4  200011     MOV #0x1, W1
0035F6  A32800     BTST.Z W0, #2
0035F8  32000E     BRA Z, 0x3616
2801:                              usbDeviceInfo.currentConfiguration = usbTPL[i].bConfiguration;
0035FA  DD5043     SL W10, #3, W0
0035FC  400064     ADD W0, #0x4, W0
0035FE  781F80     MOV W0, [W15++]
003600  7E4060     MOV.B [W0+W12], W0
003602  B7EED0     MOV.B WREG, 0xED0
003604  78004F     MOV [--W15], W0
003606  200011     MOV #0x1, W1
003608  370006     BRA 0x3616
2802:                          }
2803:              
2804:                          return TRUE;
2805:                      }
2806:              
2807:                      i++;
00360A  E8050A     INC W10, W10
00360C  4484E8     ADD W9, #0x8, W9
00360E  4585E8     ADD W11, #0x8, W11
2808:                  }
2809:              
2810:              #ifdef DEBUG_MODE
2811:                  UART2PrintString("HOST: Device not yet validated\r\n");
2812:              #endif
2813:              
2814:                  return FALSE;
2815:              }
003616  780001     MOV W1, W0
003618  78064F     MOV [--W15], W12
00361A  BE054F     MOV.D [--W15], W10
00361C  BE044F     MOV.D [--W15], W8
00361E  FA8000     ULNK
003620  060000     RETURN
2816:              
2817:              /****************************************************************************
2818:                Function:
2819:                  USB_ENDPOINT_INFO * _USB_FindEndpoint( BYTE endpoint )
2820:              
2821:                Description:
2822:                  This function searches the list of interfaces to try to find the specified
2823:                  endpoint.
2824:              
2825:                Precondition:
2826:                  None
2827:              
2828:                Parameters:
2829:                  BYTE endpoint   - The endpoint to find.
2830:              
2831:                Returns:
2832:                  Returns a pointer to the USB_ENDPOINT_INFO structure for the endpoint.
2833:              
2834:                Remarks:
2835:                  None
2836:               ***************************************************************************/
2837:              
2838:              USB_ENDPOINT_INFO * _USB_FindEndpoint(BYTE endpoint) {
003622  784100     MOV.B W0, W2
2839:                  USB_ENDPOINT_INFO *pEndpoint;
2840:                  USB_INTERFACE_INFO *pInterface;
2841:              
2842:                  if (endpoint == 0) {
003624  E00400     CP0.B W0
003626  3A0002     BRA NZ, 0x362C
2843:                      return usbDeviceInfo.pEndpoint0;
003628  8076E1     MOV 0xEDC, W1
00362A  370018     BRA 0x365C
2844:                  }
2845:              
2846:                  pInterface = usbDeviceInfo.pInterfaceList;
00362C  8076D3     MOV 0xEDA, W3
2847:                  while (pInterface) {
00362E  E00003     CP0 W3
003630  320010     BRA Z, 0x3652
00364E  E00003     CP0 W3
003650  3AFFF0     BRA NZ, 0x3632
003652  EB0080     CLR W1
003654  370003     BRA 0x365C
2848:                      // Look for the endpoint in the currently active setting.
2849:                      if (pInterface->pCurrentSetting) {
003632  900023     MOV [W3+4], W0
003634  E00000     CP0 W0
003636  32000A     BRA Z, 0x364C
2850:                          pEndpoint = pInterface->pCurrentSetting->pEndpointList;
003638  9000A0     MOV [W0+4], W1
2851:                          while (pEndpoint) {
00363A  E00001     CP0 W1
00363C  3A000C     BRA NZ, 0x3656
00363E  370006     BRA 0x364C
003648  E00001     CP0 W1
00364A  3AFFFA     BRA NZ, 0x3640
2852:                              if (pEndpoint->bEndpointAddress == endpoint) {
003640  905821     MOV.B [W1+26], W0
003642  514F80     SUB.B W2, W0, [W15]
003644  32000B     BRA Z, 0x365C
003656  905821     MOV.B [W1+26], W0
003658  514F80     SUB.B W2, W0, [W15]
00365A  3AFFF5     BRA NZ, 0x3646
2853:                                  // We have found the endpoint.
2854:                                  return pEndpoint;
2855:                              }
2856:                              pEndpoint = pEndpoint->next;
003646  780091     MOV [W1], W1
2857:                          }
2858:                      }
2859:              
2860:                      // Go to the next interface.
2861:                      pInterface = pInterface->next;
00364C  780193     MOV [W3], W3
2862:                  }
2863:              
2864:                  return NULL;
2865:              }
00365C  780001     MOV W1, W0
00365E  060000     RETURN
2866:              
2867:              
2868:              /****************************************************************************
2869:                Function:
2870:                  USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
2871:              
2872:                Description:
2873:                  This routine scans the interface linked list and returns a pointer to the
2874:                  node identified by the interface and alternate setting.
2875:              
2876:                Precondition:
2877:                  None
2878:              
2879:                Parameters:
2880:                  bInterface  - Interface number
2881:                  bAltSetting - Interface alternate setting number
2882:              
2883:                Returns:
2884:                  USB_INTERFACE_INFO *  - Pointer to the interface linked list node.
2885:              
2886:                Remarks:
2887:                  None
2888:               ***************************************************************************/
2889:              /*
2890:              USB_INTERFACE_INFO * _USB_FindInterface ( BYTE bInterface, BYTE bAltSetting )
2891:              {
2892:                  USB_INTERFACE_INFO *pCurIntf = usbDeviceInfo.pInterfaceList;
2893:              
2894:                  while (pCurIntf)
2895:                  {
2896:                      if (pCurIntf->interface           == bInterface &&
2897:                          pCurIntf->interfaceAltSetting == bAltSetting  )
2898:                      {
2899:                          return pCurIntf;
2900:                      }
2901:                  }
2902:              
2903:                  return NULL;
2904:              
2905:              } // _USB_FindInterface
2906:               */
2907:              
2908:              /****************************************************************************
2909:                Function:
2910:                  void _USB_FindNextToken( void )
2911:              
2912:                Description:
2913:                  This function determines the next token to send of all current pending
2914:                  transfers.
2915:              
2916:                Precondition:
2917:                  None
2918:              
2919:                Parameters:
2920:                  None - None
2921:              
2922:                Return Values:
2923:                  TRUE    - A token was sent
2924:                  FALSE   - No token was found to send, so the routine can be called again.
2925:              
2926:                Remarks:
2927:                  This routine is only called from an interrupt handler, either SOFIF or
2928:                  TRNIF.
2929:               ***************************************************************************/
2930:              
2931:              void _USB_FindNextToken(void) {
003660  BE9F88     MOV.D W8, [W15++]
003662  BE9F8A     MOV.D W10, [W15++]
2932:                  BOOL illegalState = FALSE;
2933:              
2934:                  // If the device is suspended or resuming, do not send any tokens.  We will
2935:                  // send the next token on an SOF interrupt after the resume recovery time
2936:                  // has expired.
2937:                  if ((usbHostState & (SUBSTATE_MASK | SUBSUBSTATE_MASK)) == (STATE_RUNNING | SUBSTATE_SUSPEND_AND_RESUME)) {
003664  807640     MOV usbHostState, W0
2938:                      return;
2939:                  }
2940:              
2941:                  // If we are currently sending a token, we cannot do anything.  We will come
2942:                  // back in here when we get either the Token Done or the Start of Frame interrupt.
2943:                  if (usbBusInfo.flags.bfTokenAlreadyWritten) //(U1CONbits.TOKBUSY)
003666  BFCECA     MOV.B usbBusInfo, WREG
003668  A34800     BTST.Z W0, #4
00366A  3A0399     BRA NZ, 0x3D9E
2944:                  {
2945:                      return;
2946:                  }
2947:              
2948:                  // We will handle control transfers first.  We only allow one control
2949:                  // transfer per frame.
2950:                  if (!usbBusInfo.flags.bfControlTransfersDone) {
00366C  BFCECA     MOV.B usbBusInfo, WREG
00366E  EB0580     CLR W11
003670  A30800     BTST.Z W0, #0
003672  3A01AF     BRA NZ, 0x39D2
2951:                      // Look for any control transfers.
2952:                      if (_USB_FindServiceEndpoint(USB_TRANSFER_TYPE_CONTROL)) {
003674  EB4000     CLR.B W0
003676  070396     RCALL _USB_FindServiceEndpoint
003678  E00000     CP0 W0
00367A  3A0002     BRA NZ, 0x3680
00367C  780580     MOV W0, W11
00367E  3701A8     BRA 0x39D0
2953:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK) {
003680  807632     MOV pCurrentEndpoint, W2
003682  905802     MOV.B [W2+24], W0
003684  780080     MOV W0, W1
003686  B20F01     AND #0xF0, W1
003688  200200     MOV #0x20, W0
00368A  508F80     SUB W1, W0, [W15]
00368C  320088     BRA Z, 0x379E
00368E  400070     ADD W0, #0x10, W0
003690  508F80     SUB W1, W0, [W15]
003692  320112     BRA Z, 0x38B8
003694  508FF0     SUB W1, #0x10, [W15]
003696  3A037B     BRA NZ, 0x3D8E
2954:                              case TSTATE_CONTROL_NO_DATA:
2955:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
003698  905802     MOV.B [W2+24], W0
00369A  60006F     AND W0, #0xF, W0
00369C  500FE1     SUB W0, #0x1, [W15]
00369E  320014     BRA Z, 0x36C8
0036A0  3C0003     BRA GT, 0x36A8
0036A2  E00000     CP0 W0
0036A4  320006     BRA Z, 0x36B2
0036A6  370373     BRA 0x3D8E
0036A8  500FE2     SUB W0, #0x2, [W15]
0036AA  32001E     BRA Z, 0x36E8
0036AC  500FEF     SUB W0, #0xF, [W15]
0036AE  3A036F     BRA NZ, 0x3D8E
0036B0  370049     BRA 0x3744
2956:                                      case TSUBSTATE_CONTROL_NO_DATA_SETUP:
2957:                                          _USB_SetDATA01(DTS_DATA0);
0036B2  904032     MOV.B [W2+3], W0
0036B4  A13400     BCLR.B W0, #3
0036B6  984130     MOV.B W0, [W2+3]
2958:                                          _USB_SetBDT(USB_TOKEN_SETUP);
0036B8  B3C0D0     MOV.B #0xD, W0
0036BA  070695     RCALL _USB_SetBDT
2959:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP);
0036BC  807630     MOV pCurrentEndpoint, W0
0036BE  905820     MOV.B [W0+26], W0
0036C0  B3C0D1     MOV.B #0xD, W1
0036C2  070674     RCALL _USB_SendToken
2960:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
2961:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0036C4  A80ECA     BSET usbBusInfo, #0
0036C6  37036B     BRA 0x3D9E
2962:              #endif
2963:                                          return;
2964:                                          break;
2965:              
2966:                                      case TSUBSTATE_CONTROL_NO_DATA_ACK:
2967:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
0036C8  900802     MOV [W2+16], W0
0036CA  900892     MOV [W2+18], W1
0036CC  980150     MOV W0, [W2+10]
0036CE  980161     MOV W1, [W2+12]
2968:                                          _USB_SetDATA01(DTS_DATA1);
0036D0  807631     MOV pCurrentEndpoint, W1
0036D2  904031     MOV.B [W1+3], W0
0036D4  A03400     BSET.B W0, #3
0036D6  9840B0     MOV.B W0, [W1+3]
2969:                                          _USB_SetBDT(USB_TOKEN_IN);
0036D8  B3C090     MOV.B #0x9, W0
0036DA  070685     RCALL _USB_SetBDT
2970:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
0036DC  807630     MOV pCurrentEndpoint, W0
0036DE  905820     MOV.B [W0+26], W0
0036E0  B3C091     MOV.B #0x9, W1
0036E2  070664     RCALL _USB_SendToken
2971:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
2972:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0036E4  A80ECA     BSET usbBusInfo, #0
0036E6  37035B     BRA 0x3D9E
2973:              #endif
2974:                                          return;
2975:                                          break;
2976:              
2977:                                      case TSUBSTATE_CONTROL_NO_DATA_COMPLETE:
2978:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
0036E8  EB4000     CLR.B W0
0036EA  985900     MOV.B W0, [W2+24]
2979:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
0036EC  807631     MOV pCurrentEndpoint, W1
0036EE  904031     MOV.B [W1+3], W0
0036F0  A01400     BSET.B W0, #1
0036F2  9840B0     MOV.B W0, [W1+3]
2980:              #if defined( USB_ENABLE_TRANSFER_EVENT )
2981:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
0036F4  807720     MOV 0xEE4, W0
0036F6  500FE3     SUB W0, #0x3, [W15]
0036F8  3C0020     BRA GT, 0x373A
2982:                                              USB_EVENT_DATA *data;
2983:              
2984:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
0036FA  E80000     INC W0, W0
0036FC  887720     MOV W0, 0xEE4
0036FE  807700     MOV usbEventQueue, W0
003700  500FE2     SUB W0, #0x2, [W15]
003702  3C0003     BRA GT, 0x370A
003704  E80000     INC W0, W0
003706  887700     MOV W0, usbEventQueue
003708  370001     BRA 0x370C
00370A  EF2EE0     CLR usbEventQueue
00370C  807700     MOV usbEventQueue, W0
00370E  B9006C     MUL.SU W0, #12, W0
003710  20EE62     MOV #0xEE6, W2
003712  410100     ADD W2, W0, W2
2985:                                              data->event = EVENT_TRANSFER;
003714  200720     MOV #0x72, W0
003716  780900     MOV W0, [W2]
2986:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003718  807631     MOV pCurrentEndpoint, W1
00371A  900A01     MOV [W1+16], W4
00371C  900A91     MOV [W1+18], W5
00371E  980114     MOV W4, [W2+2]
003720  980125     MOV W5, [W2+4]
2987:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003722  900AB1     MOV [W1+22], W5
003724  980135     MOV W5, [W2+6]
2988:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003726  EB4000     CLR.B W0
003728  984910     MOV.B W0, [W2+9]
2989:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
00372A  905821     MOV.B [W1+26], W0
00372C  984900     MOV.B W0, [W2+8]
2990:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
00372E  9059B1     MOV.B [W1+27], W3
003730  984923     MOV.B W3, [W2+10]
2991:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003732  905891     MOV.B [W1+25], W1
003734  984931     MOV.B W1, [W2+11]
003736  EB0580     CLR W11
003738  37014B     BRA 0x39D0
2992:                                          } else {
2993:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
00373A  B3C081     MOV.B #0x8, W1
00373C  807630     MOV pCurrentEndpoint, W0
00373E  985831     MOV.B W1, [W0+27]
003740  EB0580     CLR W11
003742  370146     BRA 0x39D0
2994:                                          }
2995:              #endif
2996:                                          break;
2997:              
2998:                                      case TSUBSTATE_ERROR:
2999:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003744  EB4000     CLR.B W0
003746  985900     MOV.B W0, [W2+24]
3000:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003748  807631     MOV pCurrentEndpoint, W1
00374A  904031     MOV.B [W1+3], W0
00374C  A01400     BSET.B W0, #1
00374E  9840B0     MOV.B W0, [W1+3]
3001:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3002:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003750  807720     MOV 0xEE4, W0
003752  500FE3     SUB W0, #0x3, [W15]
003754  3C001F     BRA GT, 0x3794
3003:                                              USB_EVENT_DATA *data;
3004:              
3005:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003756  E80000     INC W0, W0
003758  887720     MOV W0, 0xEE4
00375A  807700     MOV usbEventQueue, W0
00375C  500FE2     SUB W0, #0x2, [W15]
00375E  3C0003     BRA GT, 0x3766
003760  E80000     INC W0, W0
003762  887700     MOV W0, usbEventQueue
003764  370001     BRA 0x3768
003766  EF2EE0     CLR usbEventQueue
003768  807700     MOV usbEventQueue, W0
00376A  B9006C     MUL.SU W0, #12, W0
00376C  20EE62     MOV #0xEE6, W2
00376E  410100     ADD W2, W0, W2
3006:                                              data->event = EVENT_BUS_ERROR;
003770  27FFF0     MOV #0x7FFF, W0
003772  780900     MOV W0, [W2]
3007:                                              data->TransferData.dataCount = 0;
003774  B80060     MUL.UU W0, #0, W0
003776  980110     MOV W0, [W2+2]
003778  980121     MOV W1, [W2+4]
3008:                                              data->TransferData.pUserData = NULL;
00377A  EB0080     CLR W1
00377C  980131     MOV W1, [W2+6]
3009:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
00377E  807630     MOV pCurrentEndpoint, W0
003780  905A40     MOV.B [W0+28], W4
003782  984914     MOV.B W4, [W2+9]
3010:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003784  905AA0     MOV.B [W0+26], W5
003786  984905     MOV.B W5, [W2+8]
3011:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003788  9059B0     MOV.B [W0+27], W3
00378A  984923     MOV.B W3, [W2+10]
3012:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
00378C  905810     MOV.B [W0+25], W0
00378E  984930     MOV.B W0, [W2+11]
003790  780581     MOV W1, W11
003792  37011E     BRA 0x39D0
3013:                                          } else {
3014:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003794  B3C081     MOV.B #0x8, W1
003796  807630     MOV pCurrentEndpoint, W0
003798  985831     MOV.B W1, [W0+27]
00379A  EB0580     CLR W11
00379C  370119     BRA 0x39D0
3015:                                          }
3016:              #endif
3017:                                          break;
3018:              
3019:                                      default:
3020:                                          illegalState = TRUE;
3021:                                          break;
3022:                                  }
3023:                                  break;
3024:              
3025:                              case TSTATE_CONTROL_READ:
3026:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
00379E  905802     MOV.B [W2+24], W0
0037A0  60006F     AND W0, #0xF, W0
0037A2  500FE2     SUB W0, #0x2, [W15]
0037A4  32001E     BRA Z, 0x37E2
0037A6  3C0005     BRA GT, 0x37B2
0037A8  E00000     CP0 W0
0037AA  320008     BRA Z, 0x37BC
0037AC  500FE1     SUB W0, #0x1, [W15]
0037AE  3A02EF     BRA NZ, 0x3D8E
0037B0  370010     BRA 0x37D2
0037B2  500FE3     SUB W0, #0x3, [W15]
0037B4  320026     BRA Z, 0x3802
0037B6  500FEF     SUB W0, #0xF, [W15]
0037B8  3A02EA     BRA NZ, 0x3D8E
0037BA  370051     BRA 0x385E
3027:                                      case TSUBSTATE_CONTROL_READ_SETUP:
3028:                                          _USB_SetDATA01(DTS_DATA0);
0037BC  904032     MOV.B [W2+3], W0
0037BE  A13400     BCLR.B W0, #3
0037C0  984130     MOV.B W0, [W2+3]
3029:                                          _USB_SetBDT(USB_TOKEN_SETUP);
0037C2  B3C0D0     MOV.B #0xD, W0
0037C4  070610     RCALL _USB_SetBDT
3030:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP);
0037C6  807630     MOV pCurrentEndpoint, W0
0037C8  905820     MOV.B [W0+26], W0
0037CA  B3C0D1     MOV.B #0xD, W1
0037CC  0705EF     RCALL _USB_SendToken
3031:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3032:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0037CE  A80ECA     BSET usbBusInfo, #0
0037D0  3702E6     BRA 0x3D9E
3033:              #endif
3034:                                          return;
3035:                                          break;
3036:              
3037:                                      case TSUBSTATE_CONTROL_READ_DATA:
3038:                                          _USB_SetBDT(USB_TOKEN_IN);
0037D2  B3C090     MOV.B #0x9, W0
0037D4  070608     RCALL _USB_SetBDT
3039:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
0037D6  807630     MOV pCurrentEndpoint, W0
0037D8  905820     MOV.B [W0+26], W0
0037DA  B3C091     MOV.B #0x9, W1
0037DC  0705E7     RCALL _USB_SendToken
3040:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3041:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0037DE  A80ECA     BSET usbBusInfo, #0
0037E0  3702DE     BRA 0x3D9E
3042:              #endif
3043:                                          return;
3044:                                          break;
3045:              
3046:                                      case TSUBSTATE_CONTROL_READ_ACK:
3047:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
0037E2  900A02     MOV [W2+16], W4
0037E4  900A92     MOV [W2+18], W5
0037E6  980154     MOV W4, [W2+10]
0037E8  980165     MOV W5, [W2+12]
3048:                                          _USB_SetDATA01(DTS_DATA1);
0037EA  807631     MOV pCurrentEndpoint, W1
0037EC  904031     MOV.B [W1+3], W0
0037EE  A03400     BSET.B W0, #3
0037F0  9840B0     MOV.B W0, [W1+3]
3049:                                          _USB_SetBDT(USB_TOKEN_OUT);
0037F2  B3C010     MOV.B #0x1, W0
0037F4  0705F8     RCALL _USB_SetBDT
3050:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT);
0037F6  807630     MOV pCurrentEndpoint, W0
0037F8  905820     MOV.B [W0+26], W0
0037FA  B3C011     MOV.B #0x1, W1
0037FC  0705D7     RCALL _USB_SendToken
3051:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3052:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0037FE  A80ECA     BSET usbBusInfo, #0
003800  3702CE     BRA 0x3D9E
3053:              #endif
3054:                                          return;
3055:                                          break;
3056:              
3057:                                      case TSUBSTATE_CONTROL_READ_COMPLETE:
3058:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003802  EB4000     CLR.B W0
003804  985900     MOV.B W0, [W2+24]
3059:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003806  807631     MOV pCurrentEndpoint, W1
003808  904031     MOV.B [W1+3], W0
00380A  A01400     BSET.B W0, #1
00380C  9840B0     MOV.B W0, [W1+3]
3060:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3061:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
00380E  807720     MOV 0xEE4, W0
003810  500FE3     SUB W0, #0x3, [W15]
003812  3C0020     BRA GT, 0x3854
3062:                                              USB_EVENT_DATA *data;
3063:              
3064:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003814  E80000     INC W0, W0
003816  887720     MOV W0, 0xEE4
003818  807700     MOV usbEventQueue, W0
00381A  500FE2     SUB W0, #0x2, [W15]
00381C  3C0003     BRA GT, 0x3824
00381E  E80000     INC W0, W0
003820  887700     MOV W0, usbEventQueue
003822  370001     BRA 0x3826
003824  EF2EE0     CLR usbEventQueue
003826  807700     MOV usbEventQueue, W0
003828  B9006C     MUL.SU W0, #12, W0
00382A  20EE62     MOV #0xEE6, W2
00382C  410100     ADD W2, W0, W2
3065:                                              data->event = EVENT_TRANSFER;
00382E  200720     MOV #0x72, W0
003830  780900     MOV W0, [W2]
3066:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003832  807631     MOV pCurrentEndpoint, W1
003834  900A01     MOV [W1+16], W4
003836  900A91     MOV [W1+18], W5
003838  980114     MOV W4, [W2+2]
00383A  980125     MOV W5, [W2+4]
3067:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
00383C  900AB1     MOV [W1+22], W5
00383E  980135     MOV W5, [W2+6]
3068:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003840  EB4000     CLR.B W0
003842  984910     MOV.B W0, [W2+9]
3069:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003844  905821     MOV.B [W1+26], W0
003846  984900     MOV.B W0, [W2+8]
3070:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003848  9059B1     MOV.B [W1+27], W3
00384A  984923     MOV.B W3, [W2+10]
3071:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
00384C  905891     MOV.B [W1+25], W1
00384E  984931     MOV.B W1, [W2+11]
003850  EB0580     CLR W11
003852  3700BE     BRA 0x39D0
3072:                                          } else {
3073:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003854  B3C081     MOV.B #0x8, W1
003856  807630     MOV pCurrentEndpoint, W0
003858  985831     MOV.B W1, [W0+27]
00385A  EB0580     CLR W11
00385C  3700B9     BRA 0x39D0
3074:                                          }
3075:              #endif
3076:                                          break;
3077:              
3078:                                      case TSUBSTATE_ERROR:
3079:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
00385E  EB4000     CLR.B W0
003860  985900     MOV.B W0, [W2+24]
3080:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003862  807631     MOV pCurrentEndpoint, W1
003864  904031     MOV.B [W1+3], W0
003866  A01400     BSET.B W0, #1
003868  9840B0     MOV.B W0, [W1+3]
3081:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3082:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
00386A  807720     MOV 0xEE4, W0
00386C  500FE3     SUB W0, #0x3, [W15]
00386E  3C001F     BRA GT, 0x38AE
3083:                                              USB_EVENT_DATA *data;
3084:              
3085:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003870  E80000     INC W0, W0
003872  887720     MOV W0, 0xEE4
003874  807700     MOV usbEventQueue, W0
003876  500FE2     SUB W0, #0x2, [W15]
003878  3C0003     BRA GT, 0x3880
00387A  E80000     INC W0, W0
00387C  887700     MOV W0, usbEventQueue
00387E  370001     BRA 0x3882
003880  EF2EE0     CLR usbEventQueue
003882  807700     MOV usbEventQueue, W0
003884  B9006C     MUL.SU W0, #12, W0
003886  20EE62     MOV #0xEE6, W2
003888  410100     ADD W2, W0, W2
3086:                                              data->event = EVENT_BUS_ERROR;
00388A  27FFF0     MOV #0x7FFF, W0
00388C  780900     MOV W0, [W2]
3087:                                              data->TransferData.dataCount = 0;
00388E  B80060     MUL.UU W0, #0, W0
003890  980110     MOV W0, [W2+2]
003892  980121     MOV W1, [W2+4]
3088:                                              data->TransferData.pUserData = NULL;
003894  EB0080     CLR W1
003896  980131     MOV W1, [W2+6]
3089:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
003898  807630     MOV pCurrentEndpoint, W0
00389A  905A40     MOV.B [W0+28], W4
00389C  984914     MOV.B W4, [W2+9]
3090:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
00389E  905AA0     MOV.B [W0+26], W5
0038A0  984905     MOV.B W5, [W2+8]
3091:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
0038A2  9059B0     MOV.B [W0+27], W3
0038A4  984923     MOV.B W3, [W2+10]
3092:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
0038A6  905810     MOV.B [W0+25], W0
0038A8  984930     MOV.B W0, [W2+11]
0038AA  780581     MOV W1, W11
0038AC  370091     BRA 0x39D0
3093:                                          } else {
3094:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
0038AE  B3C081     MOV.B #0x8, W1
0038B0  807630     MOV pCurrentEndpoint, W0
0038B2  985831     MOV.B W1, [W0+27]
0038B4  EB0580     CLR W11
0038B6  37008C     BRA 0x39D0
3095:                                          }
3096:              #endif
3097:                                          break;
3098:              
3099:                                      default:
3100:                                          illegalState = TRUE;
3101:                                          break;
3102:                                  }
3103:                                  break;
3104:              
3105:                              case TSTATE_CONTROL_WRITE:
3106:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
0038B8  905802     MOV.B [W2+24], W0
0038BA  60006F     AND W0, #0xF, W0
0038BC  500FE2     SUB W0, #0x2, [W15]
0038BE  32001E     BRA Z, 0x38FC
0038C0  3C0005     BRA GT, 0x38CC
0038C2  E00000     CP0 W0
0038C4  320008     BRA Z, 0x38D6
0038C6  500FE1     SUB W0, #0x1, [W15]
0038C8  3A0262     BRA NZ, 0x3D8E
0038CA  370010     BRA 0x38EC
0038CC  500FE3     SUB W0, #0x3, [W15]
0038CE  320026     BRA Z, 0x391C
0038D0  500FEF     SUB W0, #0xF, [W15]
0038D2  3A025D     BRA NZ, 0x3D8E
0038D4  370051     BRA 0x3978
3107:                                      case TSUBSTATE_CONTROL_WRITE_SETUP:
3108:                                          _USB_SetDATA01(DTS_DATA0);
0038D6  904032     MOV.B [W2+3], W0
0038D8  A13400     BCLR.B W0, #3
0038DA  984130     MOV.B W0, [W2+3]
3109:                                          _USB_SetBDT(USB_TOKEN_SETUP);
0038DC  B3C0D0     MOV.B #0xD, W0
0038DE  070583     RCALL _USB_SetBDT
3110:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_SETUP);
0038E0  807630     MOV pCurrentEndpoint, W0
0038E2  905820     MOV.B [W0+26], W0
0038E4  B3C0D1     MOV.B #0xD, W1
0038E6  070562     RCALL _USB_SendToken
3111:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3112:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0038E8  A80ECA     BSET usbBusInfo, #0
0038EA  370259     BRA 0x3D9E
3113:              #endif
3114:                                          return;
3115:                                          break;
3116:              
3117:                                      case TSUBSTATE_CONTROL_WRITE_DATA:
3118:                                          _USB_SetBDT(USB_TOKEN_OUT);
0038EC  B3C010     MOV.B #0x1, W0
0038EE  07057B     RCALL _USB_SetBDT
3119:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT);
0038F0  807630     MOV pCurrentEndpoint, W0
0038F2  905820     MOV.B [W0+26], W0
0038F4  B3C011     MOV.B #0x1, W1
0038F6  07055A     RCALL _USB_SendToken
3120:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3121:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
0038F8  A80ECA     BSET usbBusInfo, #0
0038FA  370251     BRA 0x3D9E
3122:              #endif
3123:                                          return;
3124:                                          break;
3125:              
3126:                                      case TSUBSTATE_CONTROL_WRITE_ACK:
3127:                                          pCurrentEndpoint->dataCountMax = pCurrentEndpoint->dataCount;
0038FC  900A02     MOV [W2+16], W4
0038FE  900A92     MOV [W2+18], W5
003900  980154     MOV W4, [W2+10]
003902  980165     MOV W5, [W2+12]
3128:                                          _USB_SetDATA01(DTS_DATA1);
003904  807631     MOV pCurrentEndpoint, W1
003906  904031     MOV.B [W1+3], W0
003908  A03400     BSET.B W0, #3
00390A  9840B0     MOV.B W0, [W1+3]
3129:                                          _USB_SetBDT(USB_TOKEN_IN);
00390C  B3C090     MOV.B #0x9, W0
00390E  07056B     RCALL _USB_SetBDT
3130:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
003910  807630     MOV pCurrentEndpoint, W0
003912  905820     MOV.B [W0+26], W0
003914  B3C091     MOV.B #0x9, W1
003916  07054A     RCALL _USB_SendToken
3131:              #ifdef ONE_CONTROL_TRANSACTION_PER_FRAME
3132:                                          usbBusInfo.flags.bfControlTransfersDone = 1; // Only one control transfer per frame.
003918  A80ECA     BSET usbBusInfo, #0
00391A  370241     BRA 0x3D9E
3133:              #endif
3134:                                          return;
3135:                                          break;
3136:              
3137:                                      case TSUBSTATE_CONTROL_WRITE_COMPLETE:
3138:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
00391C  EB4000     CLR.B W0
00391E  985900     MOV.B W0, [W2+24]
3139:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003920  807631     MOV pCurrentEndpoint, W1
003922  904031     MOV.B [W1+3], W0
003924  A01400     BSET.B W0, #1
003926  9840B0     MOV.B W0, [W1+3]
3140:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3141:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003928  807720     MOV 0xEE4, W0
00392A  500FE3     SUB W0, #0x3, [W15]
00392C  3C0020     BRA GT, 0x396E
3142:                                              USB_EVENT_DATA *data;
3143:              
3144:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
00392E  E80000     INC W0, W0
003930  887720     MOV W0, 0xEE4
003932  807700     MOV usbEventQueue, W0
003934  500FE2     SUB W0, #0x2, [W15]
003936  3C0003     BRA GT, 0x393E
003938  E80000     INC W0, W0
00393A  887700     MOV W0, usbEventQueue
00393C  370001     BRA 0x3940
00393E  EF2EE0     CLR usbEventQueue
003940  807700     MOV usbEventQueue, W0
003942  B9006C     MUL.SU W0, #12, W0
003944  20EE62     MOV #0xEE6, W2
003946  410100     ADD W2, W0, W2
3145:                                              data->event = EVENT_TRANSFER;
003948  200720     MOV #0x72, W0
00394A  780900     MOV W0, [W2]
3146:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
00394C  807631     MOV pCurrentEndpoint, W1
00394E  900A01     MOV [W1+16], W4
003950  900A91     MOV [W1+18], W5
003952  980114     MOV W4, [W2+2]
003954  980125     MOV W5, [W2+4]
3147:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003956  900AB1     MOV [W1+22], W5
003958  980135     MOV W5, [W2+6]
3148:                                              data->TransferData.bErrorCode = USB_SUCCESS;
00395A  EB4000     CLR.B W0
00395C  984910     MOV.B W0, [W2+9]
3149:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
00395E  905821     MOV.B [W1+26], W0
003960  984900     MOV.B W0, [W2+8]
3150:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003962  9059B1     MOV.B [W1+27], W3
003964  984923     MOV.B W3, [W2+10]
3151:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003966  905891     MOV.B [W1+25], W1
003968  984931     MOV.B W1, [W2+11]
00396A  EB0580     CLR W11
00396C  370031     BRA 0x39D0
3152:                                          } else {
3153:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
00396E  B3C081     MOV.B #0x8, W1
003970  807630     MOV pCurrentEndpoint, W0
003972  985831     MOV.B W1, [W0+27]
003974  EB0580     CLR W11
003976  37002C     BRA 0x39D0
3154:                                          }
3155:              #endif
3156:                                          break;
3157:              
3158:                                      case TSUBSTATE_ERROR:
3159:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003978  EB4000     CLR.B W0
00397A  985900     MOV.B W0, [W2+24]
3160:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
00397C  807631     MOV pCurrentEndpoint, W1
00397E  904031     MOV.B [W1+3], W0
003980  A01400     BSET.B W0, #1
003982  9840B0     MOV.B W0, [W1+3]
3161:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3162:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003984  807720     MOV 0xEE4, W0
003986  500FE3     SUB W0, #0x3, [W15]
003988  3C001F     BRA GT, 0x39C8
3163:                                              USB_EVENT_DATA *data;
3164:              
3165:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
00398A  E80000     INC W0, W0
00398C  887720     MOV W0, 0xEE4
00398E  807700     MOV usbEventQueue, W0
003990  500FE2     SUB W0, #0x2, [W15]
003992  3C0003     BRA GT, 0x399A
003994  E80000     INC W0, W0
003996  887700     MOV W0, usbEventQueue
003998  370001     BRA 0x399C
00399A  EF2EE0     CLR usbEventQueue
00399C  807700     MOV usbEventQueue, W0
00399E  B9006C     MUL.SU W0, #12, W0
0039A0  20EE62     MOV #0xEE6, W2
0039A2  410100     ADD W2, W0, W2
3166:                                              data->event = EVENT_BUS_ERROR;
0039A4  27FFF0     MOV #0x7FFF, W0
0039A6  780900     MOV W0, [W2]
3167:                                              data->TransferData.dataCount = 0;
0039A8  B80060     MUL.UU W0, #0, W0
0039AA  980110     MOV W0, [W2+2]
0039AC  980121     MOV W1, [W2+4]
3168:                                              data->TransferData.pUserData = NULL;
0039AE  EB0080     CLR W1
0039B0  980131     MOV W1, [W2+6]
3169:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
0039B2  807630     MOV pCurrentEndpoint, W0
0039B4  905A40     MOV.B [W0+28], W4
0039B6  984914     MOV.B W4, [W2+9]
3170:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
0039B8  905AA0     MOV.B [W0+26], W5
0039BA  984905     MOV.B W5, [W2+8]
3171:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
0039BC  9059B0     MOV.B [W0+27], W3
0039BE  984923     MOV.B W3, [W2+10]
3172:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
0039C0  905810     MOV.B [W0+25], W0
0039C2  984930     MOV.B W0, [W2+11]
0039C4  780581     MOV W1, W11
0039C6  370004     BRA 0x39D0
3173:                                          } else {
3174:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
0039C8  B3C081     MOV.B #0x8, W1
0039CA  807630     MOV pCurrentEndpoint, W0
0039CC  985831     MOV.B W1, [W0+27]
0039CE  EB0580     CLR W11
3175:                                          }
3176:              #endif
3177:                                          break;
3178:              
3179:                                      default:
3180:                                          illegalState = TRUE;
3181:                                          break;
3182:                                  }
3183:                                  break;
3184:              
3185:                              default:
3186:                                  illegalState = TRUE;
3187:                          }
3188:              
3189:                          if (illegalState) {
3190:                              // We should never use this, but in case we do, put the endpoint
3191:                              // in a recoverable state.
3192:                              pCurrentEndpoint->transferState = TSTATE_IDLE;
003D8E  EB4000     CLR.B W0
003D90  985900     MOV.B W0, [W2+24]
3193:                              pCurrentEndpoint->status.bfTransferComplete = 1;
003D92  807631     MOV pCurrentEndpoint, W1
003D94  904031     MOV.B [W1+3], W0
003D96  A01400     BSET.B W0, #1
003D98  9840B0     MOV.B W0, [W1+3]
003D9A  20001B     MOV #0x1, W11
003D9C  37FE19     BRA 0x39D0
3194:                          }
3195:                      }
3196:              
3197:                      // If we've gone through all the endpoints, we do not have any more control transfers.
3198:                      usbBusInfo.flags.bfControlTransfersDone = 1;
0039D0  A80ECA     BSET usbBusInfo, #0
3199:                  }
3200:              
3201:              #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
3202:                  // Next, we will handle isochronous transfers.  We must be careful with
3203:                  // these.  The maximum packet size for an isochronous transfer is 1023
3204:                  // bytes, so we cannot use the threshold register (U1SOF) to ensure that
3205:                  // we do not write too many tokens during a frame.  Instead, we must count
3206:                  // the number of bytes we are sending and stop sending isochronous
3207:                  // transfers when we reach that limit.
3208:              
3209:                  // TODO: Implement scheduling by using usbBusInfo.dBytesSentInFrame
3210:              
3211:                  // Current Limitation:  The stack currently supports only one attached
3212:                  // device.  We will make the assumption that the control, isochronous, and
3213:                  // interrupt transfers requested by a single device will not exceed one
3214:                  // frame, and defer the scheduler.
3215:              
3216:                  // Due to the nature of isochronous transfers, transfer events must be used.
3217:              #if !defined( USB_ENABLE_TRANSFER_EVENT )
3218:              #error Transfer events are required for isochronous transfers
3219:              #endif
3220:              
3221:                  if (!usbBusInfo.flags.bfIsochronousTransfersDone) {
3222:                      // Look for any isochronous operations.
3223:                      while (_USB_FindServiceEndpoint(USB_TRANSFER_TYPE_ISOCHRONOUS)) {
3224:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK) {
3225:                              case TSTATE_ISOCHRONOUS_READ:
3226:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
3227:                                      case TSUBSTATE_ISOCHRONOUS_READ_DATA:
3228:                                          // Don't overwrite data the user has not yet processed.  We will skip this interval.    
3229:                                          if (((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid) {
3230:                                              // We have buffer overflow.
3231:                                          } else {
3232:                                              // Initialize the data buffer.
3233:                                              ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3234:                                              pCurrentEndpoint->dataCount = 0;
3235:              
3236:                                              _USB_SetDATA01(DTS_DATA0); // Always DATA0 for isochronous
3237:                                              _USB_SetBDT(USB_TOKEN_IN);
3238:                                              _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
3239:                                              return;
3240:                                          }
3241:                                          break;
3242:              
3243:                                      case TSUBSTATE_ISOCHRONOUS_READ_COMPLETE:
3244:                                          // Isochronous transfers are continuous until the user stops them.
3245:                                          // Send an event that there is new data, and reset for the next
3246:                                          // interval.
3247:                                          pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3248:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
3249:              
3250:                                          // Update the valid data length for this buffer.
3251:                                          ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength = pCurrentEndpoint->dataCount;
3252:                                          ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3253:              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3254:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
3255:                                              USB_EVENT_DATA *data;
3256:              
3257:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3258:                                              data->event = EVENT_TRANSFER;
3259:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
3260:                                              data->TransferData.pUserData = ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3261:                                              data->TransferData.bErrorCode = USB_SUCCESS;
3262:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3263:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3264:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
3265:                                          } else {
3266:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3267:                                          }
3268:              #endif
3269:              
3270:                                          // If the user wants an event from the interrupt handler to handle the data as quickly as
3271:                                          // possible, send up the event.  Then mark the packet as used.
3272:              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3273:                                          usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler(usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_READ, ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount);
3274:                                          ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3275:              #endif
3276:              
3277:                                          // Move to the next data buffer.
3278:                                          ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB++;
3279:                                          if (((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->totalBuffers) {
3280:                                              ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3281:                                          }
3282:                                          break;
3283:              
3284:                                      case TSUBSTATE_ERROR:
3285:                                          // Isochronous transfers are continuous until the user stops them.
3286:                                          // Send an event that there is an error, and reset for the next
3287:                                          // interval.
3288:                                          pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_READ | TSUBSTATE_ISOCHRONOUS_READ_DATA;
3289:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
3290:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3291:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
3292:                                              USB_EVENT_DATA *data;
3293:              
3294:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3295:                                              data->event = EVENT_BUS_ERROR;
3296:                                              data->TransferData.dataCount = 0;
3297:                                              data->TransferData.pUserData = NULL;
3298:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3299:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
3300:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3301:                                          } else {
3302:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3303:                                          }
3304:              #endif
3305:                                          break;
3306:              
3307:                                      default:
3308:                                          illegalState = TRUE;
3309:                                          break;
3310:                                  }
3311:                                  break;
3312:              
3313:                              case TSTATE_ISOCHRONOUS_WRITE:
3314:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
3315:                                      case TSUBSTATE_ISOCHRONOUS_WRITE_DATA:
3316:                                          if (!((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid) {
3317:                                              // We have buffer underrun.
3318:                                          } else {
3319:                                              pCurrentEndpoint->dataCount = ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].dataLength;
3320:              
3321:                                              _USB_SetDATA01(DTS_DATA0); // Always DATA0 for isochronous
3322:                                              _USB_SetBDT(USB_TOKEN_OUT);
3323:                                              _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT);
3324:                                              return;
3325:                                          }
3326:                                          break;
3327:              
3328:                                      case TSUBSTATE_ISOCHRONOUS_WRITE_COMPLETE:
3329:                                          // Isochronous transfers are continuous until the user stops them.
3330:                                          // Send an event that data has been sent, and reset for the next
3331:                                          // interval.
3332:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
3333:                                          pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3334:              
3335:                                          // Update the valid data length for this buffer.
3336:                                          ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 0;
3337:              #if defined( USB_ENABLE_ISOC_TRANSFER_EVENT )
3338:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
3339:                                              USB_EVENT_DATA *data;
3340:              
3341:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3342:                                              data->event = EVENT_TRANSFER;
3343:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
3344:                                              data->TransferData.pUserData = ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer;
3345:                                              data->TransferData.bErrorCode = USB_SUCCESS;
3346:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3347:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3348:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
3349:                                          } else {
3350:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3351:                                          }
3352:              #endif
3353:              
3354:                                          // If the user wants an event from the interrupt handler to handle the data as quickly as
3355:                                          // possible, send up the event.
3356:              #ifdef USB_HOST_APP_DATA_EVENT_HANDLER
3357:                                          usbClientDrvTable[pCurrentEndpoint->clientDriver].DataEventHandler(usbDeviceInfo.deviceAddress, EVENT_DATA_ISOC_WRITE, ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer, pCurrentEndpoint->dataCount);
3358:              #endif
3359:              
3360:                                          // Move to the next data buffer.
3361:                                          ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB++;
3362:                                          if (((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB >= ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->totalBuffers) {
3363:                                              ((ISOCHRONOUS_DATA *) pCurrentEndpoint->pUserData)->currentBufferUSB = 0;
3364:                                          }
3365:                                          ((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].bfDataLengthValid = 1;
3366:                                          break;
3367:              
3368:                                      case TSUBSTATE_ERROR:
3369:                                          // Isochronous transfers are continuous until the user stops them.
3370:                                          // Send an event that there is an error, and reset for the next
3371:                                          // interval.
3372:                                          pCurrentEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE | TSUBSTATE_ISOCHRONOUS_WRITE_DATA;
3373:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
3374:              
3375:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3376:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
3377:                                              USB_EVENT_DATA *data;
3378:              
3379:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
3380:                                              data->event = EVENT_BUS_ERROR;
3381:                                              data->TransferData.dataCount = 0;
3382:                                              data->TransferData.pUserData = NULL;
3383:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
3384:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
3385:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
3386:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
3387:                                          } else {
3388:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
3389:                                          }
3390:              #endif
3391:                                          break;
3392:              
3393:                                      default:
3394:                                          illegalState = TRUE;
3395:                                          break;
3396:                                  }
3397:                                  break;
3398:              
3399:                              default:
3400:                                  illegalState = TRUE;
3401:                                  break;
3402:                          }
3403:              
3404:                          if (illegalState) {
3405:                              // We should never use this, but in case we do, put the endpoint
3406:                              // in a recoverable state.
3407:                              pCurrentEndpoint->transferState = TSTATE_IDLE;
3408:                              pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
3409:                              pCurrentEndpoint->status.bfTransferComplete = 1;
3410:                          }
3411:                      }
3412:              
3413:                      // If we've gone through all the endpoints, we do not have any more isochronous transfers.
3414:                      usbBusInfo.flags.bfIsochronousTransfersDone = 1;
3415:                  }
3416:              #endif
3417:              
3418:              #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
3419:                  if (!usbBusInfo.flags.bfInterruptTransfersDone) {
0039D2  BFCECA     MOV.B usbBusInfo, WREG
0039D4  A31800     BTST.Z W0, #1
0039D6  3200F1     BRA Z, 0x3BBA
0039D8  3700F5     BRA 0x3BC4
3420:                      // Look for any interrupt operations.
3421:                      while (_USB_FindServiceEndpoint(USB_TRANSFER_TYPE_INTERRUPT)) {
003BBA  B3C030     MOV.B #0x3, W0
003BBC  0700F3     RCALL _USB_FindServiceEndpoint
003BBE  E00000     CP0 W0
003BC0  3AFF0C     BRA NZ, 0x39DA
3422:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK) {
0039DA  807632     MOV pCurrentEndpoint, W2
0039DC  905802     MOV.B [W2+24], W0
0039DE  780080     MOV W0, W1
0039E0  B20F01     AND #0xF0, W1
0039E2  200400     MOV #0x40, W0
0039E4  508F80     SUB W1, W0, [W15]
0039E6  320004     BRA Z, 0x39F0
0039E8  400070     ADD W0, #0x10, W0
0039EA  508F80     SUB W1, W0, [W15]
0039EC  3A00DB     BRA NZ, 0x3BA4
0039EE  37006C     BRA 0x3AC8
3423:                              case TSTATE_INTERRUPT_READ:
3424:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
0039F0  905802     MOV.B [W2+24], W0
0039F2  60006F     AND W0, #0xF, W0
0039F4  500FE1     SUB W0, #0x1, [W15]
0039F6  32000B     BRA Z, 0x3A0E
0039F8  500FEF     SUB W0, #0xF, [W15]
0039FA  320038     BRA Z, 0x3A6C
0039FC  E00000     CP0 W0
0039FE  3A00D2     BRA NZ, 0x3BA4
3425:                                      case TSUBSTATE_INTERRUPT_READ_DATA:
3426:                                          _USB_SetBDT(USB_TOKEN_IN);
003A00  B3C090     MOV.B #0x9, W0
003A02  0704F1     RCALL _USB_SetBDT
3427:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
003A04  807630     MOV pCurrentEndpoint, W0
003A06  905820     MOV.B [W0+26], W0
003A08  B3C091     MOV.B #0x9, W1
003A0A  0704D0     RCALL _USB_SendToken
003A0C  3701C8     BRA 0x3D9E
3428:                                          return;
3429:                                          break;
3430:              
3431:                                      case TSUBSTATE_INTERRUPT_READ_COMPLETE:
3432:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003A0E  EB4000     CLR.B W0
003A10  985900     MOV.B W0, [W2+24]
3433:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
003A12  807630     MOV pCurrentEndpoint, W0
003A14  900220     MOV [W0+4], W4
003A16  980034     MOV W4, [W0+6]
3434:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003A18  807631     MOV pCurrentEndpoint, W1
003A1A  904031     MOV.B [W1+3], W0
003A1C  A01400     BSET.B W0, #1
003A1E  9840B0     MOV.B W0, [W1+3]
3435:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3436:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003A20  807720     MOV 0xEE4, W0
003A22  500FE3     SUB W0, #0x3, [W15]
003A24  3C001F     BRA GT, 0x3A64
3437:                                              USB_EVENT_DATA *data;
3438:              
3439:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003A26  E80000     INC W0, W0
003A28  887720     MOV W0, 0xEE4
003A2A  807700     MOV usbEventQueue, W0
003A2C  500FE2     SUB W0, #0x2, [W15]
003A2E  3C0003     BRA GT, 0x3A36
003A30  E80000     INC W0, W0
003A32  887700     MOV W0, usbEventQueue
003A34  370001     BRA 0x3A38
003A36  EF2EE0     CLR usbEventQueue
003A38  807700     MOV usbEventQueue, W0
003A3A  B9006C     MUL.SU W0, #12, W0
003A3C  20EE62     MOV #0xEE6, W2
003A3E  410100     ADD W2, W0, W2
3440:                                              data->event = EVENT_TRANSFER;
003A40  200720     MOV #0x72, W0
003A42  780900     MOV W0, [W2]
3441:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003A44  807631     MOV pCurrentEndpoint, W1
003A46  900A01     MOV [W1+16], W4
003A48  900A91     MOV [W1+18], W5
003A4A  980114     MOV W4, [W2+2]
003A4C  980125     MOV W5, [W2+4]
3442:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003A4E  900AB1     MOV [W1+22], W5
003A50  980135     MOV W5, [W2+6]
3443:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003A52  EB4000     CLR.B W0
003A54  984910     MOV.B W0, [W2+9]
3444:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003A56  905821     MOV.B [W1+26], W0
003A58  984900     MOV.B W0, [W2+8]
3445:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003A5A  9059B1     MOV.B [W1+27], W3
003A5C  984923     MOV.B W3, [W2+10]
3446:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003A5E  905891     MOV.B [W1+25], W1
003A60  984931     MOV.B W1, [W2+11]
003A62  37009D     BRA 0x3B9E
3447:                                          } else {
3448:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003A64  B3C081     MOV.B #0x8, W1
003A66  807630     MOV pCurrentEndpoint, W0
003A68  985831     MOV.B W1, [W0+27]
003A6A  370099     BRA 0x3B9E
3449:                                          }
3450:              #endif
3451:                                          break;
3452:              
3453:                                      case TSUBSTATE_ERROR:
3454:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003A6C  EB4000     CLR.B W0
003A6E  985900     MOV.B W0, [W2+24]
3455:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
003A70  807630     MOV pCurrentEndpoint, W0
003A72  900220     MOV [W0+4], W4
003A74  980034     MOV W4, [W0+6]
3456:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003A76  807631     MOV pCurrentEndpoint, W1
003A78  904031     MOV.B [W1+3], W0
003A7A  A01400     BSET.B W0, #1
003A7C  9840B0     MOV.B W0, [W1+3]
3457:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3458:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003A7E  807720     MOV 0xEE4, W0
003A80  500FE3     SUB W0, #0x3, [W15]
003A82  3C001E     BRA GT, 0x3AC0
3459:                                              USB_EVENT_DATA *data;
3460:              
3461:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003A84  E80000     INC W0, W0
003A86  887720     MOV W0, 0xEE4
003A88  807700     MOV usbEventQueue, W0
003A8A  500FE2     SUB W0, #0x2, [W15]
003A8C  3C0003     BRA GT, 0x3A94
003A8E  E80000     INC W0, W0
003A90  887700     MOV W0, usbEventQueue
003A92  370001     BRA 0x3A96
003A94  EF2EE0     CLR usbEventQueue
003A96  807700     MOV usbEventQueue, W0
003A98  B9006C     MUL.SU W0, #12, W0
003A9A  20EE62     MOV #0xEE6, W2
003A9C  410100     ADD W2, W0, W2
3462:                                              data->event = EVENT_BUS_ERROR;
003A9E  27FFF0     MOV #0x7FFF, W0
003AA0  780900     MOV W0, [W2]
3463:                                              data->TransferData.dataCount = 0;
003AA2  B80060     MUL.UU W0, #0, W0
003AA4  980110     MOV W0, [W2+2]
003AA6  980121     MOV W1, [W2+4]
3464:                                              data->TransferData.pUserData = NULL;
003AA8  EB0000     CLR W0
003AAA  980130     MOV W0, [W2+6]
3465:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
003AAC  807630     MOV pCurrentEndpoint, W0
003AAE  905AC0     MOV.B [W0+28], W5
003AB0  984915     MOV.B W5, [W2+9]
3466:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003AB2  9058A0     MOV.B [W0+26], W1
003AB4  984901     MOV.B W1, [W2+8]
3467:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003AB6  9059B0     MOV.B [W0+27], W3
003AB8  984923     MOV.B W3, [W2+10]
3468:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003ABA  905810     MOV.B [W0+25], W0
003ABC  984930     MOV.B W0, [W2+11]
003ABE  37006F     BRA 0x3B9E
3469:                                          } else {
3470:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003AC0  B3C081     MOV.B #0x8, W1
003AC2  807630     MOV pCurrentEndpoint, W0
003AC4  985831     MOV.B W1, [W0+27]
003AC6  37006B     BRA 0x3B9E
3471:                                          }
3472:              #endif
3473:                                          break;
3474:              
3475:                                      default:
3476:                                          illegalState = TRUE;
3477:                                          break;
3478:                                  }
3479:                                  break;
3480:              
3481:                              case TSTATE_INTERRUPT_WRITE:
3482:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
003AC8  905802     MOV.B [W2+24], W0
003ACA  60006F     AND W0, #0xF, W0
003ACC  500FE1     SUB W0, #0x1, [W15]
003ACE  32000B     BRA Z, 0x3AE6
003AD0  500FEF     SUB W0, #0xF, [W15]
003AD2  320038     BRA Z, 0x3B44
003AD4  E00000     CP0 W0
003AD6  3A0066     BRA NZ, 0x3BA4
3483:                                      case TSUBSTATE_INTERRUPT_WRITE_DATA:
3484:                                          _USB_SetBDT(USB_TOKEN_OUT);
003AD8  B3C010     MOV.B #0x1, W0
003ADA  070485     RCALL _USB_SetBDT
3485:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT);
003ADC  807630     MOV pCurrentEndpoint, W0
003ADE  905820     MOV.B [W0+26], W0
003AE0  B3C011     MOV.B #0x1, W1
003AE2  070464     RCALL _USB_SendToken
003AE4  37015C     BRA 0x3D9E
3486:                                          return;
3487:                                          break;
3488:              
3489:                                      case TSUBSTATE_INTERRUPT_WRITE_COMPLETE:
3490:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003AE6  EB4000     CLR.B W0
003AE8  985900     MOV.B W0, [W2+24]
3491:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
003AEA  807630     MOV pCurrentEndpoint, W0
003AEC  900220     MOV [W0+4], W4
003AEE  980034     MOV W4, [W0+6]
3492:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003AF0  807631     MOV pCurrentEndpoint, W1
003AF2  904031     MOV.B [W1+3], W0
003AF4  A01400     BSET.B W0, #1
003AF6  9840B0     MOV.B W0, [W1+3]
3493:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3494:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003AF8  807720     MOV 0xEE4, W0
003AFA  500FE3     SUB W0, #0x3, [W15]
003AFC  3C001F     BRA GT, 0x3B3C
3495:                                              USB_EVENT_DATA *data;
3496:              
3497:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003AFE  E80000     INC W0, W0
003B00  887720     MOV W0, 0xEE4
003B02  807700     MOV usbEventQueue, W0
003B04  500FE2     SUB W0, #0x2, [W15]
003B06  3C0003     BRA GT, 0x3B0E
003B08  E80000     INC W0, W0
003B0A  887700     MOV W0, usbEventQueue
003B0C  370001     BRA 0x3B10
003B0E  EF2EE0     CLR usbEventQueue
003B10  807700     MOV usbEventQueue, W0
003B12  B9006C     MUL.SU W0, #12, W0
003B14  20EE62     MOV #0xEE6, W2
003B16  410100     ADD W2, W0, W2
3498:                                              data->event = EVENT_TRANSFER;
003B18  200720     MOV #0x72, W0
003B1A  780900     MOV W0, [W2]
3499:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003B1C  807631     MOV pCurrentEndpoint, W1
003B1E  900A01     MOV [W1+16], W4
003B20  900A91     MOV [W1+18], W5
003B22  980114     MOV W4, [W2+2]
003B24  980125     MOV W5, [W2+4]
3500:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003B26  900AB1     MOV [W1+22], W5
003B28  980135     MOV W5, [W2+6]
3501:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003B2A  EB4000     CLR.B W0
003B2C  984910     MOV.B W0, [W2+9]
3502:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003B2E  905821     MOV.B [W1+26], W0
003B30  984900     MOV.B W0, [W2+8]
3503:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003B32  9059B1     MOV.B [W1+27], W3
003B34  984923     MOV.B W3, [W2+10]
3504:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003B36  905891     MOV.B [W1+25], W1
003B38  984931     MOV.B W1, [W2+11]
003B3A  370031     BRA 0x3B9E
3505:                                          } else {
3506:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003B3C  B3C081     MOV.B #0x8, W1
003B3E  807630     MOV pCurrentEndpoint, W0
003B40  985831     MOV.B W1, [W0+27]
003B42  37002D     BRA 0x3B9E
3507:                                          }
3508:              #endif
3509:                                          break;
3510:              
3511:                                      case TSUBSTATE_ERROR:
3512:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003B44  EB4000     CLR.B W0
003B46  985900     MOV.B W0, [W2+24]
3513:                                          pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
003B48  807630     MOV pCurrentEndpoint, W0
003B4A  900220     MOV [W0+4], W4
003B4C  980034     MOV W4, [W0+6]
3514:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003B4E  807631     MOV pCurrentEndpoint, W1
003B50  904031     MOV.B [W1+3], W0
003B52  A01400     BSET.B W0, #1
003B54  9840B0     MOV.B W0, [W1+3]
3515:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3516:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003B56  807720     MOV 0xEE4, W0
003B58  500FE3     SUB W0, #0x3, [W15]
003B5A  3C001E     BRA GT, 0x3B98
3517:                                              USB_EVENT_DATA *data;
3518:              
3519:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003B5C  E80000     INC W0, W0
003B5E  887720     MOV W0, 0xEE4
003B60  807700     MOV usbEventQueue, W0
003B62  500FE2     SUB W0, #0x2, [W15]
003B64  3C0003     BRA GT, 0x3B6C
003B66  E80000     INC W0, W0
003B68  887700     MOV W0, usbEventQueue
003B6A  370001     BRA 0x3B6E
003B6C  EF2EE0     CLR usbEventQueue
003B6E  807700     MOV usbEventQueue, W0
003B70  B9006C     MUL.SU W0, #12, W0
003B72  20EE62     MOV #0xEE6, W2
003B74  410100     ADD W2, W0, W2
3520:                                              data->event = EVENT_BUS_ERROR;
003B76  27FFF0     MOV #0x7FFF, W0
003B78  780900     MOV W0, [W2]
3521:                                              data->TransferData.dataCount = 0;
003B7A  B80060     MUL.UU W0, #0, W0
003B7C  980110     MOV W0, [W2+2]
003B7E  980121     MOV W1, [W2+4]
3522:                                              data->TransferData.pUserData = NULL;
003B80  EB0000     CLR W0
003B82  980130     MOV W0, [W2+6]
3523:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
003B84  807630     MOV pCurrentEndpoint, W0
003B86  905AC0     MOV.B [W0+28], W5
003B88  984915     MOV.B W5, [W2+9]
3524:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003B8A  9058A0     MOV.B [W0+26], W1
003B8C  984901     MOV.B W1, [W2+8]
3525:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003B8E  9059B0     MOV.B [W0+27], W3
003B90  984923     MOV.B W3, [W2+10]
3526:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003B92  905810     MOV.B [W0+25], W0
003B94  984930     MOV.B W0, [W2+11]
003B96  370003     BRA 0x3B9E
3527:                                          } else {
3528:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003B98  B3C081     MOV.B #0x8, W1
003B9A  807630     MOV pCurrentEndpoint, W0
003B9C  985831     MOV.B W1, [W0+27]
3529:                                          }
3530:              #endif
3531:                                          break;
3532:              
3533:                                      default:
3534:                                          illegalState = TRUE;
3535:                                          break;
3536:                                  }
3537:                                  break;
3538:              
3539:                              default:
3540:                                  illegalState = TRUE;
3541:                                  break;
3542:                          }
3543:              
3544:                          if (illegalState) {
003B9E  E0000B     CP0 W11
003BA0  3A0002     BRA NZ, 0x3BA6
003BA2  37000B     BRA 0x3BBA
003BA4  20001B     MOV #0x1, W11
3545:                              // We should never use this, but in case we do, put the endpoint
3546:                              // in a recoverable state.
3547:                              pCurrentEndpoint->transferState = TSTATE_IDLE;
003BA6  EB4080     CLR.B W1
003BA8  807630     MOV pCurrentEndpoint, W0
003BAA  985801     MOV.B W1, [W0+24]
3548:                              pCurrentEndpoint->wIntervalCount = pCurrentEndpoint->wInterval;
003BAC  807630     MOV pCurrentEndpoint, W0
003BAE  900220     MOV [W0+4], W4
003BB0  980034     MOV W4, [W0+6]
3549:                              pCurrentEndpoint->status.bfTransferComplete = 1;
003BB2  807631     MOV pCurrentEndpoint, W1
003BB4  904031     MOV.B [W1+3], W0
003BB6  A01400     BSET.B W0, #1
003BB8  9840B0     MOV.B W0, [W1+3]
3550:                          }
3551:                      }
3552:              
3553:                      // If we've gone through all the endpoints, we do not have any more interrupt transfers.
3554:                      usbBusInfo.flags.bfInterruptTransfersDone = 1;
003BC2  A82ECA     BSET usbBusInfo, #1
3555:                  }
3556:              #endif
3557:              
3558:              #ifdef USB_SUPPORT_BULK_TRANSFERS
3559:              #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
3560:              TryBulk:
3561:              #endif
3562:              
3563:                  if (!usbBusInfo.flags.bfBulkTransfersDone) {
003BC4  BFCECA     MOV.B usbBusInfo, WREG
003BC6  A33800     BTST.Z W0, #3
003BC8  3A00EA     BRA NZ, 0x3D9E
003BCA  EB4400     CLR.B W8
003BCC  20EE69     MOV #0xEE6, W9
003BCE  B3C08A     MOV.B #0x8, W10
003D82  BFCECA     MOV.B usbBusInfo, WREG
003D84  A33800     BTST.Z W0, #3
003D86  3A000B     BRA NZ, 0x3D9E
003D88  37FF23     BRA 0x3BD0
3564:              #ifndef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
3565:                      // Only go through this section once if we are not allowing multiple transactions
3566:                      // per frame.
3567:                      usbBusInfo.flags.bfBulkTransfersDone = 1;
3568:              #endif
3569:              
3570:                      // Look for any bulk operations.  Try to service all pending requests within the frame.
3571:                      if (_USB_FindServiceEndpoint(USB_TRANSFER_TYPE_BULK)) {
003BD0  B3C020     MOV.B #0x2, W0
003BD2  0700E8     RCALL _USB_FindServiceEndpoint
003BD4  E00000     CP0 W0
003BD6  3200D2     BRA Z, 0x3D7C
3572:                          switch (pCurrentEndpoint->transferState & TSTATE_MASK) {
003BD8  807632     MOV pCurrentEndpoint, W2
003BDA  905802     MOV.B [W2+24], W0
003BDC  780080     MOV W0, W1
003BDE  B20F01     AND #0xF0, W1
003BE0  200800     MOV #0x80, W0
003BE2  508F80     SUB W1, W0, [W15]
003BE4  320004     BRA Z, 0x3BEE
003BE6  400070     ADD W0, #0x10, W0
003BE8  508F80     SUB W1, W0, [W15]
003BEA  3A00C1     BRA NZ, 0x3D6E
003BEC  37005F     BRA 0x3CAC
3573:                              case TSTATE_BULK_READ:
3574:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
003BEE  905802     MOV.B [W2+24], W0
003BF0  60006F     AND W0, #0xF, W0
003BF2  500FE1     SUB W0, #0x1, [W15]
003BF4  32000B     BRA Z, 0x3C0C
003BF6  500FEF     SUB W0, #0xF, [W15]
003BF8  320031     BRA Z, 0x3C5C
003BFA  E00000     CP0 W0
003BFC  3A00B8     BRA NZ, 0x3D6E
3575:                                      case TSUBSTATE_BULK_READ_DATA:
3576:                                          _USB_SetBDT(USB_TOKEN_IN);
003BFE  B3C090     MOV.B #0x9, W0
003C00  0703F2     RCALL _USB_SetBDT
3577:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_IN);
003C02  807630     MOV pCurrentEndpoint, W0
003C04  905820     MOV.B [W0+26], W0
003C06  B3C091     MOV.B #0x9, W1
003C08  0703D1     RCALL _USB_SendToken
003C0A  3700C9     BRA 0x3D9E
3578:                                          return;
3579:                                          break;
3580:              
3581:                                      case TSUBSTATE_BULK_READ_COMPLETE:
3582:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003C0C  985908     MOV.B W8, [W2+24]
3583:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003C0E  807631     MOV pCurrentEndpoint, W1
003C10  904031     MOV.B [W1+3], W0
003C12  A01400     BSET.B W0, #1
003C14  9840B0     MOV.B W0, [W1+3]
3584:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3585:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003C16  807720     MOV 0xEE4, W0
003C18  500FE3     SUB W0, #0x3, [W15]
003C1A  3C001D     BRA GT, 0x3C56
3586:                                              USB_EVENT_DATA *data;
3587:              
3588:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003C1C  E80000     INC W0, W0
003C1E  887720     MOV W0, 0xEE4
003C20  807700     MOV usbEventQueue, W0
003C22  500FE2     SUB W0, #0x2, [W15]
003C24  3C0003     BRA GT, 0x3C2C
003C26  E80000     INC W0, W0
003C28  887700     MOV W0, usbEventQueue
003C2A  370001     BRA 0x3C2E
003C2C  EF2EE0     CLR usbEventQueue
003C2E  807700     MOV usbEventQueue, W0
003C30  B9006C     MUL.SU W0, #12, W0
003C32  448000     ADD W9, W0, W0
3589:                                              data->event = EVENT_TRANSFER;
003C34  200722     MOV #0x72, W2
003C36  780802     MOV W2, [W0]
3590:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003C38  807632     MOV pCurrentEndpoint, W2
003C3A  900A02     MOV [W2+16], W4
003C3C  900A92     MOV [W2+18], W5
003C3E  980014     MOV W4, [W0+2]
003C40  980025     MOV W5, [W0+4]
3591:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003C42  900AB2     MOV [W2+22], W5
003C44  980035     MOV W5, [W0+6]
3592:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003C46  984818     MOV.B W8, [W0+9]
3593:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003C48  9058A2     MOV.B [W2+26], W1
003C4A  984801     MOV.B W1, [W0+8]
3594:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003C4C  9059B2     MOV.B [W2+27], W3
003C4E  984823     MOV.B W3, [W0+10]
3595:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003C50  905912     MOV.B [W2+25], W2
003C52  984832     MOV.B W2, [W0+11]
003C54  370089     BRA 0x3D68
3596:                                          } else {
3597:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003C56  807630     MOV pCurrentEndpoint, W0
003C58  98583A     MOV.B W10, [W0+27]
003C5A  370086     BRA 0x3D68
3598:                                          }
3599:              #endif
3600:                                          break;
3601:              
3602:                                      case TSUBSTATE_ERROR:
3603:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003C5C  985908     MOV.B W8, [W2+24]
3604:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003C5E  807631     MOV pCurrentEndpoint, W1
003C60  904031     MOV.B [W1+3], W0
003C62  A01400     BSET.B W0, #1
003C64  9840B0     MOV.B W0, [W1+3]
3605:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3606:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003C66  807720     MOV 0xEE4, W0
003C68  500FE3     SUB W0, #0x3, [W15]
003C6A  3C001D     BRA GT, 0x3CA6
3607:                                              USB_EVENT_DATA *data;
3608:              
3609:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003C6C  E80000     INC W0, W0
003C6E  887720     MOV W0, 0xEE4
003C70  807700     MOV usbEventQueue, W0
003C72  500FE2     SUB W0, #0x2, [W15]
003C74  3C0003     BRA GT, 0x3C7C
003C76  E80000     INC W0, W0
003C78  887700     MOV W0, usbEventQueue
003C7A  370001     BRA 0x3C7E
003C7C  EF2EE0     CLR usbEventQueue
003C7E  807700     MOV usbEventQueue, W0
003C80  B9006C     MUL.SU W0, #12, W0
003C82  448000     ADD W9, W0, W0
3610:                                              data->event = EVENT_BUS_ERROR;
003C84  27FFF2     MOV #0x7FFF, W2
003C86  780802     MOV W2, [W0]
3611:                                              data->TransferData.dataCount = 0;
003C88  B81160     MUL.UU W2, #0, W2
003C8A  980012     MOV W2, [W0+2]
003C8C  980023     MOV W3, [W0+4]
3612:                                              data->TransferData.pUserData = NULL;
003C8E  EB0100     CLR W2
003C90  980032     MOV W2, [W0+6]
3613:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
003C92  807632     MOV pCurrentEndpoint, W2
003C94  905A42     MOV.B [W2+28], W4
003C96  984814     MOV.B W4, [W0+9]
3614:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003C98  905AA2     MOV.B [W2+26], W5
003C9A  984805     MOV.B W5, [W0+8]
3615:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003C9C  9058B2     MOV.B [W2+27], W1
003C9E  984821     MOV.B W1, [W0+10]
3616:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003CA0  905912     MOV.B [W2+25], W2
003CA2  984832     MOV.B W2, [W0+11]
003CA4  370061     BRA 0x3D68
3617:                                          } else {
3618:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003CA6  807630     MOV pCurrentEndpoint, W0
003CA8  98583A     MOV.B W10, [W0+27]
003CAA  37005E     BRA 0x3D68
3619:                                          }
3620:              #endif
3621:                                          break;
3622:              
3623:                                      default:
3624:                                          illegalState = TRUE;
3625:                                          break;
3626:                                  }
3627:                                  break;
3628:              
3629:                              case TSTATE_BULK_WRITE:
3630:                                  switch (pCurrentEndpoint->transferState & TSUBSTATE_MASK) {
003CAC  905802     MOV.B [W2+24], W0
003CAE  60006F     AND W0, #0xF, W0
003CB0  500FE1     SUB W0, #0x1, [W15]
003CB2  32000B     BRA Z, 0x3CCA
003CB4  500FEF     SUB W0, #0xF, [W15]
003CB6  320031     BRA Z, 0x3D1A
003CB8  E00000     CP0 W0
003CBA  3A0059     BRA NZ, 0x3D6E
3631:                                      case TSUBSTATE_BULK_WRITE_DATA:
3632:                                          _USB_SetBDT(USB_TOKEN_OUT);
003CBC  B3C010     MOV.B #0x1, W0
003CBE  070393     RCALL _USB_SetBDT
3633:                                          _USB_SendToken(pCurrentEndpoint->bEndpointAddress, USB_TOKEN_OUT);
003CC0  807630     MOV pCurrentEndpoint, W0
003CC2  905820     MOV.B [W0+26], W0
003CC4  B3C011     MOV.B #0x1, W1
003CC6  070372     RCALL _USB_SendToken
003CC8  37006A     BRA 0x3D9E
3634:                                          return;
3635:                                          break;
3636:              
3637:                                      case TSUBSTATE_BULK_WRITE_COMPLETE:
3638:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003CCA  985908     MOV.B W8, [W2+24]
3639:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003CCC  807631     MOV pCurrentEndpoint, W1
003CCE  904031     MOV.B [W1+3], W0
003CD0  A01400     BSET.B W0, #1
003CD2  9840B0     MOV.B W0, [W1+3]
3640:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3641:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003CD4  807720     MOV 0xEE4, W0
003CD6  500FE3     SUB W0, #0x3, [W15]
003CD8  3C001D     BRA GT, 0x3D14
3642:                                              USB_EVENT_DATA *data;
3643:              
3644:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003CDA  E80000     INC W0, W0
003CDC  887720     MOV W0, 0xEE4
003CDE  807700     MOV usbEventQueue, W0
003CE0  500FE2     SUB W0, #0x2, [W15]
003CE2  3C0003     BRA GT, 0x3CEA
003CE4  E80000     INC W0, W0
003CE6  887700     MOV W0, usbEventQueue
003CE8  370001     BRA 0x3CEC
003CEA  EF2EE0     CLR usbEventQueue
003CEC  807700     MOV usbEventQueue, W0
003CEE  B9006C     MUL.SU W0, #12, W0
003CF0  448000     ADD W9, W0, W0
3645:                                              data->event = EVENT_TRANSFER;
003CF2  200722     MOV #0x72, W2
003CF4  780802     MOV W2, [W0]
3646:                                              data->TransferData.dataCount = pCurrentEndpoint->dataCount;
003CF6  807632     MOV pCurrentEndpoint, W2
003CF8  900A02     MOV [W2+16], W4
003CFA  900A92     MOV [W2+18], W5
003CFC  980014     MOV W4, [W0+2]
003CFE  980025     MOV W5, [W0+4]
3647:                                              data->TransferData.pUserData = pCurrentEndpoint->pUserData;
003D00  900AB2     MOV [W2+22], W5
003D02  980035     MOV W5, [W0+6]
3648:                                              data->TransferData.bErrorCode = USB_SUCCESS;
003D04  984818     MOV.B W8, [W0+9]
3649:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003D06  9058A2     MOV.B [W2+26], W1
003D08  984801     MOV.B W1, [W0+8]
3650:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003D0A  9059B2     MOV.B [W2+27], W3
003D0C  984823     MOV.B W3, [W0+10]
3651:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003D0E  905912     MOV.B [W2+25], W2
003D10  984832     MOV.B W2, [W0+11]
003D12  37002A     BRA 0x3D68
3652:                                          } else {
3653:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003D14  807630     MOV pCurrentEndpoint, W0
003D16  98583A     MOV.B W10, [W0+27]
003D18  370027     BRA 0x3D68
3654:                                          }
3655:              #endif
3656:                                          break;
3657:              
3658:                                      case TSUBSTATE_ERROR:
3659:                                          pCurrentEndpoint->transferState = TSTATE_IDLE;
003D1A  985908     MOV.B W8, [W2+24]
3660:                                          pCurrentEndpoint->status.bfTransferComplete = 1;
003D1C  807631     MOV pCurrentEndpoint, W1
003D1E  904031     MOV.B [W1+3], W0
003D20  A01400     BSET.B W0, #1
003D22  9840B0     MOV.B W0, [W1+3]
3661:              #if defined( USB_ENABLE_TRANSFER_EVENT )
3662:                                          if (StructQueueIsNotFull(&usbEventQueue, USB_EVENT_QUEUE_DEPTH)) {
003D24  807720     MOV 0xEE4, W0
003D26  500FE3     SUB W0, #0x3, [W15]
003D28  3C001D     BRA GT, 0x3D64
3663:                                              USB_EVENT_DATA *data;
3664:              
3665:                                              data = StructQueueAdd(&usbEventQueue, USB_EVENT_QUEUE_DEPTH);
003D2A  E80000     INC W0, W0
003D2C  887720     MOV W0, 0xEE4
003D2E  807700     MOV usbEventQueue, W0
003D30  500FE2     SUB W0, #0x2, [W15]
003D32  3C0003     BRA GT, 0x3D3A
003D34  E80000     INC W0, W0
003D36  887700     MOV W0, usbEventQueue
003D38  370001     BRA 0x3D3C
003D3A  EF2EE0     CLR usbEventQueue
003D3C  807700     MOV usbEventQueue, W0
003D3E  B9006C     MUL.SU W0, #12, W0
003D40  448000     ADD W9, W0, W0
3666:                                              data->event = EVENT_BUS_ERROR;
003D42  27FFF2     MOV #0x7FFF, W2
003D44  780802     MOV W2, [W0]
3667:                                              data->TransferData.dataCount = 0;
003D46  B81160     MUL.UU W2, #0, W2
003D48  980012     MOV W2, [W0+2]
003D4A  980023     MOV W3, [W0+4]
3668:                                              data->TransferData.pUserData = NULL;
003D4C  EB0100     CLR W2
003D4E  980032     MOV W2, [W0+6]
3669:                                              data->TransferData.bErrorCode = pCurrentEndpoint->bErrorCode;
003D50  807632     MOV pCurrentEndpoint, W2
003D52  905A42     MOV.B [W2+28], W4
003D54  984814     MOV.B W4, [W0+9]
3670:                                              data->TransferData.bEndpointAddress = pCurrentEndpoint->bEndpointAddress;
003D56  905AA2     MOV.B [W2+26], W5
003D58  984805     MOV.B W5, [W0+8]
3671:                                              data->TransferData.bmAttributes.val = pCurrentEndpoint->bmAttributes.val;
003D5A  9058B2     MOV.B [W2+27], W1
003D5C  984821     MOV.B W1, [W0+10]
3672:                                              data->TransferData.clientDriver = pCurrentEndpoint->clientDriver;
003D5E  905912     MOV.B [W2+25], W2
003D60  984832     MOV.B W2, [W0+11]
003D62  370002     BRA 0x3D68
3673:                                          } else {
3674:                                              pCurrentEndpoint->bmAttributes.val = USB_EVENT_QUEUE_FULL;
003D64  807630     MOV pCurrentEndpoint, W0
003D66  98583A     MOV.B W10, [W0+27]
3675:                                          }
3676:              #endif
3677:                                          break;
3678:              
3679:                                      default:
3680:                                          illegalState = TRUE;
3681:                                          break;
3682:                                  }
3683:                                  break;
3684:              
3685:                              default:
3686:                                  illegalState = TRUE;
3687:                                  break;
3688:                          }
3689:              
3690:                          if (illegalState) {
003D68  E0000B     CP0 W11
003D6A  3A0002     BRA NZ, 0x3D70
003D6C  370007     BRA 0x3D7C
003D6E  20001B     MOV #0x1, W11
3691:                              // We should never use this, but in case we do, put the endpoint
3692:                              // in a recoverable state.
3693:                              pCurrentEndpoint->transferState = TSTATE_IDLE;
003D70  807630     MOV pCurrentEndpoint, W0
003D72  985808     MOV.B W8, [W0+24]
3694:                              pCurrentEndpoint->status.bfTransferComplete = 1;
003D74  807631     MOV pCurrentEndpoint, W1
003D76  904031     MOV.B [W1+3], W0
003D78  A01400     BSET.B W0, #1
003D7A  9840B0     MOV.B W0, [W1+3]
3695:                          }
3696:                      }
3697:              
3698:                      // We've gone through all the bulk transactions, but we have time for more.
3699:                      // If we have any bulk transactions, go back to the beginning of the list
3700:                      // and start over.
3701:              #ifdef ALLOW_MULTIPLE_BULK_TRANSACTIONS_PER_FRAME
3702:                      if (usbBusInfo.countBulkTransactions) {
003D7C  E24ECD     CP0.B 0xECD
003D7E  320005     BRA Z, 0x3D8A
3703:                          usbBusInfo.lastBulkTransaction = 0;
003D80  EF6ECC     CLR.B 0xECC
3704:                          goto TryBulk;
3705:              
3706:                      }
3707:              #endif
3708:              
3709:                      // If we've gone through all the endpoints, we do not have any more bulk transfers.
3710:                      usbBusInfo.flags.bfBulkTransfersDone = 1;
003D8A  A86ECA     BSET usbBusInfo, #3
003D8C  370008     BRA 0x3D9E
3711:                  }
3712:              #endif
3713:              
3714:                  return;
3715:              }
003D9E  BE054F     MOV.D [--W15], W10
003DA0  BE044F     MOV.D [--W15], W8
003DA2  060000     RETURN
3716:              
3717:              /****************************************************************************
3718:                Function:
3719:                  BOOL _USB_FindServiceEndpoint( BYTE transferType )
3720:              
3721:                Description:
3722:                  This function finds an endpoint of the specified transfer type that is
3723:                  ready for servicing.  If it finds one, usbDeviceInfo.pCurrentEndpoint is
3724:                  updated to point to the endpoint information structure.
3725:              
3726:                Precondition:
3727:                  None
3728:              
3729:                Parameters:
3730:                  BYTE transferType - Endpoint transfer type.  Valid values are:
3731:               * USB_TRANSFER_TYPE_CONTROL
3732:               * USB_TRANSFER_TYPE_ISOCHRONOUS
3733:               * USB_TRANSFER_TYPE_INTERRUPT
3734:               * USB_TRANSFER_TYPE_BULK
3735:              
3736:                Return Values:
3737:                  TRUE    - An endpoint of the indicated transfer type needs to be serviced,
3738:                              and pCurrentEndpoint has been updated to point to the endpoint.
3739:                  FALSE   - No endpoints of the indicated transfer type need to be serviced.
3740:              
3741:                Remarks:
3742:                  The EP 0 block is retained.
3743:               ***************************************************************************/
3744:              BOOL _USB_FindServiceEndpoint(BYTE transferType) {
003DA4  784200     MOV.B W0, W4
3745:                  USB_ENDPOINT_INFO *pEndpoint;
3746:                  USB_INTERFACE_INFO *pInterface;
3747:              
3748:                  // Check endpoint 0.
3749:                  if ((usbDeviceInfo.pEndpoint0->bmAttributes.bfTransferType == transferType) &&
003DA6  8076E1     MOV 0xEDC, W1
003DA8  FB8280     ZE W0, W5
003DAA  900851     MOV [W1+26], W0
003DAC  DE0048     LSR W0, #8, W0
003DAE  600063     AND W0, #0x3, W0
003DB0  500F85     SUB W0, W5, [W15]
003DB2  3A0006     BRA NZ, 0x3DC0
003DB4  904031     MOV.B [W1+3], W0
003DB6  A31800     BTST.Z W0, #1
003DB8  3A0003     BRA NZ, 0x3DC0
3750:                          !usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
3751:                      pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
003DBA  887631     MOV W1, pCurrentEndpoint
003DBC  200010     MOV #0x1, W0
003DBE  37004C     BRA 0x3E58
3752:                      return TRUE;
3753:                  }
3754:              
3755:                  usbBusInfo.countBulkTransactions = 0;
003DC0  EF6ECD     CLR.B 0xECD
3756:                  pEndpoint = NULL;
3757:                  pInterface = usbDeviceInfo.pInterfaceList;
003DC2  8076D3     MOV 0xEDA, W3
3758:                  if (pInterface && pInterface->pCurrentSetting) {
003DC4  E00003     CP0 W3
003DC6  320047     BRA Z, 0x3E56
003DC8  900023     MOV [W3+4], W0
003DCA  E00000     CP0 W0
003DCC  3A0007     BRA NZ, 0x3DDC
003DCE  780100     MOV W0, W2
003DD0  37003F     BRA 0x3E50
3759:                      pEndpoint = pInterface->pCurrentSetting->pEndpointList;
003DDC  900120     MOV [W0+4], W2
003DDE  370038     BRA 0x3E50
3760:                  }
3761:              
3762:                  while (pInterface) {
3763:                      if (pEndpoint != NULL) {
003E50  E00002     CP0 W2
003E52  3AFFC6     BRA NZ, 0x3DE0
003E54  37FFF4     BRA 0x3E3E
003E56  EB0000     CLR W0
3764:                          if (pEndpoint->bmAttributes.bfTransferType == transferType) {
003DE0  900852     MOV [W2+26], W0
003DE2  DE0048     LSR W0, #8, W0
003DE4  600063     AND W0, #0x3, W0
003DE6  528F80     SUB W5, W0, [W15]
003DE8  3A0027     BRA NZ, 0x3E38
3765:                              switch (transferType) {
003DEA  524FE2     SUB.B W4, #0x2, [W15]
003DEC  320019     BRA Z, 0x3E20
003DEE  524FE3     SUB.B W4, #0x3, [W15]
003DF0  320008     BRA Z, 0x3E02
003DF2  E00404     CP0.B W4
003DF4  3A0021     BRA NZ, 0x3E38
3766:                                  case USB_TRANSFER_TYPE_CONTROL:
3767:                                      if (!pEndpoint->status.bfTransferComplete) {
003DF6  904032     MOV.B [W2+3], W0
003DF8  A31800     BTST.Z W0, #1
003DFA  3A001E     BRA NZ, 0x3E38
3768:                                          pCurrentEndpoint = pEndpoint;
003DFC  887632     MOV W2, pCurrentEndpoint
003DFE  200010     MOV #0x1, W0
003E00  37002B     BRA 0x3E58
3769:                                          return TRUE;
3770:                                      }
3771:                                      break;
3772:              
3773:              #ifdef USB_SUPPORT_ISOCHRONOUS_TRANSFERS
3774:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
3775:              #endif
3776:              #ifdef USB_SUPPORT_INTERRUPT_TRANSFERS
3777:                                  case USB_TRANSFER_TYPE_INTERRUPT:
3778:              #endif
3779:              #if defined( USB_SUPPORT_ISOCHRONOUS_TRANSFERS ) || defined( USB_SUPPORT_INTERRUPT_TRANSFERS )
3780:                                      if (pEndpoint->status.bfTransferComplete) {
003E02  904032     MOV.B [W2+3], W0
003E04  A31800     BTST.Z W0, #1
003E06  320006     BRA Z, 0x3E14
3781:                                          // The endpoint doesn't need servicing.  If the interval count
3782:                                          // has reached 0 and the user has not initiated another transaction,
3783:                                          // reset the interval count for the next interval.
3784:                                          if (pEndpoint->wIntervalCount == 0) {
003E08  900032     MOV [W2+6], W0
003E0A  E00000     CP0 W0
003E0C  3A0015     BRA NZ, 0x3E38
3785:                                              // Reset the interval count for the next packet.
3786:                                              pEndpoint->wIntervalCount = pEndpoint->wInterval;
003E0E  900022     MOV [W2+4], W0
003E10  980130     MOV W0, [W2+6]
003E12  370012     BRA 0x3E38
3787:                                          }
3788:                                      } else {
3789:                                          if (pEndpoint->wIntervalCount == 0) {
003E14  900032     MOV [W2+6], W0
003E16  E00000     CP0 W0
003E18  3A000F     BRA NZ, 0x3E38
3790:                                              pCurrentEndpoint = pEndpoint;
003E1A  887632     MOV W2, pCurrentEndpoint
003E1C  200010     MOV #0x1, W0
003E1E  37001C     BRA 0x3E58
3791:                                              return TRUE;
3792:                                          }
3793:                                      }
3794:                                      break;
3795:              #endif
3796:              
3797:              #ifdef USB_SUPPORT_BULK_TRANSFERS
3798:                                  case USB_TRANSFER_TYPE_BULK:
3799:              #ifdef ALLOW_MULTIPLE_NAKS_PER_FRAME
3800:                                      if (!pEndpoint->status.bfTransferComplete)
3801:              #else
3802:                                      if (!pEndpoint->status.bfTransferComplete &&
003E20  904032     MOV.B [W2+3], W0
003E22  A31800     BTST.Z W0, #1
003E24  3A0009     BRA NZ, 0x3E38
003E26  904032     MOV.B [W2+3], W0
003E28  A34800     BTST.Z W0, #4
003E2A  3A0006     BRA NZ, 0x3E38
3803:                                              !pEndpoint->status.bfLastTransferNAKd)
3804:              #endif
3805:                                      {
3806:                                          usbBusInfo.countBulkTransactions++;
003E2C  EC6ECD     INC.B 0xECD
3807:                                          if (usbBusInfo.countBulkTransactions > usbBusInfo.lastBulkTransaction) {
003E2E  20ECD1     MOV #0xECD, W1
003E30  784091     MOV.B [W1], W1
003E32  BFCECC     MOV.B 0xECC, WREG
003E34  50CF80     SUB.B W1, W0, [W15]
003E36  3EFFCD     BRA GTU, 0x3DD2
3808:                                              usbBusInfo.lastBulkTransaction = usbBusInfo.countBulkTransactions;
003DD2  BFCECD     MOV.B 0xECD, WREG
003DD4  B7EECC     MOV.B WREG, 0xECC
3809:                                              pCurrentEndpoint = pEndpoint;
003DD6  887632     MOV W2, pCurrentEndpoint
003DD8  200010     MOV #0x1, W0
003DDA  37003E     BRA 0x3E58
3810:                                              return TRUE;
3811:                                          }
3812:                                      }
3813:                                      break;
3814:              #endif
3815:                              }
3816:                          }
3817:              
3818:                          // Go to the next endpoint.
3819:                          pEndpoint = pEndpoint->next;
003E38  780112     MOV [W2], W2
3820:                      }
3821:              
3822:                      if (pEndpoint == NULL) {
003E3A  E00002     CP0 W2
003E3C  3A0009     BRA NZ, 0x3E50
3823:                          // Go to the next interface.
3824:                          pInterface = pInterface->next;
003E3E  780193     MOV [W3], W3
3825:                          if (pInterface && pInterface->pCurrentSetting) {
003E40  E00003     CP0 W3
003E42  320009     BRA Z, 0x3E56
003E44  900023     MOV [W3+4], W0
003E46  E00000     CP0 W0
003E48  3A0002     BRA NZ, 0x3E4E
003E4A  780100     MOV W0, W2
003E4C  370001     BRA 0x3E50
3826:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
003E4E  900120     MOV [W0+4], W2
3827:                          }
3828:                      }
3829:                  }
3830:              
3831:                  // No endpoints with the desired description are ready for servicing.
3832:                  return FALSE;
3833:              }
003E58  060000     RETURN
3834:              
3835:              /****************************************************************************
3836:                Function:
3837:                  void _USB_FreeConfigMemory( void )
3838:              
3839:                Description:
3840:                  This function frees the interface and endpoint lists associated
3841:                              with a configuration.
3842:              
3843:                Precondition:
3844:                  None
3845:              
3846:                Parameters:
3847:                  None - None
3848:              
3849:                Returns:
3850:                  None
3851:              
3852:                Remarks:
3853:                  The EP 0 block is retained.
3854:               ***************************************************************************/
3855:              
3856:              void _USB_FreeConfigMemory(void) {
003E5A  BE9F88     MOV.D W8, [W15++]
003E5C  BE9F8A     MOV.D W10, [W15++]
3857:                  USB_INTERFACE_INFO *pTempInterface;
3858:                  USB_INTERFACE_SETTING_INFO *pTempSetting;
3859:                  USB_ENDPOINT_INFO *pTempEndpoint;
3860:              
3861:                  while (usbDeviceInfo.pInterfaceList != NULL) {
003E5E  8076DB     MOV 0xEDA, W11
003E60  E0000B     CP0 W11
003E62  320028     BRA Z, 0x3EB4
003EB0  E0000B     CP0 W11
003EB2  3AFFD8     BRA NZ, 0x3E64
3862:                      pTempInterface = usbDeviceInfo.pInterfaceList->next;
003E64  78059B     MOV [W11], W11
3863:              
3864:                      while (usbDeviceInfo.pInterfaceList->pInterfaceSettings != NULL) {
003E66  8076D0     MOV 0xEDA, W0
003E68  900090     MOV [W0+2], W1
003E6A  E00001     CP0 W1
003E6C  32001F     BRA Z, 0x3EAC
003EA4  8076D0     MOV 0xEDA, W0
003EA6  900090     MOV [W0+2], W1
003EA8  E00001     CP0 W1
003EAA  3AFFE1     BRA NZ, 0x3E6E
3865:                          pTempSetting = usbDeviceInfo.pInterfaceList->pInterfaceSettings->next;
003E6E  780511     MOV [W1], W10
3866:              
3867:                          while (usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList != NULL) {
003E70  8076D0     MOV 0xEDA, W0
003E72  900090     MOV [W0+2], W1
003E74  900021     MOV [W1+4], W0
003E76  E00000     CP0 W0
003E78  32000E     BRA Z, 0x3E96
003E7A  EB0480     CLR W9
003E8C  8076D0     MOV 0xEDA, W0
003E8E  900090     MOV [W0+2], W1
003E90  900021     MOV [W1+4], W0
003E92  E00000     CP0 W0
003E94  3AFFF3     BRA NZ, 0x3E7C
3868:                              pTempEndpoint = usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList->next;
003E7C  780410     MOV [W0], W8
3869:                              USB_FREE_AND_CLEAR(usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList);
003E7E  07E2C3     RCALL _free
003E80  8076D0     MOV 0xEDA, W0
003E82  900010     MOV [W0+2], W0
003E84  980029     MOV W9, [W0+4]
3870:                              usbDeviceInfo.pInterfaceList->pInterfaceSettings->pEndpointList = pTempEndpoint;
003E86  8076D0     MOV 0xEDA, W0
003E88  900010     MOV [W0+2], W0
003E8A  980028     MOV W8, [W0+4]
3871:                          }
3872:                          USB_FREE_AND_CLEAR(usbDeviceInfo.pInterfaceList->pInterfaceSettings);
003E96  780001     MOV W1, W0
003E98  07E2B6     RCALL _free
003E9A  EB0000     CLR W0
003E9C  8076D1     MOV 0xEDA, W1
003E9E  980090     MOV W0, [W1+2]
3873:                          usbDeviceInfo.pInterfaceList->pInterfaceSettings = pTempSetting;
003EA0  8076D0     MOV 0xEDA, W0
003EA2  98001A     MOV W10, [W0+2]
3874:                      }
3875:                      USB_FREE_AND_CLEAR(usbDeviceInfo.pInterfaceList);
003EAC  07E2AC     RCALL _free
3876:                      usbDeviceInfo.pInterfaceList = pTempInterface;
003EAE  8876DB     MOV W11, 0xEDA
3877:                  }
3878:              
3879:                  pCurrentEndpoint = usbDeviceInfo.pEndpoint0;
003EB4  8076E0     MOV 0xEDC, W0
003EB6  887630     MOV W0, pCurrentEndpoint
3880:              
3881:              } // _USB_FreeConfigMemory
003EB8  BE054F     MOV.D [--W15], W10
003EBA  BE044F     MOV.D [--W15], W8
003EBC  060000     RETURN
3882:              
3883:              /****************************************************************************
3884:                Function:
3885:                  void _USB_FreeMemory( void )
3886:              
3887:                Description:
3888:                  This function frees all memory that can be freed.  Only the EP0
3889:                  information block is retained.
3890:              
3891:                Precondition:
3892:                  None
3893:              
3894:                Parameters:
3895:                  None - None
3896:              
3897:                Returns:
3898:                  None
3899:              
3900:                Remarks:
3901:                  None
3902:               ***************************************************************************/
3903:              
3904:              void _USB_FreeMemory(void) {
003EBE  781F88     MOV W8, [W15++]
3905:                  BYTE *pTemp;
3906:              
3907:                  while (usbDeviceInfo.pConfigurationDescriptorList != NULL) {
003EC0  8076C0     MOV 0xED8, W0
003EC2  E00000     CP0 W0
003EC4  32000B     BRA Z, 0x3EDC
003ED8  E00008     CP0 W8
003EDA  3AFFF5     BRA NZ, 0x3EC6
3908:                      pTemp = (BYTE *) usbDeviceInfo.pConfigurationDescriptorList->next;
003EC6  900410     MOV [W0+2], W8
3909:                      USB_FREE_AND_CLEAR(usbDeviceInfo.pConfigurationDescriptorList->descriptor);
003EC8  780010     MOV [W0], W0
003ECA  07E29D     RCALL _free
003ECC  8076C0     MOV 0xED8, W0
003ECE  EB0800     CLR [W0]
3910:                      USB_FREE_AND_CLEAR(usbDeviceInfo.pConfigurationDescriptorList);
003ED0  8076C0     MOV 0xED8, W0
003ED2  07E299     RCALL _free
3911:                      usbDeviceInfo.pConfigurationDescriptorList = (USB_CONFIGURATION *) pTemp;
003ED4  780008     MOV W8, W0
003ED6  8876C8     MOV W8, 0xED8
3912:                  }
3913:                  if (pDeviceDescriptor != NULL) {
003EDC  8078E0     MOV 0xF1C, W0
003EDE  E00000     CP0 W0
003EE0  320002     BRA Z, 0x3EE6
3914:                      USB_FREE_AND_CLEAR(pDeviceDescriptor);
003EE2  07E291     RCALL _free
003EE4  EF2F1C     CLR 0xF1C
3915:                  }
3916:                  if (pEP0Data != NULL) {
003EE6  8075D0     MOV pEP0Data, W0
003EE8  E00000     CP0 W0
003EEA  320002     BRA Z, 0x3EF0
3917:                      USB_FREE_AND_CLEAR(pEP0Data);
003EEC  07E28C     RCALL _free
003EEE  EF2EBA     CLR pEP0Data
3918:                  }
3919:              
3920:                  _USB_FreeConfigMemory();
003EF0  07FFB4     RCALL _USB_FreeConfigMemory
3921:              
3922:              }
003EF2  78044F     MOV [--W15], W8
003EF4  060000     RETURN
3923:              
3924:              /****************************************************************************
3925:                Function:
3926:                  void _USB_InitControlRead( USB_ENDPOINT_INFO *pEndpoint,
3927:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
3928:                                      WORD size )
3929:              
3930:                Description:
3931:                  This function sets up the endpoint information for a control (SETUP)
3932:                  transfer that will read information.
3933:              
3934:                Precondition:
3935:                  All error checking must be done prior to calling this function.
3936:              
3937:                Parameters:
3938:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
3939:                                                      in the endpoint information list.
3940:                  BYTE *pControlData              - Points to the SETUP message.
3941:                  WORD controlSize                - Size of the SETUP message.
3942:                  BYTE *pData                     - Points to where the read data
3943:                                                      is to be stored.
3944:                  WORD size                       - Number of data bytes to read.
3945:              
3946:                Returns:
3947:                  None
3948:              
3949:                Remarks:
3950:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
3951:                  flag must be set last.
3952:               ***************************************************************************/
3953:              
3954:              void _USB_InitControlRead(USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData, WORD controlSize,
3955:                      BYTE *pData, WORD size) {
3956:                  pEndpoint->status.bfStalled = 0;
003EF6  9042A0     MOV.B [W0+2], W5
003EF8  A15405     BCLR.B W5, #5
003EFA  984025     MOV.B W5, [W0+2]
3957:                  pEndpoint->status.bfError = 0;
003EFC  9042A0     MOV.B [W0+2], W5
003EFE  A16405     BCLR.B W5, #6
003F00  984025     MOV.B W5, [W0+2]
3958:                  pEndpoint->status.bfUserAbort = 0;
003F02  9042A0     MOV.B [W0+2], W5
003F04  A17405     BCLR.B W5, #7
003F06  984025     MOV.B W5, [W0+2]
3959:                  pEndpoint->status.bfTransferSuccessful = 0;
003F08  9042B0     MOV.B [W0+3], W5
003F0A  A10405     BCLR.B W5, #0
003F0C  984035     MOV.B W5, [W0+3]
3960:                  pEndpoint->status.bfErrorCount = 0;
003F0E  9042A0     MOV.B [W0+2], W5
003F10  B3CE06     MOV.B #0xE0, W6
003F12  62C286     AND.B W5, W6, W5
003F14  984025     MOV.B W5, [W0+2]
3961:                  pEndpoint->status.bfLastTransferNAKd = 0;
003F16  9042B0     MOV.B [W0+3], W5
003F18  A14405     BCLR.B W5, #4
003F1A  984035     MOV.B W5, [W0+3]
3962:                  pEndpoint->pUserData = pData;
003F1C  980833     MOV W3, [W0+22]
3963:                  pEndpoint->dataCount = 0;
003F1E  B83360     MUL.UU W6, #0, W6
003F20  980806     MOV W6, [W0+16]
003F22  980817     MOV W7, [W0+18]
3964:                  pEndpoint->dataCountMax = size;
003F24  200005     MOV #0x0, W5
003F26  980054     MOV W4, [W0+10]
003F28  980065     MOV W5, [W0+12]
3965:                  pEndpoint->countNAKs = 0;
003F2A  EB0180     CLR W3
003F2C  980873     MOV W3, [W0+30]
3966:              
3967:                  pEndpoint->pUserDataSETUP = pControlData;
003F2E  980821     MOV W1, [W0+20]
3968:                  pEndpoint->dataCountMaxSETUP = controlSize;
003F30  980072     MOV W2, [W0+14]
3969:                  pEndpoint->transferState = TSTATE_CONTROL_READ;
003F32  B3C201     MOV.B #0x20, W1
003F34  985801     MOV.B W1, [W0+24]
3970:              
3971:                  // Set the flag last so all the parameters are set for an interrupt.
3972:                  pEndpoint->status.bfTransferComplete = 0;
003F36  9040B0     MOV.B [W0+3], W1
003F38  A11401     BCLR.B W1, #1
003F3A  984031     MOV.B W1, [W0+3]
3973:              }
003F3C  060000     RETURN
3974:              
3975:              /****************************************************************************
3976:                Function:
3977:                  void _USB_InitControlWrite( USB_ENDPOINT_INFO *pEndpoint,
3978:                                      BYTE *pControlData, WORD controlSize, BYTE *pData,
3979:                                      WORD size )
3980:              
3981:                Description:
3982:                  This function sets up the endpoint information for a control (SETUP)
3983:                  transfer that will write information.
3984:              
3985:                Precondition:
3986:                  All error checking must be done prior to calling this function.
3987:              
3988:                Parameters:
3989:                  USB_ENDPOINT_INFO *pEndpoint    - Points to the desired endpoint
3990:                                                                    in the endpoint information list.
3991:                  BYTE *pControlData              - Points to the SETUP message.
3992:                  WORD controlSize                - Size of the SETUP message.
3993:                  BYTE *pData                     - Points to where the write data
3994:                                                                    is to be stored.
3995:                  WORD size                       - Number of data bytes to write.
3996:              
3997:                Returns:
3998:                  None
3999:              
4000:                Remarks:
4001:                  Since endpoint servicing is interrupt driven, the bfTransferComplete
4002:                  flag must be set last.
4003:               ***************************************************************************/
4004:              
4005:              void _USB_InitControlWrite(USB_ENDPOINT_INFO *pEndpoint, BYTE *pControlData,
4006:                      WORD controlSize, BYTE *pData, WORD size) {
003F3E  781F88     MOV W8, [W15++]
003F40  780400     MOV W0, W8
4007:                  pEndpoint->status.bfStalled = 0;
003F42  904020     MOV.B [W0+2], W0
003F44  A15400     BCLR.B W0, #5
003F46  984420     MOV.B W0, [W8+2]
4008:                  pEndpoint->status.bfError = 0;
003F48  904028     MOV.B [W8+2], W0
003F4A  A16400     BCLR.B W0, #6
003F4C  984420     MOV.B W0, [W8+2]
4009:                  pEndpoint->status.bfUserAbort = 0;
003F4E  904028     MOV.B [W8+2], W0
003F50  A17400     BCLR.B W0, #7
003F52  984420     MOV.B W0, [W8+2]
4010:                  pEndpoint->status.bfTransferSuccessful = 0;
003F54  904038     MOV.B [W8+3], W0
003F56  A10400     BCLR.B W0, #0
003F58  984430     MOV.B W0, [W8+3]
4011:                  pEndpoint->status.bfErrorCount = 0;
003F5A  904028     MOV.B [W8+2], W0
003F5C  B3CE05     MOV.B #0xE0, W5
003F5E  604005     AND.B W0, W5, W0
003F60  984420     MOV.B W0, [W8+2]
4012:                  pEndpoint->status.bfLastTransferNAKd = 0;
003F62  904038     MOV.B [W8+3], W0
003F64  A14400     BCLR.B W0, #4
003F66  984430     MOV.B W0, [W8+3]
4013:                  pEndpoint->pUserData = pData;
003F68  980C33     MOV W3, [W8+22]
4014:                  pEndpoint->dataCount = 0;
003F6A  B83360     MUL.UU W6, #0, W6
003F6C  980C06     MOV W6, [W8+16]
003F6E  980C17     MOV W7, [W8+18]
4015:                  pEndpoint->dataCountMax = size;
003F70  B82361     MUL.UU W4, #1, W6
003F72  980456     MOV W6, [W8+10]
003F74  980467     MOV W7, [W8+12]
4016:                  pEndpoint->countNAKs = 0;
003F76  EB0000     CLR W0
003F78  980C70     MOV W0, [W8+30]
4017:              
4018:                  pEndpoint->pUserDataSETUP = pControlData;
003F7A  980C21     MOV W1, [W8+20]
4019:                  pEndpoint->dataCountMaxSETUP = controlSize;
003F7C  980472     MOV W2, [W8+14]
4020:              
4021:                  if (size == 0) {
003F7E  E00004     CP0 W4
003F80  3A0003     BRA NZ, 0x3F88
4022:                      pEndpoint->transferState = TSTATE_CONTROL_NO_DATA;
003F82  B3C100     MOV.B #0x10, W0
003F84  985C00     MOV.B W0, [W8+24]
003F86  370002     BRA 0x3F8C
4023:                  } else {
4024:                      pEndpoint->transferState = TSTATE_CONTROL_WRITE;
003F88  B3C300     MOV.B #0x30, W0
003F8A  985C00     MOV.B W0, [W8+24]
4025:                  }
4026:              
4027:                  // Set the flag last so all the parameters are set for an interrupt.
4028:                  pEndpoint->status.bfTransferComplete = 0;
003F8C  904038     MOV.B [W8+3], W0
003F8E  A11400     BCLR.B W0, #1
003F90  984430     MOV.B W0, [W8+3]
4029:              }
003F92  78044F     MOV [--W15], W8
003F94  060000     RETURN
4030:              
4031:              /****************************************************************************
4032:                Function:
4033:                  void _USB_InitRead( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4034:                                      WORD size )
4035:              
4036:                Description:
4037:                  This function sets up the endpoint information for an interrupt,
4038:                  isochronous, or bulk read.  If the transfer is isochronous, the pData
4039:                  and size parameters have different meaning.
4040:              
4041:                Precondition:
4042:                  All error checking must be done prior to calling this function.
4043:              
4044:                Parameters:
4045:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4046:                                                  endpoint information list.
4047:                  BYTE *pData                   - Points to where the data is to be
4048:                                                  stored.  If the endpoint is isochronous,
4049:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4050:                                                  structure.
4051:                  WORD size                     - Number of data bytes to read. If the
4052:                                                  endpoint is isochronous, this is the number
4053:                                                  of data buffer pointers pointed to by
4054:                                                  pData.
4055:              
4056:                Returns:
4057:                  None
4058:              
4059:                Remarks:
4060:               * Control reads should use the routine _USB_InitControlRead().  Since
4061:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4062:                      must be set last.
4063:              
4064:               * For interrupt and isochronous endpoints, we let the interval count
4065:                      free run.  The transaction will begin when the interval count
4066:                      reaches 0.
4067:               ***************************************************************************/
4068:              
4069:              void _USB_InitRead(USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size) {
003F96  780180     MOV W0, W3
003F98  780202     MOV W2, W4
4070:                  pEndpoint->status.bfUserAbort = 0;
003F9A  904020     MOV.B [W0+2], W0
003F9C  A17400     BCLR.B W0, #7
003F9E  9841A0     MOV.B W0, [W3+2]
4071:                  pEndpoint->status.bfTransferSuccessful = 0;
003FA0  904033     MOV.B [W3+3], W0
003FA2  A10400     BCLR.B W0, #0
003FA4  9841B0     MOV.B W0, [W3+3]
4072:                  pEndpoint->status.bfErrorCount = 0;
003FA6  904023     MOV.B [W3+2], W0
003FA8  B3CE02     MOV.B #0xE0, W2
003FAA  604002     AND.B W0, W2, W0
003FAC  9841A0     MOV.B W0, [W3+2]
4073:                  pEndpoint->status.bfLastTransferNAKd = 0;
003FAE  904033     MOV.B [W3+3], W0
003FB0  A14400     BCLR.B W0, #4
003FB2  9841B0     MOV.B W0, [W3+3]
4074:                  pEndpoint->pUserData = pData;
003FB4  9809B1     MOV W1, [W3+22]
4075:                  pEndpoint->dataCount = 0;
003FB6  B80060     MUL.UU W0, #0, W0
003FB8  980980     MOV W0, [W3+16]
003FBA  980991     MOV W1, [W3+18]
4076:                  pEndpoint->dataCountMax = size; // Not used for isochronous.
003FBC  B82061     MUL.UU W4, #1, W0
003FBE  9801D0     MOV W0, [W3+10]
003FC0  9801E1     MOV W1, [W3+12]
4077:                  pEndpoint->countNAKs = 0;
003FC2  EB0000     CLR W0
003FC4  9809F0     MOV W0, [W3+30]
4078:              
4079:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) {
003FC6  9008D3     MOV [W3+26], W1
003FC8  203000     MOV #0x300, W0
003FCA  608080     AND W1, W0, W1
003FCC  508F80     SUB W1, W0, [W15]
003FCE  3A0003     BRA NZ, 0x3FD6
4080:                      pEndpoint->transferState = TSTATE_INTERRUPT_READ;
003FD0  B3C400     MOV.B #0x40, W0
003FD2  985980     MOV.B W0, [W3+24]
003FD4  37000B     BRA 0x3FEC
4081:                  } else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
003FD6  201000     MOV #0x100, W0
003FD8  508F80     SUB W1, W0, [W15]
003FDA  3A0006     BRA NZ, 0x3FE8
4082:                      pEndpoint->transferState = TSTATE_ISOCHRONOUS_READ;
003FDC  B3C600     MOV.B #0x60, W0
003FDE  985980     MOV.B W0, [W3+24]
4083:                      ((ISOCHRONOUS_DATA *) pEndpoint->pUserData)->currentBufferUSB = 0;
003FE0  9008B3     MOV [W3+22], W1
003FE2  EB4000     CLR.B W0
003FE4  984090     MOV.B W0, [W1+1]
003FE6  370002     BRA 0x3FEC
4084:                  } else // Bulk
4085:                  {
4086:                      pEndpoint->transferState = TSTATE_BULK_READ;
003FE8  B3C800     MOV.B #0x80, W0
003FEA  985980     MOV.B W0, [W3+24]
4087:                  }
4088:              
4089:                  // Set the flag last so all the parameters are set for an interrupt.
4090:                  pEndpoint->status.bfTransferComplete = 0;
003FEC  904033     MOV.B [W3+3], W0
003FEE  A11400     BCLR.B W0, #1
003FF0  9841B0     MOV.B W0, [W3+3]
4091:              }
003FF2  060000     RETURN
4092:              
4093:              /****************************************************************************
4094:                Function:
4095:                  void _USB_InitWrite( USB_ENDPOINT_INFO *pEndpoint, BYTE *pData,
4096:                                          WORD size )
4097:              
4098:                Description:
4099:                  This function sets up the endpoint information for an interrupt,
4100:                  isochronous, or bulk  write.  If the transfer is isochronous, the pData
4101:                  and size parameters have different meaning.
4102:              
4103:                Precondition:
4104:                  All error checking must be done prior to calling this function.
4105:              
4106:                Parameters:
4107:                  USB_ENDPOINT_INFO *pEndpoint  - Points to the desired endpoint in the
4108:                                                  endpoint information list.
4109:                  BYTE *pData                   - Points to where the data to send is
4110:                                                  stored.  If the endpoint is isochronous,
4111:                                                  this points to an ISOCHRONOUS_DATA_BUFFERS
4112:                                                  structure.
4113:                  WORD size                     - Number of data bytes to write.  If the
4114:                                                  endpoint is isochronous, this is the number
4115:                                                  of data buffer pointers pointed to by
4116:                                                  pData.
4117:              
4118:                Returns:
4119:                  None
4120:              
4121:                Remarks:
4122:               * Control writes should use the routine _USB_InitControlWrite().  Since
4123:                      endpoint servicing is interrupt driven, the bfTransferComplete flag
4124:                      must be set last.
4125:              
4126:               * For interrupt and isochronous endpoints, we let the interval count
4127:                      free run.  The transaction will begin when the interval count
4128:                      reaches 0.
4129:               ***************************************************************************/
4130:              
4131:              void _USB_InitWrite(USB_ENDPOINT_INFO *pEndpoint, BYTE *pData, WORD size) {
003FF4  780180     MOV W0, W3
003FF6  780202     MOV W2, W4
4132:                  pEndpoint->status.bfUserAbort = 0;
003FF8  904020     MOV.B [W0+2], W0
003FFA  A17400     BCLR.B W0, #7
003FFC  9841A0     MOV.B W0, [W3+2]
4133:                  pEndpoint->status.bfTransferSuccessful = 0;
003FFE  904033     MOV.B [W3+3], W0
004000  A10400     BCLR.B W0, #0
004002  9841B0     MOV.B W0, [W3+3]
4134:                  pEndpoint->status.bfErrorCount = 0;
004004  904023     MOV.B [W3+2], W0
004006  B3CE02     MOV.B #0xE0, W2
004008  604002     AND.B W0, W2, W0
00400A  9841A0     MOV.B W0, [W3+2]
4135:                  pEndpoint->status.bfLastTransferNAKd = 0;
00400C  904033     MOV.B [W3+3], W0
00400E  A14400     BCLR.B W0, #4
004010  9841B0     MOV.B W0, [W3+3]
4136:                  pEndpoint->pUserData = pData;
004012  9809B1     MOV W1, [W3+22]
4137:                  pEndpoint->dataCount = 0;
004014  B80060     MUL.UU W0, #0, W0
004016  980980     MOV W0, [W3+16]
004018  980991     MOV W1, [W3+18]
4138:                  pEndpoint->dataCountMax = size; // Not used for isochronous.
00401A  B82061     MUL.UU W4, #1, W0
00401C  9801D0     MOV W0, [W3+10]
00401E  9801E1     MOV W1, [W3+12]
4139:                  pEndpoint->countNAKs = 0;
004020  EB0000     CLR W0
004022  9809F0     MOV W0, [W3+30]
4140:              
4141:                  if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) {
004024  9008D3     MOV [W3+26], W1
004026  203000     MOV #0x300, W0
004028  608080     AND W1, W0, W1
00402A  508F80     SUB W1, W0, [W15]
00402C  3A0003     BRA NZ, 0x4034
4142:                      pEndpoint->transferState = TSTATE_INTERRUPT_WRITE;
00402E  B3C500     MOV.B #0x50, W0
004030  985980     MOV.B W0, [W3+24]
004032  37000B     BRA 0x404A
4143:                  } else if (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
004034  201000     MOV #0x100, W0
004036  508F80     SUB W1, W0, [W15]
004038  3A0006     BRA NZ, 0x4046
4144:                      pEndpoint->transferState = TSTATE_ISOCHRONOUS_WRITE;
00403A  B3C700     MOV.B #0x70, W0
00403C  985980     MOV.B W0, [W3+24]
4145:                      ((ISOCHRONOUS_DATA *) pEndpoint->pUserData)->currentBufferUSB = 0;
00403E  9008B3     MOV [W3+22], W1
004040  EB4000     CLR.B W0
004042  984090     MOV.B W0, [W1+1]
004044  370002     BRA 0x404A
4146:                  } else // Bulk
4147:                  {
4148:                      pEndpoint->transferState = TSTATE_BULK_WRITE;
004046  B3C900     MOV.B #0x90, W0
004048  985980     MOV.B W0, [W3+24]
4149:                  }
4150:              
4151:                  // Set the flag last so all the parameters are set for an interrupt.
4152:                  pEndpoint->status.bfTransferComplete = 0;
00404A  904033     MOV.B [W3+3], W0
00404C  A11400     BCLR.B W0, #1
00404E  9841B0     MOV.B W0, [W3+3]
4153:              }
004050  060000     RETURN
4154:              
4155:              /****************************************************************************
4156:                Function:
4157:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4158:                              unsigned int size )
4159:              
4160:                Description:
4161:                  This routine notifies all active client drivers for the given device of
4162:                  the given event.
4163:              
4164:                Precondition:
4165:                  None
4166:              
4167:                Parameters:
4168:                  BYTE address        - Address of the device generating the event
4169:                  USB_EVENT event     - Event ID
4170:                  void *data          - Pointer to event data
4171:                  unsigned int size   - Size of data pointed to by data
4172:              
4173:                Returns:
4174:                  None
4175:              
4176:                Remarks:
4177:                  When this driver is modified to support multiple devices, this function
4178:                  will require modification.
4179:               ***************************************************************************/
4180:              
4181:              void _USB_NotifyClients(BYTE address, USB_EVENT event, void *data, unsigned int size) {
004052  BE9F88     MOV.D W8, [W15++]
004054  BE9F8A     MOV.D W10, [W15++]
004056  BE9F8C     MOV.D W12, [W15++]
004058  784680     MOV.B W0, W13
00405A  780481     MOV W1, W9
00405C  BE0502     MOV.D W2, W10
4182:                  USB_INTERFACE_INFO *pInterface;
4183:              
4184:                  // Some events go to all drivers, some only to specific drivers.
4185:                  switch (event) {
00405E  200720     MOV #0x72, W0
004060  508F80     SUB W1, W0, [W15]
004062  320003     BRA Z, 0x406A
004064  27FFF0     MOV #0x7FFF, W0
004066  508F80     SUB W1, W0, [W15]
004068  3A000E     BRA NZ, 0x4086
4186:                      case EVENT_TRANSFER:
4187:                      case EVENT_BUS_ERROR:
4188:                          if (((HOST_TRANSFER_DATA *) data)->clientDriver != CLIENT_DRIVER_HOST) {
00406A  90481A     MOV.B [W10+9], W0
00406C  404FE1     ADD.B W0, #0x1, [W15]
00406E  32001C     BRA Z, 0x40A8
4189:                              usbClientDrvTable[((HOST_TRANSFER_DATA *) data)->clientDriver].EventHandler(address, event, data, size);
004070  B3C0A2     MOV.B #0xA, W2
004072  BC4004     MUL.B WREG2
004074  E88102     INC2 W2, W2
004076  20DF60     MOV #0xDF6, W0
004078  7801E2     MOV [W2+W0], W3
00407A  B85A61     MUL.UU W11, #1, W4
00407C  78010A     MOV W10, W2
00407E  780089     MOV W9, W1
004080  78400D     MOV.B W13, W0
004082  010003     CALL W3
004084  370011     BRA 0x40A8
4190:                          }
4191:                          break;
4192:                      default:
4193:                          pInterface = usbDeviceInfo.pInterfaceList;
004086  8076D8     MOV 0xEDA, W8
4194:                          while (pInterface != NULL) // Scan the interface list for all active drivers.
004088  E00008     CP0 W8
00408A  32000E     BRA Z, 0x40A8
00408C  20DF6C     MOV #0xDF6, W12
0040A4  E00008     CP0 W8
0040A6  3AFFF3     BRA NZ, 0x408E
4195:                          {
4196:                              usbClientDrvTable[pInterface->clientDriver].EventHandler(address, event, data, size);
00408E  904078     MOV.B [W8+7], W0
004090  B3C0A2     MOV.B #0xA, W2
004092  BC4004     MUL.B WREG2
004094  E88102     INC2 W2, W2
004096  7E01E2     MOV [W2+W12], W3
004098  B85A61     MUL.UU W11, #1, W4
00409A  78010A     MOV W10, W2
00409C  780089     MOV W9, W1
00409E  78400D     MOV.B W13, W0
0040A0  010003     CALL W3
4197:                              pInterface = pInterface->next;
0040A2  780418     MOV [W8], W8
4198:                          }
4199:                          break;
4200:                  }
4201:              } // _USB_NotifyClients
0040A8  BE064F     MOV.D [--W15], W12
0040AA  BE054F     MOV.D [--W15], W10
0040AC  BE044F     MOV.D [--W15], W8
0040AE  060000     RETURN
4202:              
4203:              /****************************************************************************
4204:                Function:
4205:                  void _USB_NotifyClients( BYTE address, USB_EVENT event, void *data,
4206:                              unsigned int size )
4207:              
4208:                Description:
4209:                  This routine notifies all active client drivers for the given device of
4210:                  the given event.
4211:              
4212:                Precondition:
4213:                  None
4214:              
4215:                Parameters:
4216:                  BYTE address        - Address of the device generating the event
4217:                  USB_EVENT event     - Event ID
4218:                  void *data          - Pointer to event data
4219:                  unsigned int size   - Size of data pointed to by data
4220:              
4221:                Returns:
4222:                  None
4223:              
4224:                Remarks:
4225:                  When this driver is modified to support multiple devices, this function
4226:                  will require modification.
4227:               ***************************************************************************/
4228:              
4229:              void _USB_NotifyDataClients(BYTE address, USB_EVENT event, void *data, unsigned int size) {
0040B0  BE9F88     MOV.D W8, [W15++]
0040B2  BE9F8A     MOV.D W10, [W15++]
0040B4  BE9F8C     MOV.D W12, [W15++]
0040B6  784600     MOV.B W0, W12
0040B8  780581     MOV W1, W11
0040BA  780502     MOV W2, W10
0040BC  780483     MOV W3, W9
4230:                  USB_INTERFACE_INFO *pInterface;
4231:              
4232:                  // Some events go to all drivers, some only to specific drivers.
4233:                  switch (event) {
4234:                      default:
4235:                          pInterface = usbDeviceInfo.pInterfaceList;
0040BE  8076D8     MOV 0xEDA, W8
4236:                          while (pInterface != NULL) // Scan the interface list for all active drivers.
0040C0  E00008     CP0 W8
0040C2  32000E     BRA Z, 0x40E0
0040C4  20DF6D     MOV #0xDF6, W13
0040DC  E00008     CP0 W8
0040DE  3AFFF3     BRA NZ, 0x40C6
4237:                          {
4238:                              usbClientDrvTable[pInterface->clientDriver].DataEventHandler(address, event, data, size);
0040C6  904078     MOV.B [W8+7], W0
0040C8  B3C0A2     MOV.B #0xA, W2
0040CA  BC4004     MUL.B WREG2
0040CC  410164     ADD W2, #0x4, W2
0040CE  7E81E2     MOV [W2+W13], W3
0040D0  B84A61     MUL.UU W9, #1, W4
0040D2  78010A     MOV W10, W2
0040D4  78008B     MOV W11, W1
0040D6  78400C     MOV.B W12, W0
0040D8  010003     CALL W3
4239:                              pInterface = pInterface->next;
0040DA  780418     MOV [W8], W8
4240:                          }
4241:                          break;
4242:                  }
4243:              } // _USB_NotifyClients
0040E0  BE064F     MOV.D [--W15], W12
0040E2  BE054F     MOV.D [--W15], W10
0040E4  BE044F     MOV.D [--W15], W8
0040E6  060000     RETURN
4244:              
4245:              /****************************************************************************
4246:                Function:
4247:                  void _USB_NotifyAllDataClients( BYTE address, USB_EVENT event, void *data,
4248:                              unsigned int size )
4249:              
4250:                Description:
4251:                  This routine notifies all client drivers (active or not) for the given device of
4252:                  the given event.
4253:              
4254:                Precondition:
4255:                  None
4256:              
4257:                Parameters:
4258:                  BYTE address        - Address of the device generating the event
4259:                  USB_EVENT event     - Event ID
4260:                  void *data          - Pointer to event data
4261:                  unsigned int size   - Size of data pointed to by data
4262:              
4263:                Returns:
4264:                  None
4265:              
4266:                Remarks:
4267:                  When this driver is modified to support multiple devices, this function
4268:                  will require modification.
4269:               ***************************************************************************/
4270:              #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
4271:              
4272:              void _USB_NotifyAllDataClients(BYTE address, USB_EVENT event, void *data, unsigned int size) {
4273:                  WORD i;
4274:              
4275:                  // Some events go to all drivers, some only to specific drivers.
4276:                  switch (event) {
4277:                      default:
4278:                          for (i = 0; i < NUM_CLIENT_DRIVER_ENTRIES; i++) {
4279:                              usbClientDrvTable[i].DataEventHandler(address, event, data, size);
4280:                          }
4281:                          break;
4282:                  }
4283:              } // _USB_NotifyClients
4284:              #endif
4285:              
4286:              /****************************************************************************
4287:                Function:
4288:                  BOOL _USB_ParseConfigurationDescriptor( void )
4289:              
4290:                Description:
4291:                  This function parses all the endpoint descriptors for the required
4292:                  setting of the required interface and sets up the internal endpoint
4293:                  information.
4294:              
4295:                Precondition:
4296:                  pCurrentConfigurationDescriptor points to a valid Configuration
4297:                  Descriptor, which contains the endpoint descriptors.  The current
4298:                  interface and the current interface settings must be set up in
4299:                  usbDeviceInfo.
4300:              
4301:                Parameters:
4302:                  None - None
4303:              
4304:                Returns:
4305:                  TRUE    - Successful
4306:                  FALSE   - Configuration not supported.
4307:              
4308:                Remarks:
4309:               * This function also automatically resets all endpoints (except
4310:                      endpoint 0) to DATA0, so _USB_ResetDATA0 does not have to be
4311:                      called.
4312:              
4313:               * If the configuration is not supported, the caller will need to clean
4314:                      up, freeing memory by calling _USB_FreeConfigMemory.
4315:              
4316:               * We do not currently implement checks for descriptors that are shorter
4317:                      than the expected length, in the case of invalid USB Peripherals.
4318:              
4319:               * If there is not enough available heap space for storing the
4320:                      interface or endpoint information, this function will return FALSE.
4321:                      Currently, there is no other mechanism for informing the user of
4322:                      an out of dynamic memory condition.
4323:              
4324:               * We are assuming that we can support a single interface on a single
4325:                      device.  When the driver is modified to support multiple devices,
4326:                      each endpoint should be checked to ensure that we have enough
4327:                      bandwidth to support it.
4328:               ***************************************************************************/
4329:              
4330:              BOOL _USB_ParseConfigurationDescriptor(void) {
0040E8  4787EC     ADD W15, #0xC, W15
0040EA  BE9F88     MOV.D W8, [W15++]
0040EC  BE9F8A     MOV.D W10, [W15++]
0040EE  BE9F8C     MOV.D W12, [W15++]
0040F0  781F8E     MOV W14, [W15++]
4331:                  BYTE bAlternateSetting;
4332:                  BYTE bDescriptorType;
4333:                  BYTE bInterfaceNumber;
4334:                  BYTE bLength;
4335:                  BYTE bNumEndpoints;
4336:                  BYTE bNumInterfaces;
4337:                  BYTE bMaxPower;
4338:                  BOOL error;
4339:                  BYTE Class;
4340:                  BYTE SubClass;
4341:                  BYTE Protocol;
4342:                  BYTE ClientDriver;
4343:                  WORD wTotalLength;
4344:              
4345:                  BYTE currentAlternateSetting;
4346:                  BYTE currentConfiguration;
4347:                  BYTE currentEndpoint;
4348:                  BYTE currentInterface;
4349:                  WORD index;
4350:                  USB_ENDPOINT_INFO *newEndpointInfo;
4351:                  USB_INTERFACE_INFO *newInterfaceInfo;
4352:                  USB_INTERFACE_SETTING_INFO *newSettingInfo;
4353:                  USB_VBUS_POWER_EVENT_DATA powerRequest;
4354:                  USB_INTERFACE_INFO *pTempInterfaceList;
4355:                  BYTE *ptr;
4356:              
4357:                  // Prime the loops.
4358:                  currentEndpoint = 0;
4359:                  error = FALSE;
4360:                  index = 0;
4361:                  ptr = pCurrentConfigurationDescriptor;
0040F2  8078D2     MOV 0xF1A, W2
4362:                  currentInterface = 0;
4363:                  currentAlternateSetting = 0;
4364:                  pTempInterfaceList = usbDeviceInfo.pInterfaceList; // Don't set until everything is in place.
0040F4  8076D9     MOV 0xEDA, W9
4365:              
4366:                  // Assume no OTG support (determine otherwise, below).
4367:                  usbDeviceInfo.flags.bfSupportsOTG = 0;
0040F6  A92EDE     BCLR 0xEDE, #1
4368:                  usbDeviceInfo.flags.bfConfiguredOTG = 1;
0040F8  A84EDE     BSET 0xEDE, #2
4369:              
4370:              #ifdef USB_SUPPORT_OTG
4371:                  usbDeviceInfo.flags.bfAllowHNP = 1; //Allow HNP From Host
4372:              #endif
4373:              
4374:                  // Load up the values from the Configuration Descriptor
4375:                  bLength = *ptr++;
0040FA  784412     MOV.B [W2], W8
4376:                  bDescriptorType = *ptr++;
4377:                  wTotalLength = *ptr++; // In case these are not word aligned
0040FC  9040A2     MOV.B [W2+2], W1
0040FE  FB8081     ZE W1, W1
4378:                  wTotalLength += (*ptr++) << 8;
004100  904032     MOV.B [W2+3], W0
004102  DD0048     SL W0, #8, W0
004104  408700     ADD W1, W0, W14
4379:                  bNumInterfaces = *ptr++;
4380:                  currentConfiguration = *ptr++; // bConfigurationValue
004106  904052     MOV.B [W2+5], W0
004108  9FEFE0     MOV.B W0, [W15-18]
4381:                  ptr++; // iConfiguration
4382:                  ptr++; // bmAttributes
4383:                  bMaxPower = *ptr;
00410A  904902     MOV.B [W2+8], W2
00410C  9FEFF2     MOV.B W2, [W15-17]
4384:              
4385:                  // Check Max Power to see if we can support this configuration.
4386:                  powerRequest.current = bMaxPower;
00410E  578177     SUB W15, #0x17, W2
004110  97E8FF     MOV.B [W15-17], W1
004112  984111     MOV.B W1, [W2+1]
4387:                  powerRequest.port = 0; // Port 0
004114  EB4900     CLR.B [W2]
4388:                  if (!USB_HOST_APP_EVENT_HANDLER(USB_ROOT_HUB, EVENT_VBUS_REQUEST_POWER,
004116  200024     MOV #0x2, W4
004118  200005     MOV #0x0, W5
00411A  200691     MOV #0x69, W1
00411C  EBC000     SETM.B W0
00411E  071D2F     RCALL USB_ApplicationEventHandler
004120  EB0200     CLR W4
004122  E00000     CP0 W0
004124  3A0003     BRA NZ, 0x412C
4389:                          &powerRequest, sizeof (USB_VBUS_POWER_EVENT_DATA))) {
4390:                      usbDeviceInfo.errorCode = USB_ERROR_INSUFFICIENT_POWER;
004126  B3C280     MOV.B #0x28, W0
004128  B7EED4     MOV.B WREG, 0xED4
00412A  200014     MOV #0x1, W4
4391:                      error = TRUE;
4392:                  }
4393:              
4394:                  // Skip over the rest of the Configuration Descriptor
4395:                  index += bLength;
00412C  FB8088     ZE W8, W1
4396:                  ptr = &pCurrentConfigurationDescriptor[index];
00412E  8078D0     MOV 0xF1A, W0
004130  408400     ADD W1, W0, W8
4397:              
4398:                  while (!error && (index < wTotalLength)) {
004132  E00004     CP0 W4
004134  3A00CE     BRA NZ, 0x42D2
004136  780581     MOV W1, W11
004138  9FEFD4     MOV.B W4, [W15-19]
00413A  3700C5     BRA 0x42C6
0042C2  E00004     CP0 W4
0042C4  3A0006     BRA NZ, 0x42D2
0042C6  570F8B     SUB W14, W11, [W15]
0042C8  3EFF3B     BRA GTU, 0x4140
0042CA  370003     BRA 0x42D2
0042CC  570F8B     SUB W14, W11, [W15]
0042CE  3EFF38     BRA GTU, 0x4140
0042D0  EB0200     CLR W4
4399:                      // Check the descriptor length and type
4400:                      bLength = *ptr++;
004140  784618     MOV.B [W8], W12
4401:                      bDescriptorType = *ptr++;
004142  904098     MOV.B [W8+1], W1
004144  E88008     INC2 W8, W0
4402:              
4403:              
4404:                      // Find the OTG discriptor (if present)
4405:                      if (bDescriptorType == USB_DESCRIPTOR_OTG) {
004146  50CFE9     SUB.B W1, #0x9, [W15]
004148  3A000C     BRA NZ, 0x4162
4406:                          // We found an OTG Descriptor, so the device supports OTG.
4407:                          usbDeviceInfo.flags.bfSupportsOTG = 1;
00414A  A82EDE     BSET 0xEDE, #1
4408:                          usbDeviceInfo.attributesOTG = *ptr;
00414C  784010     MOV.B [W0], W0
00414E  B7EED1     MOV.B WREG, 0xED1
4409:              
4410:                          // See if we need to send the SET FEATURE command.  If we do,
4411:                          // clear the bConfiguredOTG flag.
4412:                          if ((usbDeviceInfo.attributesOTG & OTG_HNP_SUPPORT) && (usbDeviceInfo.flags.bfAllowHNP)) {
004150  A31800     BTST.Z W0, #1
004152  320005     BRA Z, 0x415E
004154  BFCEDE     MOV.B 0xEDE, WREG
004156  A33800     BTST.Z W0, #3
004158  320002     BRA Z, 0x415E
4413:                              usbDeviceInfo.flags.bfConfiguredOTG = 0;
00415A  A94EDE     BCLR 0xEDE, #2
00415C  370004     BRA 0x4166
4414:                          } else {
4415:                              usbDeviceInfo.flags.bfAllowHNP = 0;
00415E  A96EDE     BCLR 0xEDE, #3
004160  370002     BRA 0x4166
4416:                          }
4417:                      }
4418:              
4419:                      // Find an interface descriptor
4420:                      if (bDescriptorType != USB_DESCRIPTOR_INTERFACE) {
004162  50CFE4     SUB.B W1, #0x4, [W15]
004164  320005     BRA Z, 0x4170
4421:                          // Skip over the rest of the Descriptor
4422:                          index += bLength;
004166  FB800C     ZE W12, W0
004168  458580     ADD W11, W0, W11
4423:                          ptr = &pCurrentConfigurationDescriptor[index];
00416A  8078D0     MOV 0xF1A, W0
00416C  458400     ADD W11, W0, W8
00416E  3700AE     BRA 0x42CC
4424:                      } else {
4425:                          // Read some data from the interface descriptor
4426:                          bInterfaceNumber = *ptr++;
004170  784690     MOV.B [W0], W13
4427:                          bAlternateSetting = *ptr++;
004172  9040B8     MOV.B [W8+3], W1
004174  9FF791     MOV.B W1, [W15-15]
4428:                          bNumEndpoints = *ptr++;
004176  904048     MOV.B [W8+4], W0
004178  9FF780     MOV.B W0, [W15-16]
4429:                          Class = *ptr++;
00417A  904258     MOV.B [W8+5], W4
4430:                          SubClass = *ptr++;
00417C  9040E8     MOV.B [W8+6], W1
4431:                          Protocol = *ptr++;
00417E  904178     MOV.B [W8+7], W2
004180  440468     ADD W8, #0x8, W8
4432:              
4433:                          // Get client driver index
4434:                          if (usbDeviceInfo.flags.bfUseDeviceClientDriver) {
004182  BFCEDE     MOV.B 0xEDE, WREG
004184  A36800     BTST.Z W0, #6
004186  320003     BRA Z, 0x418E
4435:                              ClientDriver = usbDeviceInfo.deviceClientDriver;
004188  BFCED5     MOV.B 0xED5, WREG
00418A  9FEF80     MOV.B W0, [W15-24]
00418C  37000A     BRA 0x41A2
4436:                          } else {
4437:                              if (!_USB_FindClassDriver(Class, SubClass, Protocol, &ClientDriver)) {
00418E  5781F8     SUB W15, #0x18, W3
004190  784004     MOV.B W4, W0
004192  07F998     RCALL _USB_FindClassDriver
004194  E00000     CP0 W0
004196  3A0005     BRA NZ, 0x41A2
4438:                                  // If we cannot support this interface, skip it.
4439:                                  index += bLength;
004198  FB800C     ZE W12, W0
00419A  458580     ADD W11, W0, W11
4440:                                  ptr = &pCurrentConfigurationDescriptor[index];
00419C  8078D0     MOV 0xF1A, W0
00419E  458400     ADD W11, W0, W8
0041A0  370095     BRA 0x42CC
4441:                                  continue;
4442:                              }
4443:                          }
4444:              
4445:                          // We can support this interface.  See if we already have a USB_INTERFACE_INFO node for it.
4446:                          newInterfaceInfo = pTempInterfaceList;
4447:                          while ((newInterfaceInfo != NULL) && (newInterfaceInfo->interface != bInterfaceNumber)) {
0041A2  E00009     CP0 W9
0041A4  3A00CB     BRA NZ, 0x433C
0041A6  370008     BRA 0x41B8
0041A8  780509     MOV W9, W10
0041AC  E0000A     CP0 W10
0041AE  320004     BRA Z, 0x41B8
0041B0  90406A     MOV.B [W10+6], W0
0041B2  56CF80     SUB.B W13, W0, [W15]
0041B4  320010     BRA Z, 0x41D6
0041B6  37FFF9     BRA 0x41AA
00433C  904069     MOV.B [W9+6], W0
00433E  56CF80     SUB.B W13, W0, [W15]
004340  3AFF33     BRA NZ, 0x41A8
004342  37FF48     BRA 0x41D4
4448:                              newInterfaceInfo = newInterfaceInfo->next;
0041AA  78051A     MOV [W10], W10
4449:                          }
4450:                          if (newInterfaceInfo == NULL) {
4451:                              // This is the first instance of this interface, so create a new node for it.
4452:                              if ((newInterfaceInfo = (USB_INTERFACE_INFO *) USB_MALLOC(sizeof (USB_INTERFACE_INFO))) == NULL) {
0041B8  200080     MOV #0x8, W0
0041BA  07E093     RCALL _malloc
0041BC  780500     MOV W0, W10
0041BE  E00000     CP0 W0
0041C0  320075     BRA Z, 0x42AC
4453:                                  // Out of memory
4454:                                  error = TRUE;
4455:              
4456:                              }
4457:              
4458:                              if (error == FALSE) {
4459:                                  // Initialize the interface node
4460:                                  newInterfaceInfo->interface = bInterfaceNumber;
0041C2  98406D     MOV.B W13, [W0+6]
4461:                                  newInterfaceInfo->clientDriver = ClientDriver;
0041C4  97E88F     MOV.B [W15-24], W1
0041C6  984071     MOV.B W1, [W0+7]
4462:                                  newInterfaceInfo->pInterfaceSettings = NULL;
0041C8  EB0000     CLR W0
0041CA  980510     MOV W0, [W10+2]
4463:                                  newInterfaceInfo->pCurrentSetting = NULL;
0041CC  980520     MOV W0, [W10+4]
4464:              
4465:                                  // Insert it into the list.
4466:                                  newInterfaceInfo->next = pTempInterfaceList;
0041CE  780D09     MOV W9, [W10]
0041D0  78048A     MOV W10, W9
0041D2  370001     BRA 0x41D6
0041D4  780509     MOV W9, W10
4467:                                  pTempInterfaceList = newInterfaceInfo;
4468:                              }
4469:                          }
4470:              
4471:                          if (!error) {
4472:                              // Create a new setting for this interface, and add it to the list.
4473:                              if ((newSettingInfo = (USB_INTERFACE_SETTING_INFO *) USB_MALLOC(sizeof (USB_INTERFACE_SETTING_INFO))) == NULL) {
0041D6  200060     MOV #0x6, W0
0041D8  07E084     RCALL _malloc
0041DA  780680     MOV W0, W13
0041DC  E00000     CP0 W0
0041DE  3A00A1     BRA NZ, 0x4322
0041E0  370065     BRA 0x42AC
4474:                                  // Out of memory
4475:                                  error = TRUE;
4476:                              }
4477:                          }
4478:              
4479:                          if (!error) {
4480:                              newSettingInfo->next = newInterfaceInfo->pInterfaceSettings;
004322  90001A     MOV [W10+2], W0
004324  780E80     MOV W0, [W13]
4481:                              newSettingInfo->interfaceAltSetting = bAlternateSetting;
004326  97F09F     MOV.B [W15-15], W1
004328  9846A1     MOV.B W1, [W13+2]
4482:                              newSettingInfo->pEndpointList = NULL;
00432A  EB0000     CLR W0
00432C  9806A0     MOV W0, [W13+4]
4483:                              newInterfaceInfo->pInterfaceSettings = newSettingInfo;
00432E  98051D     MOV W13, [W10+2]
4484:                              if (bAlternateSetting == 0) {
004330  E00401     CP0.B W1
004332  32FF57     BRA Z, 0x41E2
004334  37FF57     BRA 0x41E4
4485:                                  newInterfaceInfo->pCurrentSetting = newSettingInfo;
0041E2  98052D     MOV W13, [W10+4]
4486:                              }
4487:              
4488:                              // Skip over the rest of the Interface Descriptor
4489:                              index += bLength;
0041E4  FB800C     ZE W12, W0
0041E6  458580     ADD W11, W0, W11
4490:                              ptr = &pCurrentConfigurationDescriptor[index];
0041E8  8078D0     MOV 0xF1A, W0
0041EA  458400     ADD W11, W0, W8
0041EC  EB4000     CLR.B W0
0041EE  9FEFC0     MOV.B W0, [W15-20]
0041F0  3700A2     BRA 0x4336
4491:              
4492:                              // Find the Endpoint Descriptors.  There might be Class and Vendor descriptors in here
4493:                              currentEndpoint = 0;
4494:                              while (!error && (index < wTotalLength) && (currentEndpoint < bNumEndpoints)) {
00429C  E00405     CP0.B W5
00429E  3A000D     BRA NZ, 0x42BA
0042A0  570F8B     SUB W14, W11, [W15]
0042A2  360006     BRA LEU, 0x42B0
0042A4  97F00F     MOV.B [W15-16], W0
0042A6  50CF80     SUB.B W1, W0, [W15]
0042A8  3AFFA4     BRA NZ, 0x41F2
0042AA  370002     BRA 0x42B0
0042AC  200014     MOV #0x1, W4
0042AE  370005     BRA 0x42BA
0042B0  EB0200     CLR W4
0042B2  370003     BRA 0x42BA
0042B4  97E8CF     MOV.B [W15-20], W1
0042B6  9FEFD1     MOV.B W1, [W15-19]
0042B8  EB0200     CLR W4
004336  570F8B     SUB W14, W11, [W15]
004338  3E0005     BRA GTU, 0x4344
00433A  37FFBC     BRA 0x42B4
004344  97E84F     MOV.B [W15-20], W0
004346  97F08F     MOV.B [W15-16], W1
004348  504F81     SUB.B W0, W1, [W15]
00434A  31FFB4     BRA C, 0x42B4
4495:                                  bLength = *ptr++;
0041F2  784618     MOV.B [W8], W12
00434C  784618     MOV.B [W8], W12
4496:                                  bDescriptorType = *ptr++;
0041F4  E88508     INC2 W8, W10
00434E  E88508     INC2 W8, W10
4497:              
4498:                                  if (bDescriptorType != USB_DESCRIPTOR_ENDPOINT) {
0041F6  904018     MOV.B [W8+1], W0
0041F8  504FE5     SUB.B W0, #0x5, [W15]
0041FA  320009     BRA Z, 0x420E
0041FC  97E8DF     MOV.B [W15-19], W1
0041FE  9FEFC1     MOV.B W1, [W15-20]
004350  904018     MOV.B [W8+1], W0
004352  504FE5     SUB.B W0, #0x5, [W15]
004354  3AFF55     BRA NZ, 0x4200
004356  37FF59     BRA 0x420A
4499:                                      // Skip over the rest of the Descriptor
4500:                                      index += bLength;
004200  FB800C     ZE W12, W0
004202  458580     ADD W11, W0, W11
4501:                                      ptr = &pCurrentConfigurationDescriptor[index];
004204  8078D0     MOV 0xF1A, W0
004206  458400     ADD W11, W0, W8
004208  370096     BRA 0x4336
00420A  97E84F     MOV.B [W15-20], W0
00420C  9FEFD0     MOV.B W0, [W15-19]
4502:                                  } else {
4503:                                      // Create an entry for the new endpoint.
4504:                                      if ((newEndpointInfo = (USB_ENDPOINT_INFO *) USB_MALLOC(sizeof (USB_ENDPOINT_INFO))) == NULL) {
00420E  200220     MOV #0x22, W0
004210  07E068     RCALL _malloc
004212  780180     MOV W0, W3
004214  EA0000     NEG W0, W0
004216  700003     IOR W0, W3, W0
004218  DE02CF     LSR W0, #15, W5
00421A  B3C010     MOV.B #0x1, W0
00421C  504285     SUB.B W0, W5, W5
00421E  FB8205     ZE W5, W4
4505:                                          // Out of memory
4506:                                          error = TRUE;
4507:                                      }
4508:                                      newEndpointInfo->bEndpointAddress = *ptr++;
004220  78451A     MOV.B [W10], W10
004222  9859AA     MOV.B W10, [W3+26]
4509:                                      newEndpointInfo->bmAttributes.val = *ptr++;
004224  9040B8     MOV.B [W8+3], W1
004226  9859B1     MOV.B W1, [W3+27]
4510:                                      newEndpointInfo->wMaxPacketSize = *ptr++;
004228  9040C8     MOV.B [W8+4], W1
00422A  FB8081     ZE W1, W1
00422C  9801C1     MOV W1, [W3+8]
4511:                                      newEndpointInfo->wMaxPacketSize += (*ptr++) << 8;
00422E  904058     MOV.B [W8+5], W0
004230  DD0048     SL W0, #8, W0
004232  408080     ADD W1, W0, W1
004234  9801C1     MOV W1, [W3+8]
4512:                                      newEndpointInfo->wInterval = *ptr++;
004236  904068     MOV.B [W8+6], W0
004238  FB8300     ZE W0, W6
00423A  9801A6     MOV W6, [W3+4]
4513:                                      newEndpointInfo->status.val = 0x00;
00423C  EB0100     CLR W2
00423E  980192     MOV W2, [W3+2]
4514:                                      newEndpointInfo->status.bfUseDTS = 1;
004240  904033     MOV.B [W3+3], W0
004242  A02400     BSET.B W0, #2
004244  9841B0     MOV.B W0, [W3+3]
4515:                                      newEndpointInfo->status.bfTransferComplete = 1; // Initialize to success to allow preprocessing loops.
004246  904033     MOV.B [W3+3], W0
004248  A01400     BSET.B W0, #1
00424A  9841B0     MOV.B W0, [W3+3]
4516:                                      newEndpointInfo->dataCount = 0; // Initialize to 0 since we set bfTransferComplete.
00424C  B80060     MUL.UU W0, #0, W0
00424E  980980     MOV W0, [W3+16]
004250  980991     MOV W1, [W3+18]
4517:                                      newEndpointInfo->transferState = TSTATE_IDLE;
004252  985982     MOV.B W2, [W3+24]
4518:                                      newEndpointInfo->clientDriver = ClientDriver;
004254  97E80F     MOV.B [W15-24], W0
004256  985990     MOV.B W0, [W3+25]
4519:              
4520:                                      // Special setup for isochronous endpoints.
4521:                                      if (newEndpointInfo->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
004258  900853     MOV [W3+26], W0
00425A  B23000     AND #0x300, W0
00425C  201001     MOV #0x100, W1
00425E  500F81     SUB W0, W1, [W15]
004260  3A0011     BRA NZ, 0x4284
4522:                                          // Validate and convert the interval to the number of frames.  The value must
4523:                                          // be between 1 and 16, and the frames is 2^(bInterval-1).
4524:                                          if (newEndpointInfo->wInterval == 0) newEndpointInfo->wInterval = 1;
004262  E00006     CP0 W6
004264  3A0002     BRA NZ, 0x426A
004266  200010     MOV #0x1, W0
004268  9801A0     MOV W0, [W3+4]
4525:                                          if (newEndpointInfo->wInterval > 16) newEndpointInfo->wInterval = 16;
00426A  900023     MOV [W3+4], W0
00426C  500FF0     SUB W0, #0x10, [W15]
00426E  360002     BRA LEU, 0x4274
004270  200100     MOV #0x10, W0
004272  9801A0     MOV W0, [W3+4]
4526:                                          newEndpointInfo->wInterval = 1 << (newEndpointInfo->wInterval - 1);
004274  900023     MOV [W3+4], W0
004276  E90000     DEC W0, W0
004278  200011     MOV #0x1, W1
00427A  DD0880     SL W1, W0, W1
00427C  9801A1     MOV W1, [W3+4]
4527:              
4528:                                          // Disable DTS
4529:                                          newEndpointInfo->status.bfUseDTS = 0;
00427E  904033     MOV.B [W3+3], W0
004280  A12400     BCLR.B W0, #2
004282  9841B0     MOV.B W0, [W3+3]
4530:                                      }
4531:              
4532:                                      // Initialize interval count
4533:                                      newEndpointInfo->wIntervalCount = newEndpointInfo->wInterval;
004284  9000A3     MOV [W3+4], W1
004286  9801B1     MOV W1, [W3+6]
4534:              
4535:                                      // Put the new endpoint in the list.
4536:                                      newEndpointInfo->next = newSettingInfo->pEndpointList;
004288  90002D     MOV [W13+4], W0
00428A  780980     MOV W0, [W3]
4537:                                      newSettingInfo->pEndpointList = newEndpointInfo;
00428C  9806A3     MOV W3, [W13+4]
4538:              
4539:                                      // When multiple devices are supported, check the available
4540:                                      // bandwidth here to make sure that we can support this
4541:                                      // endpoint.
4542:              
4543:                                      // Get ready for the next endpoint.
4544:                                      currentEndpoint++;
00428E  97E8DF     MOV.B [W15-19], W1
004290  E84081     INC.B W1, W1
004292  9FEFD1     MOV.B W1, [W15-19]
4545:                                      index += bLength;
004294  FB800C     ZE W12, W0
004296  458580     ADD W11, W0, W11
4546:                                      ptr = &pCurrentConfigurationDescriptor[index];
004298  8078D0     MOV 0xF1A, W0
00429A  458400     ADD W11, W0, W8
4547:                                  }
4548:                              }
4549:                          }
4550:              
4551:                          // Ensure that we found all the endpoints for this interface.
4552:                          if (currentEndpoint != bNumEndpoints) {
00413C  200014     MOV #0x1, W4
00413E  3700C9     BRA 0x42D2
0042BA  97E85F     MOV.B [W15-19], W0
0042BC  97F08F     MOV.B [W15-16], W1
0042BE  504F81     SUB.B W0, W1, [W15]
0042C0  3AFF3D     BRA NZ, 0x413C
4553:                              error = TRUE;
4554:                          }
4555:                      }
4556:                  }
4557:              
4558:                  // Ensure that we found all the interfaces in this configuration.
4559:                  // This is a nice check, but some devices have errors where they have a
4560:                  // different number of interfaces than they report they have!
4561:                  //    if (currentInterface != bNumInterfaces)
4562:                  //    {
4563:                  //        error = TRUE;
4564:                  //    }
4565:              
4566:                  if (pTempInterfaceList == NULL) {
0042D2  E00009     CP0 W9
0042D4  320041     BRA Z, 0x4358
4567:                      // We could find no supported interfaces.
4568:              #ifdef DEBUG_MODE
4569:                      UART2PrintString("HOST: No supported interfaces.\r\n");
4570:              #endif
4571:              
4572:                      error = TRUE;
4573:                  }
4574:              
4575:                  if (error) {
0042D6  E00004     CP0 W4
0042D8  32001A     BRA Z, 0x430E
4576:                      // Destroy whatever list of interfaces, settings, and endpoints we created.
4577:                      // The "new" variables point to the current node we are trying to remove.
4578:                      while (pTempInterfaceList != NULL) {
004306  E0000A     CP0 W10
004308  32000A     BRA Z, 0x431E
00430A  78048A     MOV W10, W9
00430C  37FFE6     BRA 0x42DA
004358  E00009     CP0 W9
00435A  3AFFBF     BRA NZ, 0x42DA
00435C  37FFE0     BRA 0x431E
4579:                          newInterfaceInfo = pTempInterfaceList;
4580:                          pTempInterfaceList = pTempInterfaceList->next;
0042DA  780519     MOV [W9], W10
4581:              
4582:                          while (newInterfaceInfo->pInterfaceSettings != NULL) {
0042DC  900419     MOV [W9+2], W8
0042DE  E00008     CP0 W8
0042E0  320010     BRA Z, 0x4302
0042FC  900419     MOV [W9+2], W8
0042FE  E00008     CP0 W8
004300  3AFFF0     BRA NZ, 0x42E2
4583:                              newSettingInfo = newInterfaceInfo->pInterfaceSettings;
4584:                              newInterfaceInfo->pInterfaceSettings = newInterfaceInfo->pInterfaceSettings->next;
0042E2  780018     MOV [W8], W0
0042E4  980490     MOV W0, [W9+2]
4585:              
4586:                              while (newSettingInfo->pEndpointList != NULL) {
0042E6  900028     MOV [W8+4], W0
0042E8  E00000     CP0 W0
0042EA  320006     BRA Z, 0x42F8
0042F2  900028     MOV [W8+4], W0
0042F4  E00000     CP0 W0
0042F6  3AFFFA     BRA NZ, 0x42EC
4587:                                  newEndpointInfo = newSettingInfo->pEndpointList;
4588:                                  newSettingInfo->pEndpointList = newSettingInfo->pEndpointList->next;
0042EC  780090     MOV [W0], W1
0042EE  980421     MOV W1, [W8+4]
4589:              
4590:                                  USB_FREE_AND_CLEAR(newEndpointInfo);
0042F0  07E08A     RCALL _free
4591:                              }
4592:              
4593:                              USB_FREE_AND_CLEAR(newSettingInfo);
0042F8  780008     MOV W8, W0
0042FA  07E085     RCALL _free
4594:                          }
4595:              
4596:                          USB_FREE_AND_CLEAR(newInterfaceInfo);
004302  780009     MOV W9, W0
004304  07E080     RCALL _free
4597:                      }
4598:                      return FALSE;
4599:                  } else {
4600:                      // Set configuration.
4601:                      usbDeviceInfo.currentConfiguration = currentConfiguration;
00430E  97E86F     MOV.B [W15-18], W0
004310  B7EED0     MOV.B WREG, 0xED0
4602:                      usbDeviceInfo.currentConfigurationPower = bMaxPower;
004312  97E8FF     MOV.B [W15-17], W1
004314  FB8001     ZE W1, W0
004316  8876B0     MOV W0, 0xED6
4603:              
4604:                      // Success!
4605:              #ifdef DEBUG_MODE
4606:                      UART2PrintString("HOST: Parse Descriptor success\r\n");
4607:              #endif
4608:                      usbDeviceInfo.pInterfaceList = pTempInterfaceList;
004318  8876D9     MOV W9, 0xEDA
00431A  200010     MOV #0x1, W0
00431C  370020     BRA 0x435E
4609:                      return TRUE;
00431E  EB0000     CLR W0
004320  37001E     BRA 0x435E
4610:                  }
4611:              }
00435E  78074F     MOV [--W15], W14
004360  BE064F     MOV.D [--W15], W12
004362  BE054F     MOV.D [--W15], W10
004364  BE044F     MOV.D [--W15], W8
004366  B100CF     SUB #0xC, W15
004368  060000     RETURN
4612:              
4613:              /****************************************************************************
4614:                Function:
4615:                  void _USB_ResetDATA0( BYTE endpoint )
4616:              
4617:                Description:
4618:                  This function resets DATA0 for the specified endpoint.  If the
4619:                  specified endpoint is 0, it resets DATA0 for all endpoints.
4620:              
4621:                Precondition:
4622:                  None
4623:              
4624:                Parameters:
4625:                  BYTE endpoint   - Endpoint number to reset.
4626:              
4627:              
4628:                Returns:
4629:                  None
4630:              
4631:                Remarks:
4632:                  None
4633:               ***************************************************************************/
4634:              
4635:              void _USB_ResetDATA0(BYTE endpoint) {
4636:                  USB_ENDPOINT_INFO *pEndpoint;
4637:              
4638:                  if (endpoint == 0) {
00436A  E00400     CP0.B W0
00436C  3A0017     BRA NZ, 0x439C
4639:                      // Reset DATA0 for all endpoints.
4640:                      USB_INTERFACE_INFO *pInterface;
4641:                      USB_INTERFACE_SETTING_INFO *pSetting;
4642:              
4643:                      pInterface = usbDeviceInfo.pInterfaceList;
00436E  8076D4     MOV 0xEDA, W4
4644:                      while (pInterface) {
004370  E00004     CP0 W4
004372  32001B     BRA Z, 0x43AA
004396  E00004     CP0 W4
004398  320008     BRA Z, 0x43AA
00439A  37FFEC     BRA 0x4374
4645:                          pSetting = pInterface->pInterfaceSettings;
004374  900194     MOV [W4+2], W3
4646:                          while (pSetting) {
004376  E00003     CP0 W3
004378  32000D     BRA Z, 0x4394
004390  E00003     CP0 W3
004392  3AFFF3     BRA NZ, 0x437A
4647:                              pEndpoint = pSetting->pEndpointList;
00437A  9000A3     MOV [W3+4], W1
4648:                              while (pEndpoint) {
00437C  E00001     CP0 W1
00437E  320007     BRA Z, 0x438E
004380  B3CF72     MOV.B #0xF7, W2
00438A  E00001     CP0 W1
00438C  3AFFFA     BRA NZ, 0x4382
4649:                                  pEndpoint->status.bfNextDATA01 = 0;
004382  904031     MOV.B [W1+3], W0
004384  604002     AND.B W0, W2, W0
004386  9840B0     MOV.B W0, [W1+3]
4650:                                  pEndpoint = pEndpoint->next;
004388  780091     MOV [W1], W1
4651:                              }
4652:                              pSetting = pSetting->next;
00438E  780193     MOV [W3], W3
4653:                          }
4654:                          pInterface = pInterface->next;
004394  780214     MOV [W4], W4
4655:                      }
4656:                  } else {
4657:                      pEndpoint = _USB_FindEndpoint(endpoint);
00439C  07F942     RCALL _USB_FindEndpoint
00439E  780080     MOV W0, W1
4658:                      if (pEndpoint != NULL) {
0043A0  E00000     CP0 W0
0043A2  320003     BRA Z, 0x43AA
4659:                          pEndpoint->status.bfNextDATA01 = 0;
0043A4  904030     MOV.B [W0+3], W0
0043A6  A13400     BCLR.B W0, #3
0043A8  9840B0     MOV.B W0, [W1+3]
4660:                      }
4661:                  }
4662:              }
0043AA  060000     RETURN
4663:              
4664:              /****************************************************************************
4665:                Function:
4666:                  void _USB_SendToken( BYTE endpoint, BYTE tokenType )
4667:              
4668:                Description:
4669:                  This function sets up the endpoint control register and sends the token.
4670:              
4671:                Precondition:
4672:                  None
4673:              
4674:                Parameters:
4675:                  BYTE endpoint   - Endpoint number
4676:                  BYTE tokenType  - Token to send
4677:              
4678:                Returns:
4679:                  None
4680:              
4681:                Remarks:
4682:                  If the device is low speed, the transfer must be set to low speed.  If
4683:                  the endpoint is isochronous, handshaking must be disabled.
4684:               ***************************************************************************/
4685:              
4686:              void _USB_SendToken(BYTE endpoint, BYTE tokenType) {
0043AC  784200     MOV.B W0, W4
4687:                  BYTE temp;
4688:              
4689:                  // Disable retries, disable control transfers, enable Rx and Tx and handshaking.
4690:                  temp = 0x5D;
4691:              
4692:                  // Enable low speed transfer if the device is low speed.
4693:                  if (usbDeviceInfo.flags.bfIsLowSpeed) {
0043AE  BFCEDE     MOV.B 0xEDE, WREG
0043B0  B3CDD3     MOV.B #0xDD, W3
0043B2  A30800     BTST.Z W0, #0
0043B4  3A0001     BRA NZ, 0x43B8
0043B6  B3C5D3     MOV.B #0x5D, W3
4694:                      temp |= 0x80; // Set LSPD
4695:                  }
4696:              
4697:                  // Enable control transfers if necessary.
4698:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_CONTROL) {
0043B8  807632     MOV pCurrentEndpoint, W2
0043BA  905832     MOV.B [W2+27], W0
0043BC  604063     AND.B W0, #0x3, W0
0043BE  3A0001     BRA NZ, 0x43C2
4699:                      temp &= 0xEF; // Clear EPCONDIS
0043C0  A14403     BCLR.B W3, #4
4700:                  }
4701:              
4702:                  // Disable handshaking for isochronous endpoints.
4703:                  if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
0043C2  905832     MOV.B [W2+27], W0
0043C4  604063     AND.B W0, #0x3, W0
0043C6  504FE1     SUB.B W0, #0x1, [W15]
0043C8  3A0001     BRA NZ, 0x43CC
4704:                      temp &= 0xFE; // Clear EPHSHK
0043CA  A10403     BCLR.B W3, #0
4705:                  }
4706:              
4707:                  U1EP0 = temp;
0043CC  FB8003     ZE W3, W0
0043CE  882550     MOV W0, U1EP0
4708:              
4709:              #ifdef DEBUG_MODE
4710:                  if (usbBusInfo.flags.bfTokenAlreadyWritten) UART2PutChar('+');
4711:                  //        if (U1CONbits.TOKBUSY) UART2PutChar( '+' );
4712:              #endif
4713:              
4714:                  U1ADDR = usbDeviceInfo.deviceAddressAndSpeed;
0043D0  BFCED2     MOV.B 0xED2, WREG
0043D2  FB8000     ZE W0, W0
0043D4  8824B0     MOV W0, U1ADDR
4715:                  U1TOK = (tokenType << 4) | (endpoint & 0x7F);
0043D6  FB8001     ZE W1, W0
0043D8  DD0044     SL W0, #4, W0
0043DA  780084     MOV W4, W1
0043DC  B207F1     AND #0x7F, W1
0043DE  700001     IOR W0, W1, W0
0043E0  8824F0     MOV W0, U1TOK
4716:              
4717:                  // Lock out anyone from writing another token until this one has finished.
4718:                  //    U1CONbits.TOKBUSY = 1;
4719:                  usbBusInfo.flags.bfTokenAlreadyWritten = 1;
0043E2  A88ECA     BSET usbBusInfo, #4
4720:              
4721:              #ifdef DEBUG_MODE
4722:                  //UART2PutChar('(');
4723:                  //UART2PutHex(U1ADDR);
4724:                  //UART2PutHex(U1EP0);
4725:                  //UART2PutHex(U1TOK);
4726:                  //UART2PutChar(')');
4727:              #endif
4728:              }
0043E4  060000     RETURN
4729:              
4730:              /****************************************************************************
4731:                Function:
4732:                  void _USB_SetBDT( BYTE token )
4733:              
4734:                Description:
4735:                  This function sets up the BDT for the transfer.  The function handles the
4736:                  different ping-pong modes.
4737:              
4738:                Precondition:
4739:                  pCurrentEndpoint must point to the current endpoint being serviced.
4740:              
4741:                Parameters:
4742:                  BYTE token  - Token for the transfer.  That way we can tell which
4743:                                  ping-pong buffer and which data pointer to use.  Valid
4744:                                  values are:
4745:               * USB_TOKEN_SETUP
4746:               * USB_TOKEN_IN
4747:               * USB_TOKEN_OUT
4748:              
4749:                Returns:
4750:                  None
4751:              
4752:                Remarks:
4753:                  None
4754:               ***************************************************************************/
4755:              
4756:              void _USB_SetBDT(BYTE token) {
0043E6  784100     MOV.B W0, W2
4757:                  WORD currentPacketSize;
4758:                  BDT_ENTRY *pBDT;
4759:              
4760:                  if (token == USB_TOKEN_IN) {
0043E8  504FE9     SUB.B W0, #0x9, [W15]
0043EA  3A0011     BRA NZ, 0x440E
4761:                      // Find the BDT we need to use.
4762:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
4763:                      pBDT = BDT_IN;
4764:                      if (usbDeviceInfo.flags.bfPingPongIn) {
0043EC  BFCEDE     MOV.B 0xEDE, WREG
0043EE  210047     MOV #0x1004, W7
0043F0  A34800     BTST.Z W0, #4
0043F2  3A0001     BRA NZ, 0x43F6
0043F4  210007     MOV #0x1000, W7
4765:                          pBDT = BDT_IN_ODD;
4766:                      }
4767:              #else
4768:                      pBDT = BDT_IN;
4769:              #endif
4770:              
4771:                      // Set up ping-pong for the next transfer
4772:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
4773:                      usbDeviceInfo.flags.bfPingPongIn = ~usbDeviceInfo.flags.bfPingPongIn;
0043F6  BFCEDE     MOV.B 0xEDE, WREG
0043F8  DE0044     LSR W0, #4, W0
0043FA  600061     AND W0, #0x1, W0
0043FC  A20400     BTG.B W0, #0
0043FE  DD0044     SL W0, #4, W0
004400  20EDE1     MOV #0xEDE, W1
004402  784091     MOV.B [W1], W1
004404  A14401     BCLR.B W1, #4
004406  70C080     IOR.B W1, W0, W1
004408  780001     MOV W1, W0
00440A  B7EEDE     MOV.B WREG, 0xEDE
00440C  370025     BRA 0x4458
4774:              #endif
4775:                  } else // USB_TOKEN_OUT or USB_TOKEN_SETUP
4776:                  {
4777:                      // Find the BDT we need to use.
4778:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
4779:                      pBDT = BDT_OUT;
4780:                      if (usbDeviceInfo.flags.bfPingPongOut) {
00440E  BFCEDE     MOV.B 0xEDE, WREG
004410  2100C7     MOV #0x100C, W7
004412  A35800     BTST.Z W0, #5
004414  3A0001     BRA NZ, 0x4418
004416  210087     MOV #0x1008, W7
4781:                          pBDT = BDT_OUT_ODD;
4782:                      }
4783:              #else
4784:                      pBDT = BDT_OUT;
4785:              #endif
4786:              
4787:                      // Set up ping-pong for the next transfer
4788:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY)
4789:                      usbDeviceInfo.flags.bfPingPongOut = ~usbDeviceInfo.flags.bfPingPongOut;
004418  BFCEDE     MOV.B 0xEDE, WREG
00441A  DE0045     LSR W0, #5, W0
00441C  600061     AND W0, #0x1, W0
00441E  A20400     BTG.B W0, #0
004420  DD0045     SL W0, #5, W0
004422  20EDE1     MOV #0xEDE, W1
004424  784091     MOV.B [W1], W1
004426  A15401     BCLR.B W1, #5
004428  70C080     IOR.B W1, W0, W1
00442A  780001     MOV W1, W0
00442C  B7EEDE     MOV.B WREG, 0xEDE
4790:              #endif
4791:                  }
4792:              
4793:                  // Determine how much data we'll transfer in this packet.
4794:                  if (token == USB_TOKEN_SETUP) {
00442E  514FED     SUB.B W2, #0xD, [W15]
004430  3A0013     BRA NZ, 0x4458
4795:                      if ((pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize) {
004432  807636     MOV pCurrentEndpoint, W6
004434  900076     MOV [W6+14], W0
004436  900A06     MOV [W6+16], W4
004438  900A96     MOV [W6+18], W5
00443A  900146     MOV [W6+8], W2
00443C  200001     MOV #0x0, W1
00443E  500004     SUB W0, W4, W0
004440  588085     SUBB W1, W5, W1
004442  200003     MOV #0x0, W3
004444  500F82     SUB W0, W2, [W15]
004446  588F83     SUBB W1, W3, [W15]
004448  360002     BRA LEU, 0x444E
4796:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
00444A  9001C6     MOV [W6+8], W3
00444C  37001F     BRA 0x448C
4797:                      } else {
4798:                          currentPacketSize = pCurrentEndpoint->dataCountMaxSETUP - pCurrentEndpoint->dataCount;
00444E  900176     MOV [W6+14], W2
004450  900806     MOV [W6+16], W0
004452  900896     MOV [W6+18], W1
004454  510180     SUB W2, W0, W3
004456  37001A     BRA 0x448C
4799:                      }
4800:                  } else {
4801:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
004458  807636     MOV pCurrentEndpoint, W6
00445A  905836     MOV.B [W6+27], W0
00445C  604063     AND.B W0, #0x3, W0
00445E  504FE1     SUB.B W0, #0x1, [W15]
004460  3A0002     BRA NZ, 0x4466
4802:                          // Isochronous transfers are always the same size, though the device may choose to send less.
4803:                          currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
004462  9001C6     MOV [W6+8], W3
004464  37003B     BRA 0x44DC
4804:                      } else {
4805:                          if ((pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount) > pCurrentEndpoint->wMaxPacketSize) {
004466  900056     MOV [W6+10], W0
004468  9000E6     MOV [W6+12], W1
00446A  900A06     MOV [W6+16], W4
00446C  900A96     MOV [W6+18], W5
00446E  900146     MOV [W6+8], W2
004470  500004     SUB W0, W4, W0
004472  588085     SUBB W1, W5, W1
004474  200003     MOV #0x0, W3
004476  500F82     SUB W0, W2, [W15]
004478  588F83     SUBB W1, W3, [W15]
00447A  360002     BRA LEU, 0x4480
4806:                              currentPacketSize = pCurrentEndpoint->wMaxPacketSize;
00447C  9001C6     MOV [W6+8], W3
00447E  37002E     BRA 0x44DC
4807:                          } else {
4808:                              currentPacketSize = pCurrentEndpoint->dataCountMax - pCurrentEndpoint->dataCount;
004480  900156     MOV [W6+10], W2
004482  9001E6     MOV [W6+12], W3
004484  900806     MOV [W6+16], W0
004486  900896     MOV [W6+18], W1
004488  510180     SUB W2, W0, W3
00448A  370028     BRA 0x44DC
4809:                          }
4810:                      }
4811:                  }
4812:              
4813:                  // Load up the BDT address.
4814:                  if (token == USB_TOKEN_SETUP) {
4815:              #if defined(__C30__) || defined(__PIC32MX__)
4816:                      pBDT->ADR = ConvertToPhysicalAddress(pCurrentEndpoint->pUserDataSETUP);
00448C  900B26     MOV [W6+20], W6
00448E  980396     MOV W6, [W7+2]
004490  37000E     BRA 0x44AE
4817:              #else
4818:              #error Cannot set BDT address.
4819:              #endif
4820:                  } else {
4821:              #if defined(__C30__)
4822:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
0044DC  905836     MOV.B [W6+27], W0
0044DE  604063     AND.B W0, #0x3, W0
0044E0  504FE1     SUB.B W0, #0x1, [W15]
0044E2  3AFFE0     BRA NZ, 0x44A4
0044E4  37FFD6     BRA 0x4492
4823:                          pBDT->ADR = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
004492  9008B6     MOV [W6+22], W1
004494  900836     MOV [W6+22], W0
004496  904010     MOV.B [W0+1], W0
004498  B3C062     MOV.B #0x6, W2
00449A  BC4004     MUL.B WREG2
00449C  410166     ADD W2, #0x6, W2
00449E  7880E2     MOV [W2+W1], W1
0044A0  980391     MOV W1, [W7+2]
0044A2  370005     BRA 0x44AE
4824:                      } else {
4825:                          pBDT->ADR = ConvertToPhysicalAddress((WORD) pCurrentEndpoint->pUserData + (WORD) pCurrentEndpoint->dataCount);
0044A4  900936     MOV [W6+22], W2
0044A6  900806     MOV [W6+16], W0
0044A8  900896     MOV [W6+18], W1
0044AA  410100     ADD W2, W0, W2
0044AC  980392     MOV W2, [W7+2]
4826:                      }
4827:              #elif defined(__PIC32MX__)
4828:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
4829:                          pBDT->ADR = ConvertToPhysicalAddress(((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->buffers[((ISOCHRONOUS_DATA *) (pCurrentEndpoint->pUserData))->currentBufferUSB].pBuffer);
4830:                      } else {
4831:                          pBDT->ADR = ConvertToPhysicalAddress((DWORD) pCurrentEndpoint->pUserData + (DWORD) pCurrentEndpoint->dataCount);
4832:                      }
4833:              #else
4834:              #error Cannot set BDT address.
4835:              #endif
4836:                  }
4837:              
4838:                  // Load up the BDT status register.
4839:                  pBDT->STAT.Val = 0;
0044AE  EB4000     CLR.B W0
0044B0  984390     MOV.B W0, [W7+1]
4840:                  pBDT->count = currentPacketSize;
0044B2  780083     MOV W3, W1
0044B4  B23FF1     AND #0x3FF, W1
0044B6  2FC000     MOV #0xFC00, W0
0044B8  600B97     AND W0, [W7], [W7]
0044BA  708B97     IOR W1, [W7], [W7]
4841:                  pBDT->STAT.DTS = pCurrentEndpoint->status.bfNextDATA01;
0044BC  807631     MOV pCurrentEndpoint, W1
0044BE  904031     MOV.B [W1+3], W0
0044C0  DE0043     LSR W0, #3, W0
0044C2  600061     AND W0, #0x1, W0
0044C4  DD004E     SL W0, #14, W0
0044C6  A1E017     BCLR [W7], #14
0044C8  700B97     IOR W0, [W7], [W7]
4842:                  pBDT->STAT.DTSEN = pCurrentEndpoint->status.bfUseDTS;
0044CA  904031     MOV.B [W1+3], W0
0044CC  DE0042     LSR W0, #2, W0
0044CE  600061     AND W0, #0x1, W0
0044D0  DD004B     SL W0, #11, W0
0044D2  A1B017     BCLR [W7], #11
0044D4  700B97     IOR W0, [W7], [W7]
4843:              
4844:                  // Transfer the BD to the USB OTG module.
4845:                  pBDT->STAT.UOWN = 1;
0044D6  280000     MOV #0x8000, W0
0044D8  700B97     IOR W0, [W7], [W7]
4846:              
4847:              #ifdef DEBUG_MODE
4848:                  //        UART2PutChar('{');
4849:                  //        UART2PutHex((pBDT->v[0] >> 24) & 0xff);
4850:                  //        UART2PutHex((pBDT->v[0] >> 16) & 0xff);
4851:                  //        UART2PutHex((pBDT->v[0] >> 8) & 0xff);
4852:                  //        UART2PutHex((pBDT->v[0]) & 0xff);
4853:                  //        UART2PutChar('-');
4854:                  //        UART2PutHex((currentPacketSize >> 24) & 0xff);
4855:                  //        UART2PutHex((pBDT->v[1] >> 16) & 0xff);
4856:                  //        UART2PutHex((currentPacketSize >> 8) & 0xff);
4857:                  //        UART2PutHex(currentPacketSize & 0xff);
4858:                  //        UART2PutChar('}');
4859:              #endif
4860:              
4861:              }
0044DA  060000     RETURN
0044DC  905836     MOV.B [W6+27], W0
0044DE  604063     AND.B W0, #0x3, W0
0044E0  504FE1     SUB.B W0, #0x1, [W15]
0044E2  3AFFE0     BRA NZ, 0x44A4
0044E4  37FFD6     BRA 0x4492
4862:              
4863:              /****************************************************************************
4864:                Function:
4865:                  BOOL _USB_TransferInProgress( void )
4866:              
4867:                Description:
4868:                  This function checks to see if any read or write transfers are in
4869:                  progress.
4870:              
4871:                Precondition:
4872:                  None
4873:              
4874:                Parameters:
4875:                  None - None
4876:              
4877:                Returns:
4878:                  TRUE    - At least one read or write transfer is occurring.
4879:                  FALSE   - No read or write transfers are occurring.
4880:              
4881:                Remarks:
4882:                  None
4883:               ***************************************************************************/
4884:              
4885:              BOOL _USB_TransferInProgress(void) {
4886:                  USB_ENDPOINT_INFO *pEndpoint;
4887:                  USB_INTERFACE_INFO *pInterface;
4888:                  USB_INTERFACE_SETTING_INFO *pSetting;
4889:              
4890:                  // Check EP0.
4891:                  if (!usbDeviceInfo.pEndpoint0->status.bfTransferComplete) {
0044E6  8076E0     MOV 0xEDC, W0
0044E8  904030     MOV.B [W0+3], W0
0044EA  A31800     BTST.Z W0, #1
0044EC  320017     BRA Z, 0x451C
4892:                      return TRUE;
4893:                  }
4894:              
4895:                  // Check all of the other endpoints.
4896:                  pInterface = usbDeviceInfo.pInterfaceList;
0044EE  8076D3     MOV 0xEDA, W3
4897:                  while (pInterface) {
0044F0  E00003     CP0 W3
0044F2  320016     BRA Z, 0x4520
004516  E00003     CP0 W3
004518  320003     BRA Z, 0x4520
00451A  37FFEC     BRA 0x44F4
00451C  200010     MOV #0x1, W0
00451E  370006     BRA 0x452C
004520  EB0000     CLR W0
004522  370004     BRA 0x452C
4898:                      pSetting = pInterface->pInterfaceSettings;
0044F4  900113     MOV [W3+2], W2
4899:                      while (pSetting) {
0044F6  E00002     CP0 W2
0044F8  32000D     BRA Z, 0x4514
004510  E00002     CP0 W2
004512  3AFFF3     BRA NZ, 0x44FA
4900:                          pEndpoint = pSetting->pEndpointList;
0044FA  9000A2     MOV [W2+4], W1
4901:                          while (pEndpoint) {
0044FC  E00001     CP0 W1
0044FE  3A0012     BRA NZ, 0x4524
004500  370006     BRA 0x450E
00450A  E00001     CP0 W1
00450C  3AFFFA     BRA NZ, 0x4502
4902:                              if (!pEndpoint->status.bfTransferComplete) {
004502  904031     MOV.B [W1+3], W0
004504  A31800     BTST.Z W0, #1
004506  32000A     BRA Z, 0x451C
004524  904031     MOV.B [W1+3], W0
004526  A31800     BTST.Z W0, #1
004528  3AFFEF     BRA NZ, 0x4508
00452A  37FFF8     BRA 0x451C
4903:                                  return TRUE;
4904:                              }
4905:                              pEndpoint = pEndpoint->next;
004508  780091     MOV [W1], W1
4906:                          }
4907:                          pSetting = pSetting->next;
00450E  780112     MOV [W2], W2
4908:                      }
4909:                      pInterface = pInterface->next;
004514  780193     MOV [W3], W3
4910:                  }
4911:              
4912:                  return FALSE;
4913:              }
00452C  060000     RETURN
4914:              
4915:              
4916:              // *****************************************************************************
4917:              // *****************************************************************************
4918:              // Section: Interrupt Handlers
4919:              // *****************************************************************************
4920:              // *****************************************************************************
4921:              
4922:              /****************************************************************************
4923:                Function:
4924:                  void _USB1Interrupt( void )
4925:              
4926:                Summary:
4927:                  This is the interrupt service routine for the USB interrupt.
4928:              
4929:                Description:
4930:                  This is the interrupt service routine for the USB interrupt.  The
4931:                  following cases are serviced:
4932:               * Device Attach
4933:               * Device Detach
4934:               * One millisecond Timer
4935:               * Start of Frame
4936:               * Transfer Done
4937:               * USB Error
4938:              
4939:                Precondition:
4940:                  In TRNIF handling, pCurrentEndpoint is still pointing to the last
4941:                  endpoint to which a token was sent.
4942:              
4943:                Parameters:
4944:                  None - None
4945:              
4946:                Returns:
4947:                  None
4948:              
4949:                Remarks:
4950:                  None
4951:               ***************************************************************************/
4952:              #define U1STAT_TX_MASK                      0x08    // U1STAT bit mask for Tx/Rx indication
4953:              #define U1STAT_ODD_MASK                     0x04    // U1STAT bit mask for even/odd buffer bank
4954:              
4955:              #if defined(__C30__)
4956:              void __attribute__((__interrupt__, no_auto_psv)) _USB1Interrupt(void)
4957:              #elif defined(__PIC32MX__)
4958:              void __ISR(_USB_1_VECTOR, ipl4) _USB1Interrupt(void)
4959:              #else
4960:              #error Cannot define timer interrupt vector.
4961:              #endif
4962:              {
00452E  F80036     PUSH RCOUNT
004530  BE9F80     MOV.D W0, [W15++]
004532  BE9F82     MOV.D W2, [W15++]
004534  BE9F84     MOV.D W4, [W15++]
004536  BE9F86     MOV.D W6, [W15++]
4963:              
4964:              #if defined( __C30__)
4965:                  IFS5 &= 0xFFBF;
004538  A9C08E     BCLR IFS5, #6
4966:              #elif defined( __PIC32MX__)
4967:                  IFS1CLR = _IFS1_USBIF_MASK;
4968:              #else
4969:              #error Cannot clear USB interrupt.
4970:              #endif
4971:              
4972:                  // -------------------------------------------------------------------------
4973:                  // One Millisecond Timer ISR
4974:              
4975:                  if (U1OTGIEbits.T1MSECIE && U1OTGIRbits.T1MSECIF) {
00453A  BFC482     MOV.B U1OTGIE, WREG
00453C  A36800     BTST.Z W0, #6
00453E  320010     BRA Z, 0x4560
004540  BFC480     MOV.B U1OTGIR, WREG
004542  A36800     BTST.Z W0, #6
004544  32000D     BRA Z, 0x4560
4976:                      // The interrupt is cleared by writing a '1' to it.
4977:                      U1OTGIR = USB_INTERRUPT_T1MSECIF;
004546  200400     MOV #0x40, W0
004548  882400     MOV W0, U1OTGIR
4978:              
4979:              #if defined(USB_ENABLE_1MS_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
4980:                      msec_count++;
4981:              
4982:                      //Notify ping all client drivers of 1MSEC event (address, event, data, sizeof_data)
4983:                      _USB_NotifyAllDataClients(0, EVENT_1MS, (void*) &msec_count, 0);
4984:              #endif
4985:              
4986:              #ifdef DEBUG_MODE
4987:                      UART2PutChar('~');
4988:              #endif
4989:              
4990:              #ifdef  USB_SUPPORT_OTG
4991:                      if (USBOTGGetSRPTimeOutFlag()) {
4992:                          if (USBOTGIsSRPTimeOutExpired()) {
4993:                              USB_OTGEventHandler(0, OTG_EVENT_SRP_FAILED, 0, 0);
4994:                          }
4995:              
4996:                      }
4997:                      else if (USBOTGGetHNPTimeOutFlag()) {
4998:                          if (USBOTGIsHNPTimeOutExpired()) {
4999:                              USB_OTGEventHandler(0, OTG_EVENT_HNP_FAILED, 0, 0);
5000:                          }
5001:              
5002:                      }
5003:                      else {
5004:                          if (numTimerInterrupts != 0) {
5005:                              numTimerInterrupts--;
5006:              
5007:                              if (numTimerInterrupts == 0) {
5008:                                  //If we aren't using the 1ms events, then turn of the interrupt to
5009:                                  // save CPU time
5010:              #if !defined(USB_ENABLE_1MS_EVENT)
5011:                                  // Turn off the timer interrupt.
5012:                                  U1OTGIEbits.T1MSECIE = 0;
5013:              #endif
5014:              
5015:                                  if ((usbHostState & STATE_MASK) != STATE_DETACHED) {
5016:                                      // Advance to the next state.  We can do this here, because the only time
5017:                                      // we'll get a timer interrupt is while we are in one of the holding states.
5018:                                      _USB_SetNextSubSubState();
5019:                                  }
5020:                              }
5021:                          }
5022:                      }
5023:              #else
5024:              
5025:                      if (numTimerInterrupts != 0) {
00454A  E20EC4     CP0 numTimerInterrupts
00454C  320009     BRA Z, 0x4560
5026:                          numTimerInterrupts--;
00454E  ED2EC4     DEC numTimerInterrupts
5027:              
5028:                          if (numTimerInterrupts == 0) {
004550  E20EC4     CP0 numTimerInterrupts
004552  3A0006     BRA NZ, 0x4560
5029:                              //If we aren't using the 1ms events, then turn of the interrupt to
5030:                              // save CPU time
5031:              #if !defined(USB_ENABLE_1MS_EVENT)
5032:                              // Turn off the timer interrupt.
5033:                              U1OTGIEbits.T1MSECIE = 0;
004554  A9C482     BCLR U1OTGIE, #6
5034:              #endif
5035:              
5036:                              if ((usbHostState & STATE_MASK) != STATE_DETACHED) {
004556  807640     MOV usbHostState, W0
004558  20F001     MOV #0xF00, W1
00455A  600001     AND W0, W1, W0
00455C  320001     BRA Z, 0x4560
5037:                                  // Advance to the next state.  We can do this here, because the only time
5038:                                  // we'll get a timer interrupt is while we are in one of the holding states.
5039:                                  _USB_SetNextSubSubState();
00455E  EC2EC8     INC usbHostState
5040:                              }
5041:                          }
5042:                      }
5043:              #endif
5044:                  }
5045:              
5046:                  // -------------------------------------------------------------------------
5047:                  // Attach ISR
5048:              
5049:                  // The attach interrupt is level, not edge, triggered.  So make sure we have it enabled.
5050:                  if (U1IEbits.ATTACHIE && U1IRbits.ATTACHIF) {
004560  BFC48C     MOV.B U1IE, WREG
004562  A36800     BTST.Z W0, #6
004564  32000C     BRA Z, 0x457E
004566  BFC48A     MOV.B U1IR, WREG
004568  A36800     BTST.Z W0, #6
00456A  320009     BRA Z, 0x457E
5051:              #ifdef DEBUG_MODE
5052:                      UART2PutChar('[');
5053:              #endif
5054:              
5055:                      // The attach interrupt is level, not edge, triggered.  If we clear it, it just
5056:                      // comes right back.  So clear the enable instead
5057:                      U1IEbits.ATTACHIE = 0;
00456C  A9C48C     BCLR U1IE, #6
5058:                      U1IR = USB_INTERRUPT_ATTACH;
00456E  200400     MOV #0x40, W0
004570  882450     MOV W0, U1IR
5059:              
5060:                      if (usbHostState == (STATE_DETACHED | SUBSTATE_WAIT_FOR_DEVICE)) {
004572  807641     MOV usbHostState, W1
004574  500070     SUB W0, #0x10, W0
004576  508F80     SUB W1, W0, [W15]
004578  3A0002     BRA NZ, 0x457E
5061:                          usbOverrideHostState = STATE_ATTACHED;
00457A  201000     MOV #0x100, W0
00457C  8878C0     MOV W0, usbOverrideHostState
5062:                      }
5063:              
5064:              #ifdef  USB_SUPPORT_OTG
5065:                      //If HNP Related Attach, Process Connect Event
5066:                      USB_OTGEventHandler(0, OTG_EVENT_CONNECT, 0, 0);
5067:              
5068:                      //If SRP Related A side D+ High, Process D+ High Event
5069:                      USB_OTGEventHandler(0, OTG_EVENT_SRP_DPLUS_HIGH, 0, 0);
5070:              
5071:                      //If SRP Related B side Attach
5072:                      USB_OTGEventHandler(0, OTG_EVENT_SRP_CONNECT, 0, 0);
5073:              #endif
5074:                  }
5075:              
5076:                  // -------------------------------------------------------------------------
5077:                  // Detach ISR
5078:              
5079:                  if (U1IEbits.DETACHIE && U1IRbits.DETACHIF) {
00457E  BFC48C     MOV.B U1IE, WREG
004580  A30800     BTST.Z W0, #0
004582  320007     BRA Z, 0x4592
004584  BFC48A     MOV.B U1IR, WREG
004586  A30800     BTST.Z W0, #0
004588  320004     BRA Z, 0x4592
5080:              #ifdef DEBUG_MODE
5081:                      UART2PutChar(']');
5082:              #endif
5083:              
5084:                      U1IR = USB_INTERRUPT_DETACH;
00458A  200010     MOV #0x1, W0
00458C  882450     MOV W0, U1IR
5085:                      U1IEbits.DETACHIE = 0;
00458E  A9048C     BCLR U1IE, #0
5086:                      usbOverrideHostState = STATE_DETACHED;
004590  EF2F18     CLR usbOverrideHostState
5087:              
5088:              #ifdef  USB_SUPPORT_OTG
5089:                      //If HNP Related Detach Detected, Process Disconnect Event
5090:                      USB_OTGEventHandler(0, OTG_EVENT_DISCONNECT, 0, 0);
5091:              
5092:                      //If SRP Related D+ Low and SRP Is Active, Process D+ Low Event
5093:                      USB_OTGEventHandler(0, OTG_EVENT_SRP_DPLUS_LOW, 0, 0);
5094:              
5095:                      //Disable HNP, Detach Interrupt Could've Triggered From Cable Being Unplugged
5096:                      USBOTGDisableHnp();
5097:              #endif
5098:                  }
5099:              
5100:              #ifdef USB_SUPPORT_OTG
5101:              
5102:                  // -------------------------------------------------------------------------
5103:                  //ID Pin Change ISR
5104:                  if (U1OTGIRbits.IDIF && U1OTGIEbits.IDIE) {
5105:                      USBOTGInitialize();
5106:              
5107:                      //Clear Interrupt Flag
5108:                      U1OTGIR = 0x80;
5109:                  }
5110:              
5111:                  // -------------------------------------------------------------------------
5112:                  //VB_SESS_END ISR
5113:                  if (U1OTGIRbits.SESENDIF && U1OTGIEbits.SESENDIE) {
5114:                      //If B side Host And Cable Was Detached Then
5115:                      if (U1OTGSTATbits.ID == CABLE_B_SIDE && USBOTGCurrentRoleIs() == ROLE_HOST) {
5116:                          //Reinitialize
5117:                          USBOTGInitialize();
5118:                      }
5119:              
5120:                      //Clear Interrupt Flag
5121:                      U1OTGIR = 0x04;
5122:                  }
5123:              
5124:                  // -------------------------------------------------------------------------
5125:                  //VA_SESS_VLD ISR
5126:                  if (U1OTGIRbits.SESVDIF && U1OTGIEbits.SESVDIE) {
5127:                      //If A side Host and SRP Is Active Then
5128:                      if (USBOTGDefaultRoleIs() == ROLE_HOST && USBOTGSrpIsActive()) {
5129:                          //If VBUS > VA_SESS_VLD Then
5130:                          if (U1OTGSTATbits.SESVD == 1) {
5131:                              //Process SRP VBUS High Event
5132:                              USB_OTGEventHandler(0, OTG_EVENT_SRP_VBUS_HIGH, 0, 0);
5133:                          }
5134:                              //If VBUS < VA_SESS_VLD Then
5135:                          else {
5136:                              //Process SRP Low Event
5137:                              USB_OTGEventHandler(0, OTG_EVENT_SRP_VBUS_LOW, 0, 0);
5138:                          }
5139:                      }
5140:              
5141:                      U1OTGIR = 0x08;
5142:                  }
5143:              
5144:                  // -------------------------------------------------------------------------
5145:                  //Resume Signaling for Remote Wakeup
5146:                  if (U1IRbits.RESUMEIF && U1IEbits.RESUMEIE) {
5147:                      //Process SRP VBUS High Event
5148:                      USB_OTGEventHandler(0, OTG_EVENT_RESUME_SIGNALING, 0, 0);
5149:              
5150:                      //Clear Resume Interrupt Flag
5151:                      U1IR = 0x20;
5152:                  }
5153:              #endif
5154:              
5155:              
5156:                  // -------------------------------------------------------------------------
5157:                  // Transfer Done ISR - only process if there was no error
5158:              
5159:                  if ((U1IEbits.TRNIE && U1IRbits.TRNIF) &&
004592  BFC48C     MOV.B U1IE, WREG
004594  A33800     BTST.Z W0, #3
004596  320137     BRA Z, 0x4806
004598  BFC48A     MOV.B U1IR, WREG
00459A  A33800     BTST.Z W0, #3
00459C  320134     BRA Z, 0x4806
00459E  BFC48C     MOV.B U1IE, WREG
0045A0  A31800     BTST.Z W0, #1
0045A2  320008     BRA Z, 0x45B4
0045A4  BFC48A     MOV.B U1IR, WREG
0045A6  A31800     BTST.Z W0, #1
0045A8  320005     BRA Z, 0x45B4
0045AA  807630     MOV pCurrentEndpoint, W0
0045AC  905830     MOV.B [W0+27], W0
0045AE  604063     AND.B W0, #0x3, W0
0045B0  504FE1     SUB.B W0, #0x1, [W15]
0045B2  3A0129     BRA NZ, 0x4806
5160:                          (!(U1IEbits.UERRIE && U1IRbits.UERRIF) || (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS))) {
5161:              #if defined(__C30__)
5162:                      U1STATBITS copyU1STATbits;
5163:              #elif defined(__PIC32MX__)
5164:                      __U1STATbits_t copyU1STATbits;
5165:              #else
5166:              #error Need structure name for copyU1STATbits.
5167:              #endif
5168:                      WORD packetSize;
5169:                      BDT_ENTRY *pBDT;
5170:              
5171:              #ifdef DEBUG_MODE
5172:                      UART2PutChar('!');
5173:              #endif
5174:              
5175:                      // The previous token has finished, so clear the way for writing a new one.
5176:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
0045B4  A98ECA     BCLR usbBusInfo, #4
5177:              
5178:                      copyU1STATbits = U1STATbits; // Read the status register before clearing the flag.
0045B6  802492     MOV U1STAT, W2
5179:              
5180:                      U1IR = USB_INTERRUPT_TRANSFER; // Clear the interrupt by writing a '1' to the flag.
0045B8  200080     MOV #0x8, W0
0045BA  882450     MOV W0, U1IR
5181:              
5182:                      // In host mode, U1STAT does NOT reflect the endpoint.  It is really the last updated
5183:                      // BDT, which, in host mode, is always 0.  To get the endpoint, we either need to look
5184:                      // at U1TOK, or trust that pCurrentEndpoint is still accurate.
5185:                      if ((pCurrentEndpoint->bEndpointAddress & 0x0F) == (U1TOK & 0x0F)) {
0045BC  807633     MOV pCurrentEndpoint, W3
0045BE  9058A3     MOV.B [W3+26], W1
0045C0  8024F0     MOV U1TOK, W0
0045C2  6080EF     AND W1, #0xF, W1
0045C4  60006F     AND W0, #0xF, W0
0045C6  508F80     SUB W1, W0, [W15]
0045C8  3A011D     BRA NZ, 0x4804
5186:                          if (copyU1STATbits.DIR) // TX
0045CA  780002     MOV W2, W0
0045CC  A33802     BTST.Z W2, #3
0045CE  320005     BRA Z, 0x45DA
5187:                          {
5188:                              // We are processing OUT or SETUP packets.
5189:                              // Set up the BDT pointer for the transaction we just received.
5190:              #if (USB_PING_PONG_MODE == USB_PING_PONG__EP0_OUT_ONLY) || (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5191:                              pBDT = BDT_OUT;
5192:                              if (copyU1STATbits.PPBI) // Odd
0045D0  2100C2     MOV #0x100C, W2
0045D2  A32800     BTST.Z W0, #2
0045D4  3A0006     BRA NZ, 0x45E2
0045D6  210082     MOV #0x1008, W2
0045D8  370004     BRA 0x45E2
5193:                              {
5194:                                  pBDT = BDT_OUT_ODD;
5195:                              }
5196:              #elif (USB_PING_PONG_MODE == USB_PING_PONG__NO_PING_PONG) || (USB_PING_PONG_MODE == USB_PING_PONG__ALL_BUT_EP0)
5197:                              pBDT = BDT_OUT;
5198:              #endif
5199:                          } else {
5200:                              // We are processing IN packets.
5201:                              // Set up the BDT pointer for the transaction we just received.
5202:              #if (USB_PING_PONG_MODE == USB_PING_PONG__FULL_PING_PONG)
5203:                              pBDT = BDT_IN;
5204:                              if (copyU1STATbits.PPBI) // Odd
0045DA  210042     MOV #0x1004, W2
0045DC  A32800     BTST.Z W0, #2
0045DE  3A0001     BRA NZ, 0x45E2
0045E0  210002     MOV #0x1000, W2
5205:                              {
5206:                                  pBDT = BDT_IN_ODD;
5207:                              }
5208:              #else
5209:                              pBDT = BDT_IN;
5210:              #endif
5211:                          }
5212:              
5213:                          if (pBDT->STAT.PID == PID_ACK) {
0045E2  23C000     MOV #0x3C00, W0
0045E4  600092     AND W0, [W2], W1
0045E6  208000     MOV #0x800, W0
0045E8  508F80     SUB W1, W0, [W15]
0045EA  3A0046     BRA NZ, 0x4678
5214:                              // We will only get this PID from an OUT or SETUP packet.
5215:              
5216:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5217:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5218:                              // count when an ACK, DATA0, or DATA1 is received.
5219:                              packetSize = pBDT->count;
0045EC  203FF0     MOV #0x3FF, W0
0045EE  600292     AND W0, [W2], W5
5220:                              pCurrentEndpoint->dataCount += packetSize;
0045F0  900803     MOV [W3+16], W0
0045F2  900893     MOV [W3+18], W1
0045F4  400005     ADD W0, W5, W0
0045F6  4880E0     ADDC W1, #0x0, W1
0045F8  980980     MOV W0, [W3+16]
0045FA  980991     MOV W1, [W3+18]
5221:              
5222:                              // Set the NAK retries for the next transaction;
5223:                              pCurrentEndpoint->countNAKs = 0;
0045FC  EB0080     CLR W1
0045FE  807630     MOV pCurrentEndpoint, W0
004600  980871     MOV W1, [W0+30]
5224:              
5225:                              // Toggle DTS for the next transfer.
5226:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
004602  807632     MOV pCurrentEndpoint, W2
004604  904032     MOV.B [W2+3], W0
004606  DE0043     LSR W0, #3, W0
004608  600061     AND W0, #0x1, W0
00460A  A20400     BTG.B W0, #0
00460C  DD0043     SL W0, #3, W0
00460E  9040B2     MOV.B [W2+3], W1
004610  A13401     BCLR.B W1, #3
004612  70C080     IOR.B W1, W0, W1
004614  984131     MOV.B W1, [W2+3]
5227:              
5228:                              if ((pCurrentEndpoint->transferState == (TSTATE_CONTROL_NO_DATA | TSUBSTATE_CONTROL_NO_DATA_SETUP)) ||
004616  807634     MOV pCurrentEndpoint, W4
004618  905804     MOV.B [W4+24], W0
00461A  504FF0     SUB.B W0, #0x10, [W15]
00461C  320008     BRA Z, 0x462E
00461E  905884     MOV.B [W4+24], W1
004620  B3C200     MOV.B #0x20, W0
004622  50CF80     SUB.B W1, W0, [W15]
004624  320004     BRA Z, 0x462E
004626  905884     MOV.B [W4+24], W1
004628  404070     ADD.B W0, #0x10, W0
00462A  50CF80     SUB.B W1, W0, [W15]
00462C  3A000F     BRA NZ, 0x464C
5229:                                      (pCurrentEndpoint->transferState == (TSTATE_CONTROL_READ | TSUBSTATE_CONTROL_READ_SETUP)) ||
5230:                                      (pCurrentEndpoint->transferState == (TSTATE_CONTROL_WRITE | TSUBSTATE_CONTROL_WRITE_SETUP))) {
5231:                                  // We are doing SETUP transfers. See if we are done with the SETUP portion.
5232:                                  if (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMaxSETUP) {
00462E  900904     MOV [W4+16], W2
004630  900994     MOV [W4+18], W3
004632  900074     MOV [W4+14], W0
004634  200001     MOV #0x0, W1
004636  510F80     SUB W2, W0, [W15]
004638  598F81     SUBB W3, W1, [W15]
00463A  3900E4     BRA NC, 0x4804
5233:                                      // We are done with the SETUP.  Reset the byte count and
5234:                                      // proceed to the next token.
5235:                                      pCurrentEndpoint->dataCount = 0;
00463C  B80060     MUL.UU W0, #0, W0
00463E  980A00     MOV W0, [W4+16]
004640  980A11     MOV W1, [W4+18]
5236:                                      _USB_SetNextTransferState();
004642  807631     MOV pCurrentEndpoint, W1
004644  905801     MOV.B [W1+24], W0
004646  E84000     INC.B W0, W0
004648  985880     MOV.B W0, [W1+24]
00464A  3700DC     BRA 0x4804
5237:                                  }
5238:                              } else {
5239:                                  // We are doing OUT transfers.  See if we've written all the data.
5240:                                  // We've written all the data when we send a short packet or we have
5241:                                  // transferred all the data.  If it's an isochronous transfer, this
5242:                                  // portion is complete, so go to the next state, so we can tell the
5243:                                  // next higher layer that a batch of data has been transferred.
5244:                                  if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
00464C  905834     MOV.B [W4+27], W0
00464E  604063     AND.B W0, #0x3, W0
004650  504FE1     SUB.B W0, #0x1, [W15]
004652  32000A     BRA Z, 0x4668
004654  900044     MOV [W4+8], W0
004656  528F80     SUB W5, W0, [W15]
004658  390007     BRA NC, 0x4668
00465A  900904     MOV [W4+16], W2
00465C  900994     MOV [W4+18], W3
00465E  900054     MOV [W4+10], W0
004660  9000E4     MOV [W4+12], W1
004662  510F80     SUB W2, W0, [W15]
004664  598F81     SUBB W3, W1, [W15]
004666  3900CE     BRA NC, 0x4804
5245:                                          (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5246:                                          (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax)) {
5247:                                      // We've written all the data. Proceed to the next step.
5248:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
004668  904034     MOV.B [W4+3], W0
00466A  A00400     BSET.B W0, #0
00466C  984230     MOV.B W0, [W4+3]
5249:                                      _USB_SetNextTransferState();
00466E  807631     MOV pCurrentEndpoint, W1
004670  905801     MOV.B [W1+24], W0
004672  E84000     INC.B W0, W0
004674  985880     MOV.B W0, [W1+24]
004676  3700C6     BRA 0x4804
5250:                                  } else {
5251:                                      // We need to process more data.  Keep this endpoint in its current
5252:                                      // transfer state.
5253:                                  }
5254:                              }
5255:                          } else if ((pBDT->STAT.PID == PID_DATA0) || (pBDT->STAT.PID == PID_DATA1)) {
004678  20C000     MOV #0xC00, W0
00467A  508F80     SUB W1, W0, [W15]
00467C  320003     BRA Z, 0x4684
00467E  22C000     MOV #0x2C00, W0
004680  508F80     SUB W1, W0, [W15]
004682  3A002C     BRA NZ, 0x46DC
5256:                              // We will only get these PID's from an IN packet.
5257:              
5258:                              // Update the count of bytes tranferred.  (If there was an error, this count will be 0.)
5259:                              // The Byte Count is NOT 0 if a NAK occurs.  Therefore, we can only update the
5260:                              // count when an ACK, DATA0, or DATA1 is received.
5261:                              packetSize = pBDT->count;
004684  203FF0     MOV #0x3FF, W0
004686  600292     AND W0, [W2], W5
5262:                              pCurrentEndpoint->dataCount += packetSize;
004688  900803     MOV [W3+16], W0
00468A  900893     MOV [W3+18], W1
00468C  400005     ADD W0, W5, W0
00468E  4880E0     ADDC W1, #0x0, W1
004690  980980     MOV W0, [W3+16]
004692  980991     MOV W1, [W3+18]
5263:              
5264:                              // Set the NAK retries for the next transaction;
5265:                              pCurrentEndpoint->countNAKs = 0;
004694  EB0080     CLR W1
004696  807630     MOV pCurrentEndpoint, W0
004698  980871     MOV W1, [W0+30]
5266:              
5267:                              // Toggle DTS for the next transfer.
5268:                              pCurrentEndpoint->status.bfNextDATA01 ^= 0x01;
00469A  807632     MOV pCurrentEndpoint, W2
00469C  904032     MOV.B [W2+3], W0
00469E  DE0043     LSR W0, #3, W0
0046A0  600061     AND W0, #0x1, W0
0046A2  A20400     BTG.B W0, #0
0046A4  DD0043     SL W0, #3, W0
0046A6  9040B2     MOV.B [W2+3], W1
0046A8  A13401     BCLR.B W1, #3
0046AA  70C080     IOR.B W1, W0, W1
0046AC  984131     MOV.B W1, [W2+3]
5269:              
5270:                              // We are doing IN transfers.  See if we've received all the data.
5271:                              // We've received all the data if it's an isochronous transfer, or when we receive a
5272:                              // short packet or we have transferred all the data.
5273:                              if ((pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) ||
0046AE  807634     MOV pCurrentEndpoint, W4
0046B0  905834     MOV.B [W4+27], W0
0046B2  604063     AND.B W0, #0x3, W0
0046B4  504FE1     SUB.B W0, #0x1, [W15]
0046B6  32000A     BRA Z, 0x46CC
0046B8  900044     MOV [W4+8], W0
0046BA  528F80     SUB W5, W0, [W15]
0046BC  390007     BRA NC, 0x46CC
0046BE  900904     MOV [W4+16], W2
0046C0  900994     MOV [W4+18], W3
0046C2  900054     MOV [W4+10], W0
0046C4  9000E4     MOV [W4+12], W1
0046C6  510F80     SUB W2, W0, [W15]
0046C8  598F81     SUBB W3, W1, [W15]
0046CA  39009C     BRA NC, 0x4804
5274:                                      (packetSize < pCurrentEndpoint->wMaxPacketSize) ||
5275:                                      (pCurrentEndpoint->dataCount >= pCurrentEndpoint->dataCountMax)) {
5276:                                  // If we've received all the data, stop the transfer.  We've received all the
5277:                                  // data when we receive a short or zero-length packet.  If the data length is a
5278:                                  // multiple of wMaxPacketSize, we will get a 0-length packet.
5279:                                  pCurrentEndpoint->status.bfTransferSuccessful = 1;
0046CC  904034     MOV.B [W4+3], W0
0046CE  A00400     BSET.B W0, #0
0046D0  984230     MOV.B W0, [W4+3]
5280:                                  _USB_SetNextTransferState();
0046D2  807631     MOV pCurrentEndpoint, W1
0046D4  905801     MOV.B [W1+24], W0
0046D6  E84000     INC.B W0, W0
0046D8  985880     MOV.B W0, [W1+24]
0046DA  370094     BRA 0x4804
5281:                              } else {
5282:                                  // We need to process more data.  Keep this endpoint in its current
5283:                                  // transfer state.
5284:                              }
5285:                          } else if (pBDT->STAT.PID == PID_NAK) {
0046DC  228000     MOV #0x2800, W0
0046DE  508F80     SUB W1, W0, [W15]
0046E0  3A0064     BRA NZ, 0x47AA
5286:              #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
5287:                              pCurrentEndpoint->status.bfLastTransferNAKd = 1;
0046E2  904033     MOV.B [W3+3], W0
0046E4  A04400     BSET.B W0, #4
0046E6  9841B0     MOV.B W0, [W3+3]
5288:              #endif
5289:              
5290:                              pCurrentEndpoint->countNAKs++;
0046E8  807631     MOV pCurrentEndpoint, W1
0046EA  900871     MOV [W1+30], W0
0046EC  E80000     INC W0, W0
0046EE  9808F0     MOV W0, [W1+30]
5291:              
5292:                              switch (pCurrentEndpoint->bmAttributes.bfTransferType) {
0046F0  807632     MOV pCurrentEndpoint, W2
0046F2  905832     MOV.B [W2+27], W0
0046F4  600063     AND W0, #0x3, W0
0046F6  500FE1     SUB W0, #0x1, [W15]
0046F8  320050     BRA Z, 0x479A
0046FA  3C0003     BRA GT, 0x4702
0046FC  E00000     CP0 W0
0046FE  32001A     BRA Z, 0x4734
004700  370081     BRA 0x4804
004702  500FE2     SUB W0, #0x2, [W15]
004704  320003     BRA Z, 0x470C
004706  500FE3     SUB W0, #0x3, [W15]
004708  3A007D     BRA NZ, 0x4804
00470A  370028     BRA 0x475C
5293:                                  case USB_TRANSFER_TYPE_BULK:
5294:                                      // Bulk IN and OUT transfers are allowed to retry NAK'd
5295:                                      // transactions until a timeout (if enabled) or indefinitely
5296:                                      // (if NAK timeouts disabled).
5297:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
00470C  904032     MOV.B [W2+3], W0
00470E  A35800     BTST.Z W0, #5
004710  320079     BRA Z, 0x4804
004712  9008F2     MOV [W2+30], W1
004714  901002     MOV [W2+32], W0
004716  508F80     SUB W1, W0, [W15]
004718  360075     BRA LEU, 0x4804
5298:                                              (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs)) {
5299:                                          pCurrentEndpoint->status.bfError = 1;
00471A  904022     MOV.B [W2+2], W0
00471C  A06400     BSET.B W0, #6
00471E  984120     MOV.B W0, [W2+2]
5300:                                          pCurrentEndpoint->bErrorCode = USB_ENDPOINT_NAK_TIMEOUT;
004720  B3C171     MOV.B #0x17, W1
004722  807630     MOV pCurrentEndpoint, W0
004724  985841     MOV.B W1, [W0+28]
5301:                                          _USB_SetTransferErrorState(pCurrentEndpoint);
004726  807632     MOV pCurrentEndpoint, W2
004728  905802     MOV.B [W2+24], W0
00472A  B3CF01     MOV.B #0xF0, W1
00472C  604001     AND.B W0, W1, W0
00472E  B340F0     IOR.B #0xF, W0
004730  985900     MOV.B W0, [W2+24]
004732  370068     BRA 0x4804
5302:                                      }
5303:                                      break;
5304:              
5305:                                  case USB_TRANSFER_TYPE_CONTROL:
5306:                                      // Devices should not NAK the SETUP portion.  If they NAK
5307:                                      // the DATA portion, they are allowed to retry a fixed
5308:                                      // number of times.
5309:                                      if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
004734  904032     MOV.B [W2+3], W0
004736  A35800     BTST.Z W0, #5
004738  320065     BRA Z, 0x4804
00473A  9008F2     MOV [W2+30], W1
00473C  901002     MOV [W2+32], W0
00473E  508F80     SUB W1, W0, [W15]
004740  360061     BRA LEU, 0x4804
5310:                                              (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs)) {
5311:                                          pCurrentEndpoint->status.bfError = 1;
004742  904022     MOV.B [W2+2], W0
004744  A06400     BSET.B W0, #6
004746  984120     MOV.B W0, [W2+2]
5312:                                          pCurrentEndpoint->bErrorCode = USB_ENDPOINT_NAK_TIMEOUT;
004748  B3C171     MOV.B #0x17, W1
00474A  807630     MOV pCurrentEndpoint, W0
00474C  985841     MOV.B W1, [W0+28]
5313:                                          _USB_SetTransferErrorState(pCurrentEndpoint);
00474E  807632     MOV pCurrentEndpoint, W2
004750  905802     MOV.B [W2+24], W0
004752  B3CF01     MOV.B #0xF0, W1
004754  604001     AND.B W0, W1, W0
004756  B340F0     IOR.B #0xF, W0
004758  985900     MOV.B W0, [W2+24]
00475A  370054     BRA 0x4804
5314:                                      }
5315:                                      break;
5316:              
5317:                                  case USB_TRANSFER_TYPE_INTERRUPT:
5318:                                      if ((pCurrentEndpoint->bEndpointAddress & 0x80) == 0x00) {
00475C  905822     MOV.B [W2+26], W0
00475E  E00400     CP0.B W0
004760  350014     BRA LT, 0x478A
5319:                                          // Interrupt OUT transfers are allowed to retry NAK'd
5320:                                          // transactions until a timeout (if enabled) or indefinitely
5321:                                          // (if NAK timeouts disabled).
5322:                                          if (pCurrentEndpoint->status.bfNAKTimeoutEnabled &&
004762  904032     MOV.B [W2+3], W0
004764  A35800     BTST.Z W0, #5
004766  32004E     BRA Z, 0x4804
004768  9008F2     MOV [W2+30], W1
00476A  901002     MOV [W2+32], W0
00476C  508F80     SUB W1, W0, [W15]
00476E  36004A     BRA LEU, 0x4804
5323:                                                  (pCurrentEndpoint->countNAKs > pCurrentEndpoint->timeoutNAKs)) {
5324:                                              pCurrentEndpoint->status.bfError = 1;
004770  904022     MOV.B [W2+2], W0
004772  A06400     BSET.B W0, #6
004774  984120     MOV.B W0, [W2+2]
5325:                                              pCurrentEndpoint->bErrorCode = USB_ENDPOINT_NAK_TIMEOUT;
004776  B3C171     MOV.B #0x17, W1
004778  807630     MOV pCurrentEndpoint, W0
00477A  985841     MOV.B W1, [W0+28]
5326:                                              _USB_SetTransferErrorState(pCurrentEndpoint);
00477C  807632     MOV pCurrentEndpoint, W2
00477E  905802     MOV.B [W2+24], W0
004780  B3CF01     MOV.B #0xF0, W1
004782  604001     AND.B W0, W1, W0
004784  B340F0     IOR.B #0xF, W0
004786  985900     MOV.B W0, [W2+24]
004788  37003D     BRA 0x4804
5327:                                          }
5328:                                      } else {
5329:                                          // Interrupt IN transfers terminate with no error.
5330:                                          pCurrentEndpoint->status.bfTransferSuccessful = 1;
00478A  904032     MOV.B [W2+3], W0
00478C  A00400     BSET.B W0, #0
00478E  984130     MOV.B W0, [W2+3]
5331:                                          _USB_SetNextTransferState();
004790  807631     MOV pCurrentEndpoint, W1
004792  905801     MOV.B [W1+24], W0
004794  E84000     INC.B W0, W0
004796  985880     MOV.B W0, [W1+24]
004798  370035     BRA 0x4804
5332:                                      }
5333:                                      break;
5334:              
5335:                                  case USB_TRANSFER_TYPE_ISOCHRONOUS:
5336:                                      // Isochronous transfers terminate with no error.
5337:                                      pCurrentEndpoint->status.bfTransferSuccessful = 1;
00479A  904032     MOV.B [W2+3], W0
00479C  A00400     BSET.B W0, #0
00479E  984130     MOV.B W0, [W2+3]
5338:                                      _USB_SetNextTransferState();
0047A0  807631     MOV pCurrentEndpoint, W1
0047A2  905801     MOV.B [W1+24], W0
0047A4  E84000     INC.B W0, W0
0047A6  985880     MOV.B W0, [W1+24]
0047A8  37002D     BRA 0x4804
5339:                                      break;
5340:                              }
5341:                          } else if (pBDT->STAT.PID == PID_STALL) {
0047AA  238000     MOV #0x3800, W0
0047AC  508F80     SUB W1, W0, [W15]
0047AE  3A000D     BRA NZ, 0x47CA
5342:                              // Device is stalled.  Stop the transfer, and indicate the stall.
5343:                              // The application must clear this if not a control endpoint.
5344:                              // A stall on a control endpoint does not indicate that the
5345:                              // endpoint is halted.
5346:              #ifdef DEBUG_MODE
5347:                              UART2PutChar('^');
5348:              #endif
5349:                              pCurrentEndpoint->status.bfStalled = 1;
0047B0  904023     MOV.B [W3+2], W0
0047B2  A05400     BSET.B W0, #5
0047B4  9841A0     MOV.B W0, [W3+2]
5350:                              pCurrentEndpoint->bErrorCode = USB_ENDPOINT_STALLED;
0047B6  B3C111     MOV.B #0x11, W1
0047B8  807630     MOV pCurrentEndpoint, W0
0047BA  985841     MOV.B W1, [W0+28]
5351:                              _USB_SetTransferErrorState(pCurrentEndpoint);
0047BC  807632     MOV pCurrentEndpoint, W2
0047BE  905802     MOV.B [W2+24], W0
0047C0  B3CF01     MOV.B #0xF0, W1
0047C2  604001     AND.B W0, W1, W0
0047C4  B340F0     IOR.B #0xF, W0
0047C6  985900     MOV.B W0, [W2+24]
0047C8  37001D     BRA 0x4804
5352:                          } else {
5353:                              // Module-defined PID - Bus Timeout (0x0) or Data Error (0x0F).  Increment the error count.
5354:                              // NOTE: If DTS is enabled and the packet has the wrong DTS value, a PID of 0x0F is
5355:                              // returned.  The hardware, however, acknowledges the packet, so the device thinks
5356:                              // that the host has received it.  But the data is not actually received, and the application
5357:                              // layer is not informed of the packet.
5358:                              pCurrentEndpoint->status.bfErrorCount++;
0047CA  9040A3     MOV.B [W3+2], W1
0047CC  E84081     INC.B W1, W1
0047CE  60C0FF     AND.B W1, #0x1F, W1
0047D0  904023     MOV.B [W3+2], W0
0047D2  B3CE02     MOV.B #0xE0, W2
0047D4  604002     AND.B W0, W2, W0
0047D6  704001     IOR.B W0, W1, W0
0047D8  9841A0     MOV.B W0, [W3+2]
5359:              
5360:                              if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS) {
0047DA  807631     MOV pCurrentEndpoint, W1
0047DC  904021     MOV.B [W1+2], W0
0047DE  60007F     AND W0, #0x1F, W0
0047E0  500FF3     SUB W0, #0x13, [W15]
0047E2  340010     BRA LE, 0x4804
5361:                                  // We have too many errors.
5362:              
5363:                                  // Stop the transfer and indicate an error.
5364:                                  // The application must clear this.
5365:                                  pCurrentEndpoint->status.bfError = 1;
0047E4  904021     MOV.B [W1+2], W0
0047E6  A06400     BSET.B W0, #6
0047E8  9840A0     MOV.B W0, [W1+2]
5366:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_ILLEGAL_PID;
0047EA  B3C131     MOV.B #0x13, W1
0047EC  807630     MOV pCurrentEndpoint, W0
0047EE  985841     MOV.B W1, [W0+28]
5367:                                  _USB_SetTransferErrorState(pCurrentEndpoint);
0047F0  807632     MOV pCurrentEndpoint, W2
0047F2  905802     MOV.B [W2+24], W0
0047F4  B3CF01     MOV.B #0xF0, W1
0047F6  604001     AND.B W0, W1, W0
0047F8  B340F0     IOR.B #0xF, W0
0047FA  985900     MOV.B W0, [W2+24]
5368:              
5369:                                  // Avoid the error interrupt code, because we are going to
5370:                                  // find another token to send.
5371:                                  U1EIR = 0xFF;
0047FC  200FF0     MOV #0xFF, W0
0047FE  882470     MOV W0, U1EIR
5372:                                  U1IR = USB_INTERRUPT_ERROR;
004800  200020     MOV #0x2, W0
004802  882450     MOV W0, U1IR
5373:                              } else {
5374:                                  // Fall through.  This will automatically cause the transfer
5375:                                  // to be retried.
5376:                              }
5377:                          }
5378:                      } else {
5379:                          // We have a mismatch between the endpoint we were expecting and the one that we got.
5380:                          // The user may be trying to select a new configuration.  Discard the transaction.
5381:                      }
5382:              
5383:                      _USB_FindNextToken();
004804  07F72D     RCALL _USB_FindNextToken
5384:                  } // U1IRbits.TRNIF
5385:              
5386:              
5387:                  // -------------------------------------------------------------------------
5388:                  // Start-of-Frame ISR
5389:              
5390:                  if (U1IEbits.SOFIE && U1IRbits.SOFIF) {
004806  BFC48C     MOV.B U1IE, WREG
004808  A32800     BTST.Z W0, #2
00480A  32002C     BRA Z, 0x4864
00480C  BFC48A     MOV.B U1IR, WREG
00480E  A32800     BTST.Z W0, #2
004810  320029     BRA Z, 0x4864
5391:                      USB_ENDPOINT_INFO *pEndpoint;
5392:                      USB_INTERFACE_INFO *pInterface;
5393:              
5394:              #if defined(USB_ENABLE_SOF_EVENT) && defined(USB_HOST_APP_DATA_EVENT_HANDLER)
5395:                      //Notify ping all client drivers of SOF event (address, event, data, sizeof_data)
5396:                      _USB_NotifyDataClients(0, EVENT_SOF, NULL, 0);
5397:              #endif
5398:              
5399:              #ifdef DEBUG_MODE
5400:                      //            UART2PutChar( '$' );
5401:              #endif
5402:                      U1IR = USB_INTERRUPT_SOF; // Clear the interrupt by writing a '1' to the flag.
004812  200040     MOV #0x4, W0
004814  882450     MOV W0, U1IR
5403:              
5404:                      pInterface = usbDeviceInfo.pInterfaceList;
004816  8076D3     MOV 0xEDA, W3
5405:                      while (pInterface) {
004818  E00003     CP0 W3
00481A  32001E     BRA Z, 0x4858
004854  E00003     CP0 W3
004856  3AFFE2     BRA NZ, 0x481C
5406:                          if (pInterface->pCurrentSetting) {
00481C  900023     MOV [W3+4], W0
00481E  E00000     CP0 W0
004820  320018     BRA Z, 0x4852
5407:                              pEndpoint = pInterface->pCurrentSetting->pEndpointList;
004822  9000A0     MOV [W0+4], W1
5408:                              while (pEndpoint) {
004824  E00001     CP0 W1
004826  320015     BRA Z, 0x4852
004828  203002     MOV #0x300, W2
00482A  201005     MOV #0x100, W5
00482C  B3CEF4     MOV.B #0xEF, W4
00484E  E00001     CP0 W1
004850  3AFFEE     BRA NZ, 0x482E
5409:                                  // Decrement the interval count of all active interrupt and isochronous endpoints.
5410:                                  if ((pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_INTERRUPT) ||
00482E  900851     MOV [W1+26], W0
004830  600002     AND W0, W2, W0
004832  500F82     SUB W0, W2, [W15]
004834  320002     BRA Z, 0x483A
004836  500F85     SUB W0, W5, [W15]
004838  3A0006     BRA NZ, 0x4846
5411:                                          (pEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS)) {
5412:                                      if (pEndpoint->wIntervalCount != 0) {
00483A  900031     MOV [W1+6], W0
00483C  E00000     CP0 W0
00483E  320003     BRA Z, 0x4846
5413:                                          pEndpoint->wIntervalCount--;
004840  900031     MOV [W1+6], W0
004842  E90000     DEC W0, W0
004844  9800B0     MOV W0, [W1+6]
5414:                                      }
5415:                                  }
5416:              
5417:              #ifndef ALLOW_MULTIPLE_NAKS_PER_FRAME
5418:                                  pEndpoint->status.bfLastTransferNAKd = 0;
004846  904031     MOV.B [W1+3], W0
004848  604004     AND.B W0, W4, W0
00484A  9840B0     MOV.B W0, [W1+3]
5419:              #endif
5420:              
5421:                                  pEndpoint = pEndpoint->next;
00484C  780091     MOV [W1], W1
5422:                              }
5423:                          }
5424:              
5425:                          pInterface = pInterface->next;
004852  780193     MOV [W3], W3
5426:                      }
5427:              
5428:                      usbBusInfo.flags.bfControlTransfersDone = 0;
004858  A90ECA     BCLR usbBusInfo, #0
5429:                      usbBusInfo.flags.bfInterruptTransfersDone = 0;
00485A  A92ECA     BCLR usbBusInfo, #1
5430:                      usbBusInfo.flags.bfIsochronousTransfersDone = 0;
00485C  A94ECA     BCLR usbBusInfo, #2
5431:                      usbBusInfo.flags.bfBulkTransfersDone = 0;
00485E  A96ECA     BCLR usbBusInfo, #3
5432:                      //usbBusInfo.dBytesSentInFrame                = 0;
5433:                      usbBusInfo.lastBulkTransaction = 0;
004860  EF6ECC     CLR.B 0xECC
5434:              
5435:                      _USB_FindNextToken();
004862  07F6FE     RCALL _USB_FindNextToken
5436:                  }
5437:              
5438:                  // -------------------------------------------------------------------------
5439:                  // USB Error ISR
5440:              
5441:                  if (U1IEbits.UERRIE && U1IRbits.UERRIF) {
004864  BFC48C     MOV.B U1IE, WREG
004866  A31800     BTST.Z W0, #1
004868  32004C     BRA Z, 0x4902
00486A  BFC48A     MOV.B U1IR, WREG
00486C  A31800     BTST.Z W0, #1
00486E  320049     BRA Z, 0x4902
5442:              #ifdef DEBUG_MODE
5443:                      UART2PutChar('#');
5444:                      UART2PutHex(U1EIR);
5445:              #endif
5446:              
5447:                      // The previous token has finished, so clear the way for writing a new one.
5448:                      usbBusInfo.flags.bfTokenAlreadyWritten = 0;
004870  A98ECA     BCLR usbBusInfo, #4
5449:              
5450:                      // If we are doing isochronous transfers, ignore the error.
5451:                      if (pCurrentEndpoint->bmAttributes.bfTransferType == USB_TRANSFER_TYPE_ISOCHRONOUS) {
004872  807633     MOV pCurrentEndpoint, W3
004874  905833     MOV.B [W3+27], W0
004876  604063     AND.B W0, #0x3, W0
004878  504FE1     SUB.B W0, #0x1, [W15]
00487A  32003F     BRA Z, 0x48FA
5452:                          //            pCurrentEndpoint->status.bfTransferSuccessful = 1;
5453:                          //            _USB_SetNextTransferState();
5454:                      } else {
5455:                          // Increment the error count.
5456:                          pCurrentEndpoint->status.bfErrorCount++;
00487C  9040A3     MOV.B [W3+2], W1
00487E  E84081     INC.B W1, W1
004880  60C0FF     AND.B W1, #0x1F, W1
004882  904023     MOV.B [W3+2], W0
004884  B3CE02     MOV.B #0xE0, W2
004886  604002     AND.B W0, W2, W0
004888  704001     IOR.B W0, W1, W0
00488A  9841A0     MOV.B W0, [W3+2]
5457:              
5458:                          if (pCurrentEndpoint->status.bfErrorCount >= USB_TRANSACTION_RETRY_ATTEMPTS) {
00488C  807631     MOV pCurrentEndpoint, W1
00488E  904021     MOV.B [W1+2], W0
004890  60007F     AND W0, #0x1F, W0
004892  500FF3     SUB W0, #0x13, [W15]
004894  340032     BRA LE, 0x48FA
5459:                              // We have too many errors.
5460:              
5461:                              // Check U1EIR for the appropriate error codes to return
5462:                              if (U1EIRbits.BTSEF)
004896  E2448E     CP0.B U1EIR
004898  3D0002     BRA GE, 0x489E
5463:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BIT_STUFF;
00489A  B3C200     MOV.B #0x20, W0
00489C  9858C0     MOV.B W0, [W1+28]
5464:                              if (U1EIRbits.DMAEF)
00489E  BFC48E     MOV.B U1EIR, WREG
0048A0  A35800     BTST.Z W0, #5
0048A2  320003     BRA Z, 0x48AA
5465:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DMA;
0048A4  B3C211     MOV.B #0x21, W1
0048A6  807630     MOV pCurrentEndpoint, W0
0048A8  985841     MOV.B W1, [W0+28]
5466:                              if (U1EIRbits.BTOEF)
0048AA  BFC48E     MOV.B U1EIR, WREG
0048AC  A34800     BTST.Z W0, #4
0048AE  320003     BRA Z, 0x48B6
5467:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_TIMEOUT;
0048B0  B3C221     MOV.B #0x22, W1
0048B2  807630     MOV pCurrentEndpoint, W0
0048B4  985841     MOV.B W1, [W0+28]
5468:                              if (U1EIRbits.DFN8EF)
0048B6  BFC48E     MOV.B U1EIR, WREG
0048B8  A33800     BTST.Z W0, #3
0048BA  320003     BRA Z, 0x48C2
5469:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_DATA_FIELD;
0048BC  B3C231     MOV.B #0x23, W1
0048BE  807630     MOV pCurrentEndpoint, W0
0048C0  985841     MOV.B W1, [W0+28]
5470:                              if (U1EIRbits.CRC16EF)
0048C2  BFC48E     MOV.B U1EIR, WREG
0048C4  A32800     BTST.Z W0, #2
0048C6  320003     BRA Z, 0x48CE
5471:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_CRC16;
0048C8  B3C241     MOV.B #0x24, W1
0048CA  807630     MOV pCurrentEndpoint, W0
0048CC  985841     MOV.B W1, [W0+28]
5472:                              if (U1EIRbits.EOFEF)
0048CE  BFC48E     MOV.B U1EIR, WREG
0048D0  A31800     BTST.Z W0, #1
0048D2  320003     BRA Z, 0x48DA
5473:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_END_OF_FRAME;
0048D4  B3C251     MOV.B #0x25, W1
0048D6  807630     MOV pCurrentEndpoint, W0
0048D8  985841     MOV.B W1, [W0+28]
5474:                              if (U1EIRbits.PIDEF)
0048DA  BFC48E     MOV.B U1EIR, WREG
0048DC  A30800     BTST.Z W0, #0
0048DE  320003     BRA Z, 0x48E6
5475:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_PID_CHECK;
0048E0  B3C261     MOV.B #0x26, W1
0048E2  807630     MOV pCurrentEndpoint, W0
0048E4  985841     MOV.B W1, [W0+28]
5476:              #if defined(__PIC32MX__)
5477:                              if (U1EIRbits.BMXEF)
5478:                                  pCurrentEndpoint->bErrorCode = USB_ENDPOINT_ERROR_BMX;
5479:              #endif
5480:              
5481:                              pCurrentEndpoint->status.bfError = 1;
0048E6  807631     MOV pCurrentEndpoint, W1
0048E8  904021     MOV.B [W1+2], W0
0048EA  A06400     BSET.B W0, #6
0048EC  9840A0     MOV.B W0, [W1+2]
5482:              
5483:                              _USB_SetTransferErrorState(pCurrentEndpoint);
0048EE  807632     MOV pCurrentEndpoint, W2
0048F0  905802     MOV.B [W2+24], W0
0048F2  B3CF01     MOV.B #0xF0, W1
0048F4  604001     AND.B W0, W1, W0
0048F6  B340F0     IOR.B #0xF, W0
0048F8  985900     MOV.B W0, [W2+24]
5484:                          }
5485:                      }
5486:              
5487:                      U1EIR = 0xFF; // Clear the interrupts by writing '1' to the flags.
0048FA  200FF0     MOV #0xFF, W0
0048FC  882470     MOV W0, U1EIR
5488:                      U1IR = USB_INTERRUPT_ERROR; // Clear the interrupt by writing a '1' to the flag.
0048FE  200020     MOV #0x2, W0
004900  882450     MOV W0, U1IR
5489:                  }
5490:              }
004902  BE034F     MOV.D [--W15], W6
004904  BE024F     MOV.D [--W15], W4
004906  BE014F     MOV.D [--W15], W2
004908  BE004F     MOV.D [--W15], W0
00490A  F90036     POP RCOUNT
00490C  064000     RETFIE
5491:              
5492:              
5493:              /*************************************************************************
5494:               * EOF usb_host.c
5495:               */
5496:              
---  D:/PIC/PIC_PS4_Host/trunk/PS4_controller.c  --------------------------------------------------------
1:                 /***********************************************************************
2:                     PS4 USB Host
3:                     Copyright (C) 2013 Cross Product Creations
4:                 
5:                     This program is free software: you can redistribute it and/or modify
6:                     it under the terms of the GNU General Public License as published by
7:                     the Free Software Foundation, either version 3 of the License, or
8:                     (at your option) any later version.
9:                 
10:                    This program is distributed in the hope that it will be useful,
11:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                    GNU General Public License for more details.
14:                
15:                    You should have received a copy of the GNU General Public License
16:                    along with this program.  If not, see <http://www.gnu.org/licenses/>.
17:                 *************************************************************************/
18:                
19:                #include "USB\usb.h"
20:                #include "USB\usb_host_generic_PS4.h"
21:                #include "PS4_controller.h"
22:                #include "uart2.h"
23:                #include "PS4_SPI.h"
24:                #include "main.h"
25:                
26:                
27:                volatile BYTE outputReportBT[DATA_PACKET_LENGTH] = {0};
28:                
29:                //USB Wire report is shorter, doesn't have the Bluetooth headers
30:                static volatile BYTE *outputReportWire = &outputReportBT[11]; //USB version of the packet has smaller header, remember to edit the header for USB
31:                static volatile CONTROLLER_OUTPUT *PS4OutputPtr = (CONTROLLER_OUTPUT*) outputReportBT;
32:                
33:                //////////////////////////////PRIVATE VARIABLES//////////////////////////////////
34:                static volatile BUTTONS LastPress;
35:                static volatile BUTTONS NewPress;
36:                static volatile BUTTONS PressDuration;
37:                static volatile CONTROLLER_STATE_BUFFER CurrentStateBuffer;
38:                
39:                //static volatile TOUCHPAD_STRUCT Touchpads;
40:                
41:                static volatile BYTE PS4_report_buf[PS4_REPORT_LENGTH];
42:                static volatile unsigned int idleTimer = 0;
43:                
44:                void CopyPS4Report(CONTROLLER_IN* ControllerIn){
00805E  EB0080     CLR W1
008060  20C3C3     MOV #0xC3C, W3
008062  2003D2     MOV #0x3D, W2
45:                    unsigned int i = 0;
46:                    for (i = 0; i < PS4_REPORT_LENGTH; i++) {  //have to do a deep copy
008066  E80081     INC W1, W1
008068  508F82     SUB W1, W2, [W15]
00806A  3AFFFC     BRA NZ, 0x8064
47:                        PS4_report_buf[i] = ((BYTE*) ControllerIn)[i]; //need this for SPI data; copy this over because hci_buf and acl_buf don't always contain dualshock packets
008064  78F1E0     MOV.B [W0+W1], [W3+W1]
48:                    }
49:                }
00806C  060000     RETURN
50:                
51:                
52:                void CopySpaceNavigatorReport(BYTE packet[], unsigned char length){
00806E  780200     MOV W0, W4
008070  784281     MOV.B W1, W5
53:                    int x,y,z;
54:                    switch (((SPACE_NAV_PACKET6*)packet)->id)
008072  780180     MOV W0, W3
008074  784010     MOV.B [W0], W0
008076  504FE2     SUB.B W0, #0x2, [W15]
008078  320084     BRA Z, 0x8182
00807A  504FE3     SUB.B W0, #0x3, [W15]
00807C  3200BF     BRA Z, 0x81FC
00807E  504FE1     SUB.B W0, #0x1, [W15]
008080  3A014D     BRA NZ, 0x831C
55:                    {
56:                        case 1:
57:                            if (length == 7 || length == 13)
008082  50CFE7     SUB.B W1, #0x7, [W15]
008084  320002     BRA Z, 0x808A
008086  50CFED     SUB.B W1, #0xD, [W15]
008088  3A0149     BRA NZ, 0x831C
58:                            {
59:                                x = ((SPACE_NAV_PACKET6*)packet)->x/2+127;
00808A  904093     MOV.B [W3+1], W1
00808C  FB8081     ZE W1, W1
00808E  904023     MOV.B [W3+2], W0
008090  DD0048     SL W0, #8, W0
008092  700001     IOR W0, W1, W0
008094  200022     MOV #0x2, W2
008096  090011     REPEAT #0x11
008098  D80002     DIV.SW W0, W2
00809A  2007F7     MOV #0x7F, W7
00809C  438380     ADD W7, W0, W7
60:                                if (x > 255) x = 255;
00809E  200FF0     MOV #0xFF, W0
0080A0  538F80     SUB W7, W0, [W15]
0080A2  340002     BRA LE, 0x80A8
0080A4  780380     MOV W0, W7
0080A6  370003     BRA 0x80AE
61:                                else if (x < 0) x = 0;
0080A8  E00007     CP0 W7
0080AA  3D0001     BRA GE, 0x80AE
0080AC  EB0380     CLR W7
62:                                
63:                                y = ((SPACE_NAV_PACKET6*)packet)->y/2+127;
0080AE  9040B3     MOV.B [W3+3], W1
0080B0  FB8081     ZE W1, W1
0080B2  904043     MOV.B [W3+4], W0
0080B4  DD0048     SL W0, #8, W0
0080B6  700001     IOR W0, W1, W0
0080B8  200022     MOV #0x2, W2
0080BA  090011     REPEAT #0x11
0080BC  D80002     DIV.SW W0, W2
0080BE  2007F6     MOV #0x7F, W6
0080C0  430300     ADD W6, W0, W6
64:                                if (y > 255) y = 255;
0080C2  200FF0     MOV #0xFF, W0
0080C4  530F80     SUB W6, W0, [W15]
0080C6  340002     BRA LE, 0x80CC
0080C8  780300     MOV W0, W6
0080CA  370003     BRA 0x80D2
65:                                else if (y < 0) y = 0;
0080CC  E00006     CP0 W6
0080CE  3D0001     BRA GE, 0x80D2
0080D0  EB0300     CLR W6
66:                                
67:                                z = ((SPACE_NAV_PACKET6*)packet)->z/2+127;
0080D2  9040D3     MOV.B [W3+5], W1
0080D4  FB8081     ZE W1, W1
0080D6  904063     MOV.B [W3+6], W0
0080D8  DD0048     SL W0, #8, W0
0080DA  700001     IOR W0, W1, W0
0080DC  200022     MOV #0x2, W2
0080DE  090011     REPEAT #0x11
0080E0  D80002     DIV.SW W0, W2
0080E2  B007F0     ADD #0x7F, W0
68:                                if (z > 255) z = 255;
0080E4  200FF1     MOV #0xFF, W1
0080E6  500F81     SUB W0, W1, [W15]
0080E8  340002     BRA LE, 0x80EE
0080EA  780001     MOV W1, W0
0080EC  370003     BRA 0x80F4
69:                                else if (z < 0) z = 0;
0080EE  E00000     CP0 W0
0080F0  3D0001     BRA GE, 0x80F4
0080F2  EB0000     CLR W0
70:                                
71:                                ((CONTROLLER_IN*)PS4_report_buf)->lStickX = (unsigned char)x;
0080F4  FD0380     EXCH W0, W7
0080F6  B7EC3D     MOV.B WREG, 0xC3D
0080F8  FD0380     EXCH W0, W7
72:                                ((CONTROLLER_IN*)PS4_report_buf)->lStickY = (unsigned char)y;
0080FA  FD0300     EXCH W0, W6
0080FC  B7EC3E     MOV.B WREG, 0xC3E
0080FE  FD0300     EXCH W0, W6
73:                                ((CONTROLLER_IN*)PS4_report_buf)->rStickX = (unsigned char)z;
008100  B7EC3F     MOV.B WREG, 0xC3F
74:                                
75:                                if (length == 13)
008102  52CFED     SUB.B W5, #0xD, [W15]
008104  3A010B     BRA NZ, 0x831C
76:                                {
77:                                    x = ((SPACE_NAV_PACKET13*)packet)->x2/2+127;
008106  780284     MOV W4, W5
008108  9040F4     MOV.B [W4+7], W1
00810A  FB8081     ZE W1, W1
00810C  904804     MOV.B [W4+8], W0
00810E  DD0048     SL W0, #8, W0
008110  700001     IOR W0, W1, W0
008112  200022     MOV #0x2, W2
008114  090011     REPEAT #0x11
008116  D80002     DIV.SW W0, W2
008118  2007F4     MOV #0x7F, W4
00811A  420200     ADD W4, W0, W4
78:                                    if (x > 255) x = 255;
00811C  200FF0     MOV #0xFF, W0
00811E  520F80     SUB W4, W0, [W15]
008120  340002     BRA LE, 0x8126
008122  780200     MOV W0, W4
008124  370003     BRA 0x812C
79:                                    else if (x < 0) x = 0;
008126  E00004     CP0 W4
008128  3D0001     BRA GE, 0x812C
00812A  EB0200     CLR W4
80:                
81:                                    y = ((SPACE_NAV_PACKET13*)packet)->y2/2+127;
00812C  904895     MOV.B [W5+9], W1
00812E  FB8081     ZE W1, W1
008130  904825     MOV.B [W5+10], W0
008132  DD0048     SL W0, #8, W0
008134  700001     IOR W0, W1, W0
008136  200022     MOV #0x2, W2
008138  090011     REPEAT #0x11
00813A  D80002     DIV.SW W0, W2
00813C  2007F3     MOV #0x7F, W3
00813E  418180     ADD W3, W0, W3
82:                                    if (y > 255) y = 255;
008140  200FF0     MOV #0xFF, W0
008142  518F80     SUB W3, W0, [W15]
008144  340002     BRA LE, 0x814A
008146  780180     MOV W0, W3
008148  370003     BRA 0x8150
83:                                    else if (y < 0) y = 0;
00814A  E00003     CP0 W3
00814C  3D0001     BRA GE, 0x8150
00814E  EB0180     CLR W3
84:                
85:                                    z = ((SPACE_NAV_PACKET13*)packet)->z2/2+127;
008150  9048B5     MOV.B [W5+11], W1
008152  FB8081     ZE W1, W1
008154  904845     MOV.B [W5+12], W0
008156  DD0048     SL W0, #8, W0
008158  700001     IOR W0, W1, W0
00815A  200022     MOV #0x2, W2
00815C  090011     REPEAT #0x11
00815E  D80002     DIV.SW W0, W2
008160  B007F0     ADD #0x7F, W0
86:                                    if (z > 255) z = 255;
008162  200FF1     MOV #0xFF, W1
008164  500F81     SUB W0, W1, [W15]
008166  340002     BRA LE, 0x816C
008168  780001     MOV W1, W0
00816A  370003     BRA 0x8172
87:                                    else if (z < 0) z = 0;
00816C  E00000     CP0 W0
00816E  3D0001     BRA GE, 0x8172
008170  EB0000     CLR W0
88:                
89:                                    ((CONTROLLER_IN*)PS4_report_buf)->rStickY = (unsigned char)x;
008172  FD0200     EXCH W0, W4
008174  B7EC40     MOV.B WREG, 0xC40
008176  FD0200     EXCH W0, W4
90:                                    ((CONTROLLER_IN*)PS4_report_buf)->lTriggerAnalog = (unsigned char)y;
008178  FD0180     EXCH W0, W3
00817A  B7EC44     MOV.B WREG, 0xC44
00817C  FD0180     EXCH W0, W3
91:                                    ((CONTROLLER_IN*)PS4_report_buf)->rTriggerAnalog = (unsigned char)z;       
00817E  B7EC45     MOV.B WREG, 0xC45
008180  3700CD     BRA 0x831C
92:                
93:                                }
94:                            }
95:                
96:                            else{
97:                #ifdef DEBUG_MODE
98:                                UART2PrintString("packet length?\n\r");
99:                #endif
100:                           }
101:                           break;
102:                       case 2:
103:                           x = ((SPACE_NAV_PACKET6*)packet)->x/2+127;
008182  904094     MOV.B [W4+1], W1
008184  FB8081     ZE W1, W1
008186  904024     MOV.B [W4+2], W0
008188  DD0048     SL W0, #8, W0
00818A  700001     IOR W0, W1, W0
00818C  200022     MOV #0x2, W2
00818E  090011     REPEAT #0x11
008190  D80002     DIV.SW W0, W2
008192  2007F5     MOV #0x7F, W5
008194  428280     ADD W5, W0, W5
104:                           if (x > 255) x = 255;
008196  200FF0     MOV #0xFF, W0
008198  528F80     SUB W5, W0, [W15]
00819A  340002     BRA LE, 0x81A0
00819C  780280     MOV W0, W5
00819E  370003     BRA 0x81A6
105:                           else if (x < 0) x = 0;
0081A0  E00005     CP0 W5
0081A2  3D0001     BRA GE, 0x81A6
0081A4  EB0280     CLR W5
106:               
107:                           y = ((SPACE_NAV_PACKET6*)packet)->y/2+127;
0081A6  9040B3     MOV.B [W3+3], W1
0081A8  FB8081     ZE W1, W1
0081AA  904043     MOV.B [W3+4], W0
0081AC  DD0048     SL W0, #8, W0
0081AE  700001     IOR W0, W1, W0
0081B0  200022     MOV #0x2, W2
0081B2  090011     REPEAT #0x11
0081B4  D80002     DIV.SW W0, W2
0081B6  2007F4     MOV #0x7F, W4
0081B8  420200     ADD W4, W0, W4
108:                           if (y > 255) y = 255;
0081BA  200FF0     MOV #0xFF, W0
0081BC  520F80     SUB W4, W0, [W15]
0081BE  340002     BRA LE, 0x81C4
0081C0  780200     MOV W0, W4
0081C2  370003     BRA 0x81CA
109:                           else if (y < 0) y = 0;
0081C4  E00004     CP0 W4
0081C6  3D0001     BRA GE, 0x81CA
0081C8  EB0200     CLR W4
110:               
111:                           z = ((SPACE_NAV_PACKET6*)packet)->z/2+127;
0081CA  9040D3     MOV.B [W3+5], W1
0081CC  FB8081     ZE W1, W1
0081CE  904063     MOV.B [W3+6], W0
0081D0  DD0048     SL W0, #8, W0
0081D2  700001     IOR W0, W1, W0
0081D4  200022     MOV #0x2, W2
0081D6  090011     REPEAT #0x11
0081D8  D80002     DIV.SW W0, W2
0081DA  B007F0     ADD #0x7F, W0
112:                           if (z > 255) z = 255;
0081DC  200FF1     MOV #0xFF, W1
0081DE  500F81     SUB W0, W1, [W15]
0081E0  340002     BRA LE, 0x81E6
0081E2  780001     MOV W1, W0
0081E4  370003     BRA 0x81EC
113:                           else if (z < 0) z = 0;
0081E6  E00000     CP0 W0
0081E8  3D0001     BRA GE, 0x81EC
0081EA  EB0000     CLR W0
114:               
115:                           ((CONTROLLER_IN*)PS4_report_buf)->rStickY = (unsigned char)x;
0081EC  FD0280     EXCH W0, W5
0081EE  B7EC40     MOV.B WREG, 0xC40
0081F0  FD0280     EXCH W0, W5
116:                           ((CONTROLLER_IN*)PS4_report_buf)->lTriggerAnalog = (unsigned char)y;
0081F2  FD0200     EXCH W0, W4
0081F4  B7EC44     MOV.B WREG, 0xC44
0081F6  FD0200     EXCH W0, W4
117:                           ((CONTROLLER_IN*)PS4_report_buf)->rTriggerAnalog = (unsigned char)z;
0081F8  B7EC45     MOV.B WREG, 0xC45
0081FA  370090     BRA 0x831C
118:                           break;
119:                       case 3:
120:                           if (length > 2)
0081FC  50CFE2     SUB.B W1, #0x2, [W15]
0081FE  36008E     BRA LEU, 0x831C
121:                           {
122:                               if ( ((SPACE_NAV_BUTTONS*)packet)->esc ) ((CONTROLLER_IN*)PS4_report_buf)->dPad |= 0b0001;
008200  780304     MOV W4, W6
008202  904014     MOV.B [W4+1], W0
008204  A36800     BTST.Z W0, #6
008206  320008     BRA Z, 0x8218
008208  BFCC41     MOV.B 0xC41, WREG
00820A  6040EF     AND.B W0, #0xF, W1
00820C  A00401     BSET.B W1, #0
00820E  B3CF02     MOV.B #0xF0, W2
008210  604002     AND.B W0, W2, W0
008212  704001     IOR.B W0, W1, W0
008214  B7EC41     MOV.B WREG, 0xC41
008216  370001     BRA 0x821A
123:                               else ((CONTROLLER_IN*)PS4_report_buf)->dPad &= 0b1110;
008218  A90C41     BCLR 0xC41, #0
124:                               if ( ((SPACE_NAV_BUTTONS*)packet)->ctrl ) ((CONTROLLER_IN*)PS4_report_buf)->dPad |= 0b0010;
00821A  904026     MOV.B [W6+2], W0
00821C  A31800     BTST.Z W0, #1
00821E  320008     BRA Z, 0x8230
008220  BFCC41     MOV.B 0xC41, WREG
008222  6040EF     AND.B W0, #0xF, W1
008224  A01401     BSET.B W1, #1
008226  B3CF02     MOV.B #0xF0, W2
008228  604002     AND.B W0, W2, W0
00822A  704001     IOR.B W0, W1, W0
00822C  B7EC41     MOV.B WREG, 0xC41
00822E  370001     BRA 0x8232
125:                               else ((CONTROLLER_IN*)PS4_report_buf)->dPad &= 0b1101;
008230  A92C41     BCLR 0xC41, #1
126:                               if ( ((SPACE_NAV_BUTTONS*)packet)->alt ) ((CONTROLLER_IN*)PS4_report_buf)->dPad |= 0b0100;
008232  904016     MOV.B [W6+1], W0
008234  E00400     CP0.B W0
008236  3D0008     BRA GE, 0x8248
008238  BFCC41     MOV.B 0xC41, WREG
00823A  6040EF     AND.B W0, #0xF, W1
00823C  A02401     BSET.B W1, #2
00823E  B3CF02     MOV.B #0xF0, W2
008240  604002     AND.B W0, W2, W0
008242  704001     IOR.B W0, W1, W0
008244  B7EC41     MOV.B WREG, 0xC41
008246  370001     BRA 0x824A
127:                               else ((CONTROLLER_IN*)PS4_report_buf)->dPad &= 0b1011;
008248  A94C41     BCLR 0xC41, #2
128:                               if ( ((SPACE_NAV_BUTTONS*)packet)->shift ) ((CONTROLLER_IN*)PS4_report_buf)->dPad |= 0b1000;
00824A  904026     MOV.B [W6+2], W0
00824C  A30800     BTST.Z W0, #0
00824E  320008     BRA Z, 0x8260
008250  BFCC41     MOV.B 0xC41, WREG
008252  6040EF     AND.B W0, #0xF, W1
008254  A03401     BSET.B W1, #3
008256  B3CF02     MOV.B #0xF0, W2
008258  604002     AND.B W0, W2, W0
00825A  704001     IOR.B W0, W1, W0
00825C  B7EC41     MOV.B WREG, 0xC41
00825E  370001     BRA 0x8262
129:                               else ((CONTROLLER_IN*)PS4_report_buf)->dPad &= 0b0111;
008260  A96C41     BCLR 0xC41, #3
130:                               ((CONTROLLER_IN*)PS4_report_buf)->triangle = ((SPACE_NAV_BUTTONS*)packet)->T;
008262  904016     MOV.B [W6+1], W0
008264  DE0042     LSR W0, #2, W0
008266  600061     AND W0, #0x1, W0
008268  DD0047     SL W0, #7, W0
00826A  20C411     MOV #0xC41, W1
00826C  784091     MOV.B [W1], W1
00826E  A17401     BCLR.B W1, #7
008270  70C080     IOR.B W1, W0, W1
008272  780001     MOV W1, W0
008274  B7EC41     MOV.B WREG, 0xC41
131:                               ((CONTROLLER_IN*)PS4_report_buf)->circle = ((SPACE_NAV_BUTTONS*)packet)->R;
008276  904016     MOV.B [W6+1], W0
008278  DE0044     LSR W0, #4, W0
00827A  600061     AND W0, #0x1, W0
00827C  DD0046     SL W0, #6, W0
00827E  B3CBF2     MOV.B #0xBF, W2
008280  60C082     AND.B W1, W2, W1
008282  70C080     IOR.B W1, W0, W1
008284  780001     MOV W1, W0
008286  B7EC41     MOV.B WREG, 0xC41
132:                               ((CONTROLLER_IN*)PS4_report_buf)->cross = ((SPACE_NAV_BUTTONS*)packet)->F;
008288  904016     MOV.B [W6+1], W0
00828A  DE0045     LSR W0, #5, W0
00828C  600061     AND W0, #0x1, W0
00828E  DD0045     SL W0, #5, W0
008290  B3CDF4     MOV.B #0xDF, W4
008292  60C084     AND.B W1, W4, W1
008294  70C080     IOR.B W1, W0, W1
008296  780001     MOV W1, W0
008298  B7EC41     MOV.B WREG, 0xC41
133:                               ((CONTROLLER_IN*)PS4_report_buf)->square = ((SPACE_NAV_BUTTONS*)packet)->L;
00829A  904016     MOV.B [W6+1], W0
00829C  DE0043     LSR W0, #3, W0
00829E  600061     AND W0, #0x1, W0
0082A0  DD0044     SL W0, #4, W0
0082A2  B3CEF3     MOV.B #0xEF, W3
0082A4  60C083     AND.B W1, W3, W1
0082A6  70C080     IOR.B W1, W0, W1
0082A8  780001     MOV W1, W0
0082AA  B7EC41     MOV.B WREG, 0xC41
134:                               ((CONTROLLER_IN*)PS4_report_buf)->lBumper = ((SPACE_NAV_BUTTONS*)packet)->one;
0082AC  904016     MOV.B [W6+1], W0
0082AE  604061     AND.B W0, #0x1, W0
0082B0  B3CFE5     MOV.B #0xFE, W5
0082B2  20C421     MOV #0xC42, W1
0082B4  784091     MOV.B [W1], W1
0082B6  60C085     AND.B W1, W5, W1
0082B8  70C080     IOR.B W1, W0, W1
0082BA  780001     MOV W1, W0
0082BC  B7EC42     MOV.B WREG, 0xC42
135:                               ((CONTROLLER_IN*)PS4_report_buf)->rBumper = ((SPACE_NAV_BUTTONS*)packet)->plus;
0082BE  904026     MOV.B [W6+2], W0
0082C0  DE0044     LSR W0, #4, W0
0082C2  600061     AND W0, #0x1, W0
0082C4  404000     ADD.B W0, W0, W0
0082C6  A11401     BCLR.B W1, #1
0082C8  70C080     IOR.B W1, W0, W1
0082CA  780001     MOV W1, W0
0082CC  B7EC42     MOV.B WREG, 0xC42
136:                               ((CONTROLLER_IN*)PS4_report_buf)->lStickPress = ((SPACE_NAV_BUTTONS*)packet)->two;
0082CE  904016     MOV.B [W6+1], W0
0082D0  D10000     LSR W0, W0
0082D2  600061     AND W0, #0x1, W0
0082D4  DD0046     SL W0, #6, W0
0082D6  60C082     AND.B W1, W2, W1
0082D8  70C080     IOR.B W1, W0, W1
0082DA  780001     MOV W1, W0
0082DC  B7EC42     MOV.B WREG, 0xC42
137:                               ((CONTROLLER_IN*)PS4_report_buf)->rStickPress = ((SPACE_NAV_BUTTONS*)packet)->minus;
0082DE  904026     MOV.B [W6+2], W0
0082E0  DE0045     LSR W0, #5, W0
0082E2  600061     AND W0, #0x1, W0
0082E4  DD0047     SL W0, #7, W0
0082E6  A17401     BCLR.B W1, #7
0082E8  70C080     IOR.B W1, W0, W1
0082EA  780001     MOV W1, W0
0082EC  B7EC42     MOV.B WREG, 0xC42
138:                               ((CONTROLLER_IN*)PS4_report_buf)->options = ((SPACE_NAV_BUTTONS*)packet)->fit;
0082EE  904026     MOV.B [W6+2], W0
0082F0  DE0042     LSR W0, #2, W0
0082F2  600061     AND W0, #0x1, W0
0082F4  DD0045     SL W0, #5, W0
0082F6  60C084     AND.B W1, W4, W1
0082F8  70C080     IOR.B W1, W0, W1
0082FA  780001     MOV W1, W0
0082FC  B7EC42     MOV.B WREG, 0xC42
139:                               ((CONTROLLER_IN*)PS4_report_buf)->share = ((SPACE_NAV_BUTTONS*)packet)->panel;
0082FE  904026     MOV.B [W6+2], W0
008300  DE0043     LSR W0, #3, W0
008302  600061     AND W0, #0x1, W0
008304  DD0044     SL W0, #4, W0
008306  60C083     AND.B W1, W3, W1
008308  70C080     IOR.B W1, W0, W1
00830A  780001     MOV W1, W0
00830C  B7EC42     MOV.B WREG, 0xC42
140:                               ((CONTROLLER_IN*)PS4_report_buf)->psButton = ((SPACE_NAV_BUTTONS*)packet)->twoD;
00830E  9040A6     MOV.B [W6+2], W1
008310  DE08C6     LSR W1, #6, W1
008312  6080E1     AND W1, #0x1, W1
008314  BFCC43     MOV.B 0xC43, WREG
008316  604005     AND.B W0, W5, W0
008318  704001     IOR.B W0, W1, W0
00831A  B7EC43     MOV.B WREG, 0xC43
141:                           }
142:                           break;
143:                       default:
144:               #ifdef DEBUG_MODE
145:                           UART2PrintString("Unknown packet\n\r");
146:               #endif
147:                           break;
148:                   }   
149:               } 
00831C  060000     RETURN
150:               
151:               void UpdateCurrentStateBuffer(CONTROLLER_IN *ControllerIn) {
00831E  B00B2F     ADD #0xB2, W15
008320  BE9F88     MOV.D W8, [W15++]
008322  BE9F8A     MOV.D W10, [W15++]
008324  BE9F8C     MOV.D W12, [W15++]
008326  781F8E     MOV W14, [W15++]
008328  780700     MOV W0, W14
152:                   
153:                  /*********WARNING********
154:                   * Button/Servo update functions may not be synchronized to this buffer update function.
155:                   * Therefore, make a working copy of CurrentStateBuffer, or else you'll have 
156:                   * to keep track very carefully that each member of the struct is only written to a
157:                   * single time, since an interrupt could interrupt this function.
158:                   *************************/
159:                   CONTROLLER_STATE_BUFFER Temp = CurrentStateBuffer; //make copy of current state
00832A  2FF420     MOV #0xFF42, W0
00832C  40000F     ADD W0, W15, W0
00832E  20BC61     MOV #0xBC6, W1
008330  090075     REPEAT #0x75
008332  785831     MOV.B [W1++], [W0++]
008334  B10760     SUB #0x76, W0
008336  9791DF     MOV [W15-86], W3
008338  9FBF83     MOV W3, [W15-16]
00833A  97904F     MOV [W15-88], W0
00833C  9FB7F0     MOV W0, [W15-18]
00833E  97989F     MOV [W15-78], W1
008340  DE09C8     LSR W1, #8, W3
008342  97992F     MOV [W15-76], W2
008344  DD1048     SL W2, #8, W0
008346  700183     IOR W0, W3, W3
008348  9FB7E3     MOV W3, [W15-20]
00834A  97980F     MOV [W15-80], W0
00834C  DE0048     LSR W0, #8, W0
00834E  DD08C8     SL W1, #8, W1
008350  708000     IOR W1, W0, W0
008352  9FB7D0     MOV W0, [W15-22]
008354  9790FF     MOV [W15-82], W1
008356  9FB7C1     MOV W1, [W15-24]
008358  9791EF     MOV [W15-84], W3
00835A  9FB7B3     MOV W3, [W15-26]
00835C  97903F     MOV [W15-90], W0
00835E  9FB7A0     MOV W0, [W15-28]
008360  9790AF     MOV [W15-92], W1
008362  9FB791     MOV W1, [W15-30]
008364  DE1148     LSR W2, #8, W2
008366  97983F     MOV [W15-74], W0
008368  DD0048     SL W0, #8, W0
00836A  700102     IOR W0, W2, W2
00836C  9FB782     MOV W2, [W15-32]
00836E  97710F     MOV.B [W15-80], W2
008370  9FDFE2     MOV.B W2, [W15-34]
008372  9788BF     MOV [W15-106], W1
008374  DE0948     LSR W1, #8, W2
008376  9789CF     MOV [W15-104], W3
008378  DD1848     SL W3, #8, W0
00837A  700102     IOR W0, W2, W2
00837C  9FAFE2     MOV W2, [W15-36]
00837E  978A2F     MOV [W15-108], W4
008380  DE2048     LSR W4, #8, W0
008382  DD08C8     SL W1, #8, W1
008384  708000     IOR W1, W0, W0
008386  9FAFD0     MOV W0, [W15-38]
008388  97900F     MOV [W15-96], W0
00838A  9FAFC0     MOV W0, [W15-40]
00838C  9788FF     MOV [W15-98], W1
00838E  9FAFB1     MOV W1, [W15-42]
008390  9788DF     MOV [W15-102], W1
008392  DE0948     LSR W1, #8, W2
008394  97886F     MOV [W15-100], W0
008396  DD0048     SL W0, #8, W0
008398  700102     IOR W0, W2, W2
00839A  9F9FD2     MOV W2, [W15-70]
00839C  DE19C8     LSR W3, #8, W3
00839E  DD08C8     SL W1, #8, W1
0083A0  708183     IOR W1, W3, W3
0083A2  9F9FC3     MOV W3, [W15-72]
0083A4  97889F     MOV [W15-110], W1
0083A6  DE0848     LSR W1, #8, W0
0083A8  DD2248     SL W4, #8, W4
0083AA  720000     IOR W4, W0, W0
0083AC  9FAFA0     MOV W0, [W15-44]
0083AE  97880F     MOV [W15-112], W0
0083B0  DE0048     LSR W0, #8, W0
0083B2  DD08C8     SL W1, #8, W1
0083B4  708000     IOR W1, W0, W0
0083B6  9FAF90     MOV W0, [W15-46]
0083B8  97911F     MOV [W15-94], W2
0083BA  9FAF82     MOV W2, [W15-48]
0083BC  9759DF     MOV.B [W15-99], W3
0083BE  9FCFE3     MOV.B W3, [W15-50]
0083C0  97802F     MOV [W15-124], W0
0083C2  9FA7E0     MOV W0, [W15-52]
0083C4  97809F     MOV [W15-126], W1
0083C6  9FA7D1     MOV W1, [W15-54]
0083C8  9780EF     MOV [W15-116], W1
0083CA  DE0948     LSR W1, #8, W2
0083CC  97807F     MOV [W15-114], W0
0083CE  DD0048     SL W0, #8, W0
0083D0  700102     IOR W0, W2, W2
0083D2  9FA7C2     MOV W2, [W15-56]
0083D4  97805F     MOV [W15-118], W0
0083D6  DE0048     LSR W0, #8, W0
0083D8  DD08C8     SL W1, #8, W1
0083DA  708000     IOR W1, W0, W0
0083DC  9FA7B0     MOV W0, [W15-58]
0083DE  97814F     MOV [W15-120], W2
0083E0  9FA7A2     MOV W2, [W15-60]
0083E2  9781BF     MOV [W15-122], W3
0083E4  9FA793     MOV W3, [W15-62]
0083E6  97800F     MOV [W15-128], W0
0083E8  9FA780     MOV W0, [W15-64]
0083EA  9738FF     MOV [W15-130], W1
0083EC  9F9FF1     MOV W1, [W15-66]
0083EE  97492F     MOV.B [W15-118], W2
0083F0  9F7FD2     MOV.B W2, [W15-67]
160:                   static signed long int xAngle=0;
161:                   static signed long int zAngle=0;
162:                   
163:                   Temp.Buttons.triangle = ControllerIn->triangle;
0083F2  9040DE     MOV.B [W14+5], W1
0083F4  FB8081     ZE W1, W1
0083F6  DE0847     LSR W1, #7, W0
0083F8  9F27D0     MOV W0, [W15-182]
164:                   Temp.Buttons.circle = ControllerIn->circle;
0083FA  DE0846     LSR W1, #6, W0
0083FC  600061     AND W0, #0x1, W0
0083FE  9F27E0     MOV W0, [W15-180]
165:                   Temp.Buttons.cross = ControllerIn->cross;
008400  DE0845     LSR W1, #5, W0
008402  600061     AND W0, #0x1, W0
008404  9F27F0     MOV W0, [W15-178]
166:                   Temp.Buttons.square = ControllerIn->square;
008406  DE08C4     LSR W1, #4, W1
008408  6080E1     AND W1, #0x1, W1
00840A  9F2F81     MOV W1, [W15-176]
167:               
168:               
169:                   if (GetConnectedDeviceType() == SPACE_MOUSE)
00840C  070915     RCALL GetConnectedDeviceType
00840E  500FE3     SUB W0, #0x3, [W15]
008410  3A000B     BRA NZ, 0x8428
170:                   {
171:                       Temp.Buttons.dPadUp = (BYTE)(ControllerIn->dPad)&0b00000001;
008412  90405E     MOV.B [W14+5], W0
008414  60006F     AND W0, #0xF, W0
008416  6001E1     AND W0, #0x1, W3
008418  9F2793     MOV W3, [W15-190]
172:                       Temp.Buttons.dPadRight = (BYTE)(ControllerIn->dPad)&0b00000010;
00841A  6000E2     AND W0, #0x2, W1
00841C  9F27A1     MOV W1, [W15-188]
173:                       Temp.Buttons.dPadDown = (BYTE)(ControllerIn->dPad)&0b00000100;
00841E  6000E4     AND W0, #0x4, W1
008420  9F27B1     MOV W1, [W15-186]
174:                       Temp.Buttons.dPadLeft = (BYTE)(ControllerIn->dPad)&0b00001000;
008422  600068     AND W0, #0x8, W0
008424  9F27C0     MOV W0, [W15-184]
008426  37001D     BRA 0x8462
175:                   }
176:                   else
177:                   {
178:               
179:                       Temp.Buttons.dPadUp = ControllerIn->dPad == 7 || ControllerIn->dPad == 0 || ControllerIn->dPad == 1;
008428  90405E     MOV.B [W14+5], W0
00842A  6040EF     AND.B W0, #0xF, W1
00842C  50CFE7     SUB.B W1, #0x7, [W15]
00842E  320005     BRA Z, 0x843A
008430  E00401     CP0.B W1
008432  320003     BRA Z, 0x843A
008434  EB0000     CLR W0
008436  50CFE1     SUB.B W1, #0x1, [W15]
008438  3A0001     BRA NZ, 0x843C
00843A  200010     MOV #0x1, W0
00843C  9F2790     MOV W0, [W15-190]
180:                       Temp.Buttons.dPadRight = ControllerIn->dPad == 1 || ControllerIn->dPad == 2 || ControllerIn->dPad == 3;
00843E  EB0100     CLR W2
008440  E94001     DEC.B W1, W0
008442  504FE2     SUB.B W0, #0x2, [W15]
008444  3E0001     BRA GTU, 0x8448
008446  200012     MOV #0x1, W2
008448  9F27A2     MOV W2, [W15-188]
181:                       Temp.Buttons.dPadDown = ControllerIn->dPad == 3 || ControllerIn->dPad == 4 || ControllerIn->dPad == 5;
00844A  EB0100     CLR W2
00844C  50C063     SUB.B W1, #0x3, W0
00844E  504FE2     SUB.B W0, #0x2, [W15]
008450  3E0001     BRA GTU, 0x8454
008452  200012     MOV #0x1, W2
008454  9F27B2     MOV W2, [W15-186]
182:                       Temp.Buttons.dPadLeft = ControllerIn->dPad == 5 || ControllerIn->dPad == 6 || ControllerIn->dPad == 7;
008456  EB0100     CLR W2
008458  50C065     SUB.B W1, #0x5, W0
00845A  504FE2     SUB.B W0, #0x2, [W15]
00845C  3E0001     BRA GTU, 0x8460
00845E  200012     MOV #0x1, W2
008460  9F27C2     MOV W2, [W15-184]
183:                       
184:                   }
185:               
186:                   Temp.Buttons.lStickPress = ControllerIn->lStickPress;
008462  90416E     MOV.B [W14+6], W2
008464  FB8082     ZE W2, W1
008466  DE0846     LSR W1, #6, W0
008468  600061     AND W0, #0x1, W0
00846A  9F2FD0     MOV W0, [W15-166]
187:                   Temp.Buttons.rStickPress = ControllerIn->rStickPress;
00846C  DE0847     LSR W1, #7, W0
00846E  9F2FE0     MOV W0, [W15-164]
188:                   Temp.Buttons.options = ControllerIn->options;
008470  DE0845     LSR W1, #5, W0
008472  600061     AND W0, #0x1, W0
008474  9F2FF0     MOV W0, [W15-162]
189:                   Temp.Buttons.share = ControllerIn->share;
008476  DE0844     LSR W1, #4, W0
008478  600061     AND W0, #0x1, W0
00847A  9F3780     MOV W0, [W15-160]
190:                   Temp.Buttons.lTriggerPull = ControllerIn->lTriggerPull;
00847C  DE0842     LSR W1, #2, W0
00847E  600061     AND W0, #0x1, W0
008480  9F2FB0     MOV W0, [W15-170]
191:                   Temp.Buttons.rTriggerPull = ControllerIn->rTriggerPull;
008482  DE0843     LSR W1, #3, W0
008484  600061     AND W0, #0x1, W0
008486  9F2FC0     MOV W0, [W15-168]
192:                   Temp.Buttons.lBumper = ControllerIn->lBumper;
008488  610161     AND W2, #0x1, W2
00848A  9F2F92     MOV W2, [W15-174]
193:                   Temp.Buttons.rBumper = ControllerIn->rBumper;
00848C  D10081     LSR W1, W1
00848E  6080E1     AND W1, #0x1, W1
008490  9F2FA1     MOV W1, [W15-172]
194:                   Temp.Buttons.psButton = ControllerIn->psButton;
008492  90407E     MOV.B [W14+7], W0
008494  6000E1     AND W0, #0x1, W1
008496  9F37A1     MOV W1, [W15-156]
195:                   Temp.Buttons.tpadClick = ControllerIn->tpadClick;
008498  D10000     LSR W0, W0
00849A  600061     AND W0, #0x1, W0
00849C  9F3790     MOV W0, [W15-158]
196:                   Temp.Analogs.lStickX = ControllerIn->lStickX;
00849E  90401E     MOV.B [W14+1], W0
0084A0  FB8000     ZE W0, W0
0084A2  9F37B0     MOV W0, [W15-154]
197:                   Temp.Analogs.lStickY = ControllerIn->lStickY;
0084A4  90402E     MOV.B [W14+2], W0
0084A6  FB8000     ZE W0, W0
0084A8  9F37C0     MOV W0, [W15-152]
198:                   Temp.Analogs.rStickX = ControllerIn->rStickX;
0084AA  90403E     MOV.B [W14+3], W0
0084AC  FB8000     ZE W0, W0
0084AE  9F37D0     MOV W0, [W15-150]
199:                   Temp.Analogs.rStickY = ControllerIn->rStickY;
0084B0  90404E     MOV.B [W14+4], W0
0084B2  FB8000     ZE W0, W0
0084B4  9F37E0     MOV W0, [W15-148]
200:                   Temp.Analogs.lTriggerAnalog = ControllerIn->lTriggerAnalog;
0084B6  90480E     MOV.B [W14+8], W0
0084B8  FB8000     ZE W0, W0
0084BA  9F37F0     MOV W0, [W15-146]
201:                   Temp.Analogs.rTriggerAnalog = ControllerIn->rTriggerAnalog;
0084BC  90481E     MOV.B [W14+9], W0
0084BE  FB8000     ZE W0, W0
0084C0  9F3F80     MOV W0, [W15-144]
202:                   Temp.battery = ControllerIn->battery;
0084C2  90586E     MOV.B [W14+30], W0
0084C4  60406F     AND.B W0, #0xF, W0
0084C6  9F7FC0     MOV.B W0, [W15-68]
203:               
204:                   
205:                   //Process Tilt
206:               #define COEFF_GYRO 980
207:               #define COEFF_ACCEL 20
208:               #define ACCEL_GAIN 15
209:               #define GYRO_GAIN 1
210:                   xAngle = (COEFF_GYRO*((signed long)xAngle + GYRO_GAIN*(ControllerIn->gyroZ/10))+(COEFF_ACCEL*ACCEL_GAIN*(signed long)ControllerIn->accelX)/10)/1000;
0084C8  90501E     MOV.B [W14+17], W0
0084CA  FB8000     ZE W0, W0
0084CC  90512E     MOV.B [W14+18], W2
0084CE  DD1148     SL W2, #8, W2
0084D0  710100     IOR W2, W0, W2
0084D2  2000AA     MOV #0xA, W10
0084D4  090011     REPEAT #0x11
0084D6  D8010A     DIV.SW W2, W10
0084D8  780100     MOV W0, W2
0084DA  DE91CF     ASR W2, #15, W3
0084DC  8058B0     MOV xAngle, W0
0084DE  8058C1     MOV 0xB18, W1
0084E0  400102     ADD W0, W2, W2
0084E2  488183     ADDC W1, W3, W3
0084E4  203D4B     MOV #0x3D4, W11
0084E6  B8100B     MUL.UU W2, W11, W0
0084E8  203D48     MOV #0x3D4, W8
0084EA  B99908     MUL.SS W3, W8, W2
0084EC  410081     ADD W2, W1, W1
0084EE  90523E     MOV.B [W14+19], W4
0084F0  FB8204     ZE W4, W4
0084F2  90514E     MOV.B [W14+20], W2
0084F4  DD1148     SL W2, #8, W2
0084F6  710104     IOR W2, W4, W2
0084F8  B9117E     MUL.SU W2, #30, W2
0084FA  410000     ADD W2, W0, W0
0084FC  498081     ADDC W3, W1, W1
0084FE  203E82     MOV #0x3E8, W2
008500  200003     MOV #0x0, W3
008502  07BED0     RCALL ___divsi3
008504  BE0600     MOV.D W0, W12
008506  8858B0     MOV W0, xAngle
008508  8858C1     MOV W1, 0xB18
211:                   zAngle = (COEFF_GYRO*((signed long)zAngle + GYRO_GAIN*(ControllerIn->gyroX/10))-(COEFF_ACCEL*ACCEL_GAIN*(signed long)ControllerIn->accelZ)/10)/1000;
00850A  90485E     MOV.B [W14+13], W0
00850C  FB8000     ZE W0, W0
00850E  90496E     MOV.B [W14+14], W2
008510  DD1148     SL W2, #8, W2
008512  710100     IOR W2, W0, W2
008514  090011     REPEAT #0x11
008516  D8010A     DIV.SW W2, W10
008518  780100     MOV W0, W2
00851A  DE91CF     ASR W2, #15, W3
00851C  805890     MOV zAngle, W0
00851E  8058A1     MOV 0xB14, W1
008520  400102     ADD W0, W2, W2
008522  488183     ADDC W1, W3, W3
008524  B8100B     MUL.UU W2, W11, W0
008526  B99C08     MUL.SS W3, W8, W8
008528  440081     ADD W8, W1, W1
00852A  90527E     MOV.B [W14+23], W4
00852C  FB8204     ZE W4, W4
00852E  90590E     MOV.B [W14+24], W2
008530  DD1148     SL W2, #8, W2
008532  710104     IOR W2, W4, W2
008534  B9117E     MUL.SU W2, #30, W2
008536  500002     SUB W0, W2, W0
008538  588083     SUBB W1, W3, W1
00853A  203E82     MOV #0x3E8, W2
00853C  200003     MOV #0x0, W3
00853E  07BEB2     RCALL ___divsi3
008540  BE0400     MOV.D W0, W8
008542  885890     MOV W0, zAngle
008544  8858A1     MOV W1, 0xB14
212:               
213:                   Temp.Analogs.tiltX = xAngle/100;
008546  200642     MOV #0x64, W2
008548  200003     MOV #0x0, W3
00854A  BE000C     MOV.D W12, W0
00854C  07BEAB     RCALL ___divsi3
00854E  9F3FD0     MOV W0, [W15-134]
214:                   Temp.Analogs.tiltZ = zAngle/100;
008550  200642     MOV #0x64, W2
008552  200003     MOV #0x0, W3
008554  BE0008     MOV.D W8, W0
008556  07BEA6     RCALL ___divsi3
008558  9F3FE0     MOV W0, [W15-132]
215:                   
216:                   /*
217:                   UART2PutDecSLong(ControllerIn->gyroX);
218:                   UART2PutChar('\t');
219:                   UART2PutDecSLong(ControllerIn->accelZ);
220:                   UART2PutChar('\t');
221:                    */
222:                   
223:                   //Process Touchpads
224:                   //check finger 0
225:                   Temp.Tpad.wholePad.fingerActive = !ControllerIn->tpad[0].finger[0].noFinger;
00855A  9060BE     MOV.B [W14+35], W1
00855C  FB0001     SE W1, W0
00855E  EA8000     COM W0, W0
008560  DE064F     LSR W0, #15, W12
226:                   if (Temp.Tpad.leftSide.originTouchID == ControllerIn->tpad[0].finger[0].touchID) //if the left half is most recently associated with finger 0
008562  97C86F     MOV.B [W15-50], W0
008564  FB8380     ZE W0, W7
008566  784501     MOV.B W1, W10
008568  A1740A     BCLR.B W10, #7
00856A  FB830A     ZE W10, W6
00856C  538F86     SUB W7, W6, [W15]
00856E  3A0001     BRA NZ, 0x8572
008570  9FAF8C     MOV W12, [W15-48]
227:                   {
228:                       Temp.Tpad.leftSide.fingerActive = !ControllerIn->tpad[0].finger[0].noFinger;
229:                   }
230:                   if (Temp.Tpad.rightSide.originTouchID == ControllerIn->tpad[0].finger[0].touchID) //if the right half is most recently associated with finger 0
008572  97D9EF     MOV.B [W15-34], W3
008574  FB8203     ZE W3, W4
008576  530F84     SUB W6, W4, [W15]
008578  3A0001     BRA NZ, 0x857C
00857A  9FB78C     MOV W12, [W15-32]
231:                   {
232:                       Temp.Tpad.rightSide.fingerActive = !ControllerIn->tpad[0].finger[0].noFinger;
233:                   }
234:                   //Check finger 1
235:                   if (Temp.Tpad.leftSide.originTouchID == ControllerIn->tpad[0].finger[1].touchID) //if the left half is most recently associated with finger 1
00857C  90607E     MOV.B [W14+39], W0
00857E  784680     MOV.B W0, W13
008580  A1740D     BCLR.B W13, #7
008582  FB848D     ZE W13, W9
008584  538F89     SUB W7, W9, [W15]
008586  3A0004     BRA NZ, 0x8590
236:                   {
237:                       Temp.Tpad.leftSide.fingerActive = !ControllerIn->tpad[0].finger[1].noFinger;
008588  FB0000     SE W0, W0
00858A  EA8000     COM W0, W0
00858C  DE004F     LSR W0, #15, W0
00858E  9FAF80     MOV W0, [W15-48]
238:                   }
239:                   if (Temp.Tpad.rightSide.originTouchID == ControllerIn->tpad[0].finger[1].touchID) //if the right half is most recently associated with finger 1
008590  520F89     SUB W4, W9, [W15]
008592  3A0007     BRA NZ, 0x85A2
240:                   {
241:                       Temp.Tpad.rightSide.fingerActive = !ControllerIn->tpad[0].finger[1].noFinger;
008594  EB0100     CLR W2
008596  9FB782     MOV W2, [W15-32]
008598  90607E     MOV.B [W14+39], W0
00859A  E00400     CP0.B W0
00859C  350002     BRA LT, 0x85A2
00859E  200013     MOV #0x1, W3
0085A0  9FB783     MOV W3, [W15-32]
242:                   }
243:               
244:                   //if no fingers detected, reset active flags, otherwise it won't initialized properly because the first Touch ID is unknown.
245:                   if (ControllerIn->tpad[0].finger[0].noFinger && ControllerIn->tpad[0].finger[1].noFinger) 
0085A2  E00401     CP0.B W1
0085A4  3D0008     BRA GE, 0x85B6
0085A6  9060FE     MOV.B [W14+39], W1
0085A8  B3C800     MOV.B #0x80, W0
0085AA  60C080     AND.B W1, W0, W1
0085AC  32008B     BRA Z, 0x86C4
0085AE  EB0000     CLR W0
0085B0  9FB780     MOV W0, [W15-32]
0085B2  9FAF80     MOV W0, [W15-48]
0085B4  370087     BRA 0x86C4
246:                   {
247:                       Temp.Tpad.leftSide.fingerActive = 0;
248:                       Temp.Tpad.rightSide.fingerActive = 0;
249:                   }
250:               
251:               
252:                   if (!ControllerIn->tpad[0].finger[0].noFinger) //process finger 0
253:                   {
254:                       //Update parameters for whole touchpad mode
255:                       //Check to see if it can be traced back to an existing touch.  If not, it's a new touch, update origin
256:                       if (ControllerIn->tpad[0].finger[0].touchID != Temp.Tpad.wholePad.originTouchID) //if this is a new touch, set the origin coordinates
0085B6  97795F     MOV.B [W15-67], W2
0085B8  FB8002     ZE W2, W0
0085BA  530F80     SUB W6, W0, [W15]
0085BC  320015     BRA Z, 0x85E8
257:                       {
258:                           Temp.Tpad.wholePad.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_WHOLE;
0085BE  9060CE     MOV.B [W14+36], W1
0085C0  FB8081     ZE W1, W1
0085C2  90615E     MOV.B [W14+37], W2
0085C4  FB8102     ZE W2, W2
0085C6  61006F     AND W2, #0xF, W0
0085C8  DD0048     SL W0, #8, W0
0085CA  700081     IOR W0, W1, W1
0085CC  9FA791     MOV W1, [W15-62]
0085CE  2FC400     MOV #0xFC40, W0
0085D0  408000     ADD W1, W0, W0
0085D2  9F9FF0     MOV W0, [W15-66]
259:                           Temp.Tpad.wholePad.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
0085D4  DE1144     LSR W2, #4, W2
0085D6  90606E     MOV.B [W14+38], W0
0085D8  FB8000     ZE W0, W0
0085DA  DD0044     SL W0, #4, W0
0085DC  700102     IOR W0, W2, W2
0085DE  9FA7A2     MOV W2, [W15-60]
0085E0  2FE2A0     MOV #0xFE2A, W0
0085E2  410000     ADD W2, W0, W0
0085E4  9FA780     MOV W0, [W15-64]
260:                           Temp.Tpad.wholePad.originTouchID = ControllerIn->tpad[0].finger[0].touchID;
0085E6  9F7FDA     MOV.B W10, [W15-67]
261:                           Temp.Tpad.wholePad.originX = ControllerIn->tpad[0].finger[0].x;
262:                           Temp.Tpad.wholePad.originY = ControllerIn->tpad[0].finger[0].y;
263:                       }
264:                       //Update parameters
265:                       Temp.Tpad.wholePad.incrementX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_WHOLE - Temp.Tpad.wholePad.absoluteX;
0085E8  9060CE     MOV.B [W14+36], W1
0085EA  FB8081     ZE W1, W1
0085EC  90615E     MOV.B [W14+37], W2
0085EE  FB8102     ZE W2, W2
0085F0  61006F     AND W2, #0xF, W0
0085F2  DD0048     SL W0, #8, W0
0085F4  700581     IOR W0, W1, W11
0085F6  9798FF     MOV [W15-66], W1
0085F8  558001     SUB W11, W1, W0
0085FA  2FC403     MOV #0xFC40, W3
0085FC  400003     ADD W0, W3, W0
0085FE  9FA7B0     MOV W0, [W15-58]
266:                       Temp.Tpad.wholePad.incrementY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y - Temp.Tpad.wholePad.absoluteY;
008600  DE1144     LSR W2, #4, W2
008602  90606E     MOV.B [W14+38], W0
008604  FB8000     ZE W0, W0
008606  DD0044     SL W0, #4, W0
008608  700402     IOR W0, W2, W8
00860A  97A10F     MOV [W15-64], W2
00860C  540002     SUB W8, W2, W0
00860E  2FE2A1     MOV #0xFE2A, W1
008610  400001     ADD W0, W1, W0
008612  9FA7C0     MOV W0, [W15-56]
267:                       Temp.Tpad.wholePad.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_WHOLE;
008614  78028B     MOV W11, W5
008616  458183     ADD W11, W3, W3
008618  9F9FF3     MOV W3, [W15-66]
268:                       Temp.Tpad.wholePad.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
00861A  780188     MOV W8, W3
00861C  440081     ADD W8, W1, W1
00861E  9FA781     MOV W1, [W15-64]
269:                       Temp.Tpad.wholePad.displacementX = ControllerIn->tpad[0].finger[0].x - Temp.Tpad.wholePad.originX;
008620  97A01F     MOV [W15-62], W0
008622  558000     SUB W11, W0, W0
008624  9FA7D0     MOV W0, [W15-54]
270:                       Temp.Tpad.wholePad.displacementY = ControllerIn->tpad[0].finger[0].y - Temp.Tpad.wholePad.originY;
008626  97A0AF     MOV [W15-60], W1
008628  540081     SUB W8, W1, W1
00862A  9FA7E1     MOV W1, [W15-52]
271:               
272:                       //Update parameters for touchpad left/right mode.
273:               
274:                       //Process Finger 0
275:                       if (ControllerIn->tpad[0].finger[0].touchID != Temp.Tpad.leftSide.originTouchID &&\
00862C  538F86     SUB W7, W6, [W15]
00862E  32001E     BRA Z, 0x866C
008630  530F84     SUB W6, W4, [W15]
008632  320030     BRA Z, 0x8694
276:                               ControllerIn->tpad[0].finger[0].touchID != Temp.Tpad.rightSide.originTouchID) //if the touch is not a continuation of either joystick, it a new touch
277:                       {
278:                           if (ControllerIn->tpad[0].finger[0].x < 960)
008634  203BF0     MOV #0x3BF, W0
008636  558F80     SUB W11, W0, [W15]
008638  3C000C     BRA GT, 0x8652
279:                           {
280:                               Temp.Tpad.leftSide.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_LEFT;
00863A  2FEC00     MOV #0xFEC0, W0
00863C  458000     ADD W11, W0, W0
00863E  9FAF90     MOV W0, [W15-46]
281:                               Temp.Tpad.leftSide.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
282:                               Temp.Tpad.leftSide.originX = ControllerIn->tpad[0].finger[0].x;
283:                               Temp.Tpad.leftSide.originY = ControllerIn->tpad[0].finger[0].y;
284:                               Temp.Tpad.leftSide.originTouchID = ControllerIn->tpad[0].finger[0].touchID;
008640  9FCFEA     MOV.B W10, [W15-50]
285:                           }
286:                           else if (ControllerIn->tpad[0].finger[0].x >= 960) {
287:                               Temp.Tpad.rightSide.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_RIGHT;
008652  2F9C00     MOV #0xF9C0, W0
008654  458000     ADD W11, W0, W0
008656  9FB790     MOV W0, [W15-30]
288:                               Temp.Tpad.rightSide.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
289:                               Temp.Tpad.rightSide.originTouchID = ControllerIn->tpad[0].finger[0].touchID;
008658  9FDFEA     MOV.B W10, [W15-34]
00865A  9FB7C8     MOV W8, [W15-24]
00865C  9FB7BB     MOV W11, [W15-26]
00865E  97A08F     MOV [W15-64], W1
008660  9FB7A1     MOV W1, [W15-28]
008662  370018     BRA 0x8694
008664  9F9FCB     MOV W11, [W15-72]
008666  9F9FD8     MOV W8, [W15-70]
008668  97A08F     MOV [W15-64], W1
00866A  9FAFA1     MOV W1, [W15-44]
290:                               Temp.Tpad.rightSide.originX = ControllerIn->tpad[0].finger[0].x;
291:                               Temp.Tpad.rightSide.originY = ControllerIn->tpad[0].finger[0].y;
292:                           }
293:                           else
294:                           {
295:                               UART2PrintString("Unknown Side\n\r");
296:                           }
297:                       }
298:                       if (ControllerIn->tpad[0].finger[0].touchID == Temp.Tpad.leftSide.originTouchID){
008642  FB800A     ZE W10, W0
008644  530F80     SUB W6, W0, [W15]
008646  32000E     BRA Z, 0x8664
008648  97A10F     MOV [W15-64], W2
00864A  9FAFA2     MOV W2, [W15-44]
00864C  9F9FCB     MOV W11, [W15-72]
00864E  9F9FD8     MOV W8, [W15-70]
008650  370021     BRA 0x8694
299:                           Temp.Tpad.leftSide.incrementX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_LEFT - Temp.Tpad.leftSide.absoluteX;
00866C  97A91F     MOV [W15-46], W2
00866E  558002     SUB W11, W2, W0
008670  2FEC02     MOV #0xFEC0, W2
008672  400002     ADD W0, W2, W0
008674  9FAFB0     MOV W0, [W15-42]
300:                           Temp.Tpad.leftSide.incrementY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y - Temp.Tpad.leftSide.absoluteY;
008676  97A82F     MOV [W15-44], W0
008678  540080     SUB W8, W0, W1
00867A  2FE2A0     MOV #0xFE2A, W0
00867C  408080     ADD W1, W0, W1
00867E  9FAFC1     MOV W1, [W15-40]
301:                           Temp.Tpad.leftSide.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_LEFT;
008680  428102     ADD W5, W2, W2
008682  9FAF92     MOV W2, [W15-46]
302:                           Temp.Tpad.leftSide.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
303:                           Temp.Tpad.leftSide.displacementX = ControllerIn->tpad[0].finger[0].x - Temp.Tpad.leftSide.originX;
008684  9798CF     MOV [W15-72], W1
008686  528081     SUB W5, W1, W1
008688  9FAFD1     MOV W1, [W15-38]
304:                           Temp.Tpad.leftSide.displacementY = ControllerIn->tpad[0].finger[0].y - Temp.Tpad.leftSide.originY;
00868A  97995F     MOV [W15-70], W2
00868C  518102     SUB W3, W2, W2
00868E  9FAFE2     MOV W2, [W15-36]
008690  97A00F     MOV [W15-64], W0
008692  9FAFA0     MOV W0, [W15-44]
305:                       }
306:                       if (ControllerIn->tpad[0].finger[0].touchID == Temp.Tpad.rightSide.originTouchID){
008694  97D8EF     MOV.B [W15-34], W1
008696  FB8001     ZE W1, W0
008698  530F80     SUB W6, W0, [W15]
00869A  3A0014     BRA NZ, 0x86C4
307:                           Temp.Tpad.rightSide.incrementX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_RIGHT - Temp.Tpad.rightSide.absoluteX;
00869C  97B11F     MOV [W15-30], W2
00869E  558002     SUB W11, W2, W0
0086A0  2F9C02     MOV #0xF9C0, W2
0086A2  400002     ADD W0, W2, W0
0086A4  9FB7D0     MOV W0, [W15-22]
308:                           Temp.Tpad.rightSide.incrementY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y - Temp.Tpad.rightSide.absoluteY;
0086A6  97B02F     MOV [W15-28], W0
0086A8  540080     SUB W8, W0, W1
0086AA  2FE2A0     MOV #0xFE2A, W0
0086AC  408080     ADD W1, W0, W1
0086AE  9FB7E1     MOV W1, [W15-20]
309:                           Temp.Tpad.rightSide.absoluteX = ControllerIn->tpad[0].finger[0].x - TOUCHPAD_ORIGIN_X_RIGHT;
0086B0  428102     ADD W5, W2, W2
0086B2  9FB792     MOV W2, [W15-30]
310:                           Temp.Tpad.rightSide.absoluteY = ControllerIn->tpad[0].finger[0].y - TOUCHPAD_ORIGIN_Y;
311:                           Temp.Tpad.rightSide.displacementX = ControllerIn->tpad[0].finger[0].x - Temp.Tpad.rightSide.originX;
0086B4  97B0BF     MOV [W15-26], W1
0086B6  528281     SUB W5, W1, W5
0086B8  9FB7F5     MOV W5, [W15-18]
312:                           Temp.Tpad.rightSide.displacementY = ControllerIn->tpad[0].finger[0].y - Temp.Tpad.rightSide.originY;
0086BA  97B14F     MOV [W15-24], W2
0086BC  518182     SUB W3, W2, W3
0086BE  9FBF83     MOV W3, [W15-16]
0086C0  97A18F     MOV [W15-64], W3
0086C2  9FB7A3     MOV W3, [W15-28]
313:                       }
314:                   } //end processing finger 0
315:               
316:               
317:                   if (!ControllerIn->tpad[0].finger[1].noFinger) //process finger 1
0086C4  90607E     MOV.B [W14+39], W0
0086C6  E00400     CP0.B W0
0086C8  35007A     BRA LT, 0x87BE
318:                   {
319:                       if (ControllerIn->tpad[0].finger[1].touchID != Temp.Tpad.leftSide.originTouchID &&\
0086CA  97C8EF     MOV.B [W15-50], W1
0086CC  FB8001     ZE W1, W0
0086CE  548F80     SUB W9, W0, [W15]
0086D0  320032     BRA Z, 0x8736
0086D2  97D96F     MOV.B [W15-34], W2
0086D4  FB8002     ZE W2, W0
0086D6  548F80     SUB W9, W0, [W15]
0086D8  32004E     BRA Z, 0x8776
320:                               ControllerIn->tpad[0].finger[1].touchID != Temp.Tpad.rightSide.originTouchID) //if the touch is not a continuation of either joystick, it a new touch
321:                       {
322:                           if (ControllerIn->tpad[0].finger[1].x < 960)
0086DA  90688E     MOV.B [W14+40], W1
0086DC  FB8081     ZE W1, W1
0086DE  90681E     MOV.B [W14+41], W0
0086E0  FB8100     ZE W0, W2
0086E2  61006F     AND W2, #0xF, W0
0086E4  DD0048     SL W0, #8, W0
0086E6  700181     IOR W0, W1, W3
0086E8  203BF0     MOV #0x3BF, W0
0086EA  518F80     SUB W3, W0, [W15]
0086EC  3C0012     BRA GT, 0x8712
323:                           {
324:                               Temp.Tpad.leftSide.absoluteX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_LEFT;
0086EE  2FEC00     MOV #0xFEC0, W0
0086F0  418000     ADD W3, W0, W0
0086F2  9FAF90     MOV W0, [W15-46]
325:                               Temp.Tpad.leftSide.absoluteY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y;
0086F4  DE10C4     LSR W2, #4, W1
0086F6  90682E     MOV.B [W14+42], W0
0086F8  FB8000     ZE W0, W0
0086FA  DD0044     SL W0, #4, W0
0086FC  700081     IOR W0, W1, W1
0086FE  9F9FD1     MOV W1, [W15-70]
008700  2FE2A0     MOV #0xFE2A, W0
008702  408000     ADD W1, W0, W0
008704  9FAFA0     MOV W0, [W15-44]
326:                               Temp.Tpad.leftSide.originX = ControllerIn->tpad[0].finger[1].x;
327:                               Temp.Tpad.leftSide.originY = ControllerIn->tpad[0].finger[1].y;
328:                               Temp.Tpad.leftSide.originTouchID = ControllerIn->tpad[0].finger[1].touchID;
008706  9FCFED     MOV.B W13, [W15-50]
329:                           }
330:                           else if (ControllerIn->tpad[0].finger[1].x >= 960) {
331:                               Temp.Tpad.rightSide.absoluteX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_RIGHT;
008712  2F9C00     MOV #0xF9C0, W0
008714  418000     ADD W3, W0, W0
008716  9FB790     MOV W0, [W15-30]
332:                               Temp.Tpad.rightSide.absoluteY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y;
008718  90689E     MOV.B [W14+41], W1
00871A  FB8081     ZE W1, W1
00871C  DE08C4     LSR W1, #4, W1
00871E  90682E     MOV.B [W14+42], W0
008720  FB8000     ZE W0, W0
008722  DD0044     SL W0, #4, W0
008724  700081     IOR W0, W1, W1
008726  9FB7C1     MOV W1, [W15-24]
008728  2FE2A0     MOV #0xFE2A, W0
00872A  408000     ADD W1, W0, W0
00872C  9FB7A0     MOV W0, [W15-28]
333:                               Temp.Tpad.rightSide.originTouchID = ControllerIn->tpad[0].finger[1].touchID;
00872E  9FDFED     MOV.B W13, [W15-34]
008730  9FB7B3     MOV W3, [W15-26]
008732  370021     BRA 0x8776
008734  9F9FC3     MOV W3, [W15-72]
334:                               Temp.Tpad.rightSide.originX = ControllerIn->tpad[0].finger[1].x;
335:                               Temp.Tpad.rightSide.originY = ControllerIn->tpad[0].finger[1].y;
336:                           }
337:                           else
338:                           {
339:                               UART2PrintString("Unknown Side\n\r");;
340:                           }
341:                       }
342:                       if (ControllerIn->tpad[0].finger[1].touchID == Temp.Tpad.leftSide.originTouchID){
008708  FB800D     ZE W13, W0
00870A  548F80     SUB W9, W0, [W15]
00870C  320013     BRA Z, 0x8734
00870E  9F9FC3     MOV W3, [W15-72]
008710  370032     BRA 0x8776
343:                           Temp.Tpad.leftSide.incrementX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_LEFT - Temp.Tpad.leftSide.absoluteX;
008736  90680E     MOV.B [W14+40], W0
008738  FB8000     ZE W0, W0
00873A  90691E     MOV.B [W14+41], W2
00873C  FB8102     ZE W2, W2
00873E  6100EF     AND W2, #0xF, W1
008740  DD08C8     SL W1, #8, W1
008742  708080     IOR W1, W0, W1
008744  97A99F     MOV [W15-46], W3
008746  508003     SUB W1, W3, W0
008748  2FEC04     MOV #0xFEC0, W4
00874A  400004     ADD W0, W4, W0
00874C  9FAFB0     MOV W0, [W15-42]
344:                           Temp.Tpad.leftSide.incrementY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y - Temp.Tpad.leftSide.absoluteY;
00874E  DE1144     LSR W2, #4, W2
008750  90682E     MOV.B [W14+42], W0
008752  FB8000     ZE W0, W0
008754  DD0044     SL W0, #4, W0
008756  700002     IOR W0, W2, W0
008758  97A9AF     MOV [W15-44], W3
00875A  500103     SUB W0, W3, W2
00875C  2FE2A3     MOV #0xFE2A, W3
00875E  410103     ADD W2, W3, W2
008760  9FAFC2     MOV W2, [W15-40]
345:                           Temp.Tpad.leftSide.absoluteX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_LEFT;
008762  408204     ADD W1, W4, W4
008764  9FAF94     MOV W4, [W15-46]
346:                           Temp.Tpad.leftSide.absoluteY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y;
008766  400183     ADD W0, W3, W3
008768  9FAFA3     MOV W3, [W15-44]
347:                           Temp.Tpad.leftSide.displacementX = ControllerIn->tpad[0].finger[1].x - Temp.Tpad.leftSide.originX;
00876A  97994F     MOV [W15-72], W2
00876C  508082     SUB W1, W2, W1
00876E  9FAFD1     MOV W1, [W15-38]
348:                           Temp.Tpad.leftSide.displacementY = ControllerIn->tpad[0].finger[1].y - Temp.Tpad.leftSide.originY;
008770  9799DF     MOV [W15-70], W3
008772  500003     SUB W0, W3, W0
008774  9FAFE0     MOV W0, [W15-36]
349:                       }
350:                       if (ControllerIn->tpad[0].finger[1].touchID == Temp.Tpad.rightSide.originTouchID){
008776  97D8EF     MOV.B [W15-34], W1
008778  FB8001     ZE W1, W0
00877A  548F80     SUB W9, W0, [W15]
00877C  3A0020     BRA NZ, 0x87BE
351:                           Temp.Tpad.rightSide.incrementX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_RIGHT - Temp.Tpad.rightSide.absoluteX;
00877E  90680E     MOV.B [W14+40], W0
008780  FB8000     ZE W0, W0
008782  90691E     MOV.B [W14+41], W2
008784  FB8102     ZE W2, W2
008786  6100EF     AND W2, #0xF, W1
008788  DD08C8     SL W1, #8, W1
00878A  708080     IOR W1, W0, W1
00878C  97B19F     MOV [W15-30], W3
00878E  508003     SUB W1, W3, W0
008790  2F9C04     MOV #0xF9C0, W4
008792  400004     ADD W0, W4, W0
008794  9FB7D0     MOV W0, [W15-22]
352:                           Temp.Tpad.rightSide.incrementY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y - Temp.Tpad.rightSide.absoluteY;
008796  DE1144     LSR W2, #4, W2
008798  90682E     MOV.B [W14+42], W0
00879A  FB8000     ZE W0, W0
00879C  DD0044     SL W0, #4, W0
00879E  700002     IOR W0, W2, W0
0087A0  97B1AF     MOV [W15-28], W3
0087A2  500103     SUB W0, W3, W2
0087A4  2FE2A3     MOV #0xFE2A, W3
0087A6  410103     ADD W2, W3, W2
0087A8  9FB7E2     MOV W2, [W15-20]
353:                           Temp.Tpad.rightSide.absoluteX = ControllerIn->tpad[0].finger[1].x - TOUCHPAD_ORIGIN_X_RIGHT;
0087AA  408204     ADD W1, W4, W4
0087AC  9FB794     MOV W4, [W15-30]
354:                           Temp.Tpad.rightSide.absoluteY = ControllerIn->tpad[0].finger[1].y - TOUCHPAD_ORIGIN_Y;
0087AE  400183     ADD W0, W3, W3
0087B0  9FB7A3     MOV W3, [W15-28]
355:                           Temp.Tpad.rightSide.displacementX = ControllerIn->tpad[0].finger[1].x - Temp.Tpad.rightSide.originX;
0087B2  97B13F     MOV [W15-26], W2
0087B4  508082     SUB W1, W2, W1
0087B6  9FB7F1     MOV W1, [W15-18]
356:                           Temp.Tpad.rightSide.displacementY = ControllerIn->tpad[0].finger[1].y - Temp.Tpad.rightSide.originY;
0087B8  97B1CF     MOV [W15-24], W3
0087BA  500003     SUB W0, W3, W0
0087BC  9FBF80     MOV W0, [W15-16]
357:                       }
358:                   } //end processing finger 1
359:               
360:                   if (!Temp.Tpad.wholePad.fingerActive) {
0087BE  E0000C     CP0 W12
0087C0  3A0004     BRA NZ, 0x87CA
0087C2  9FA7EC     MOV W12, [W15-52]
0087C4  9FA7DC     MOV W12, [W15-54]
0087C6  9FA7CC     MOV W12, [W15-56]
0087C8  9FA7BC     MOV W12, [W15-58]
361:                       Temp.Tpad.wholePad.displacementX = 0;
362:                       Temp.Tpad.wholePad.displacementY = 0;
363:                       Temp.Tpad.wholePad.incrementX = 0;
364:                       Temp.Tpad.wholePad.incrementY = 0;
365:               
366:                   }
367:                   if (!Temp.Tpad.leftSide.fingerActive) {
0087CA  97A80F     MOV [W15-48], W0
0087CC  E00000     CP0 W0
0087CE  3A0004     BRA NZ, 0x87D8
0087D0  9FAFE0     MOV W0, [W15-36]
0087D2  9FAFD0     MOV W0, [W15-38]
0087D4  9FAFC0     MOV W0, [W15-40]
0087D6  9FAFB0     MOV W0, [W15-42]
368:                       Temp.Tpad.leftSide.displacementX = 0;
369:                       Temp.Tpad.leftSide.displacementY = 0;
370:                       Temp.Tpad.leftSide.incrementX = 0;
371:                       Temp.Tpad.leftSide.incrementY = 0;
372:                   }
373:                   if (!Temp.Tpad.rightSide.fingerActive) {
0087D8  97B08F     MOV [W15-32], W1
0087DA  E00001     CP0 W1
0087DC  3A0004     BRA NZ, 0x87E6
0087DE  9FBF81     MOV W1, [W15-16]
0087E0  9FB7F1     MOV W1, [W15-18]
0087E2  9FB7E1     MOV W1, [W15-20]
0087E4  9FB7D1     MOV W1, [W15-22]
374:                       Temp.Tpad.rightSide.displacementX = 0;
375:                       Temp.Tpad.rightSide.displacementY = 0;
376:                       Temp.Tpad.rightSide.incrementX = 0;
377:                       Temp.Tpad.rightSide.incrementY = 0;
378:                   }
379:                   CurrentStateBuffer = Temp;
0087E6  97B90F     MOV [W15-16], W2
0087E8  9F97D2     MOV W2, [W15-86]
0087EA  97B1FF     MOV [W15-18], W3
0087EC  9F97C3     MOV W3, [W15-88]
0087EE  200FF4     MOV #0xFF, W4
0087F0  97B0EF     MOV [W15-20], W1
0087F2  DD0848     SL W1, #8, W0
0087F4  97991F     MOV [W15-78], W2
0087F6  610104     AND W2, W4, W2
0087F8  710100     IOR W2, W0, W2
0087FA  DE0848     LSR W1, #8, W0
0087FC  600004     AND W0, W4, W0
0087FE  2FF006     MOV #0xFF00, W6
008800  9799AF     MOV [W15-76], W3
008802  618186     AND W3, W6, W3
008804  718180     IOR W3, W0, W3
008806  97B05F     MOV [W15-22], W0
008808  600084     AND W0, W4, W1
00880A  DD08C8     SL W1, #8, W1
00880C  97980F     MOV [W15-80], W0
00880E  600004     AND W0, W4, W0
008810  700001     IOR W0, W1, W0
008812  9F9F80     MOV W0, [W15-80]
008814  97B0DF     MOV [W15-22], W1
008816  DE0848     LSR W1, #8, W0
008818  600004     AND W0, W4, W0
00881A  610106     AND W2, W6, W2
00881C  710100     IOR W2, W0, W2
00881E  9F9F92     MOV W2, [W15-78]
008820  97B14F     MOV [W15-24], W2
008822  9F97F2     MOV W2, [W15-82]
008824  97B03F     MOV [W15-26], W0
008826  9F97E0     MOV W0, [W15-84]
008828  97B0AF     MOV [W15-28], W1
00882A  9F97B1     MOV W1, [W15-90]
00882C  97B11F     MOV [W15-30], W2
00882E  9F97A2     MOV W2, [W15-92]
008830  97B08F     MOV [W15-32], W1
008832  608004     AND W1, W4, W0
008834  DD0048     SL W0, #8, W0
008836  618184     AND W3, W4, W3
008838  718180     IOR W3, W0, W3
00883A  9F9FA3     MOV W3, [W15-76]
00883C  DE08C8     LSR W1, #8, W1
00883E  608084     AND W1, W4, W1
008840  97983F     MOV [W15-74], W0
008842  600006     AND W0, W6, W0
008844  700001     IOR W0, W1, W0
008846  9F9FB0     MOV W0, [W15-74]
008848  97D9EF     MOV.B [W15-34], W3
00884A  9F7783     MOV.B W3, [W15-80]
00884C  97A8EF     MOV [W15-36], W1
00884E  608004     AND W1, W4, W0
008850  DD0048     SL W0, #8, W0
008852  9788BF     MOV [W15-106], W1
008854  608084     AND W1, W4, W1
008856  708080     IOR W1, W0, W1
008858  97A96F     MOV [W15-36], W2
00885A  DE1048     LSR W2, #8, W0
00885C  600004     AND W0, W4, W0
00885E  9789CF     MOV [W15-104], W3
008860  618186     AND W3, W6, W3
008862  718180     IOR W3, W0, W3
008864  97A95F     MOV [W15-38], W2
008866  610004     AND W2, W4, W0
008868  DD0048     SL W0, #8, W0
00886A  978AAF     MOV [W15-108], W5
00886C  628284     AND W5, W4, W5
00886E  728280     IOR W5, W0, W5
008870  DE1048     LSR W2, #8, W0
008872  600004     AND W0, W4, W0
008874  608086     AND W1, W6, W1
008876  708080     IOR W1, W0, W1
008878  9F8FB1     MOV W1, [W15-106]
00887A  97A84F     MOV [W15-40], W0
00887C  9F9780     MOV W0, [W15-96]
00887E  97A8BF     MOV [W15-42], W1
008880  9F8FF1     MOV W1, [W15-98]
008882  97995F     MOV [W15-70], W2
008884  610004     AND W2, W4, W0
008886  DD0048     SL W0, #8, W0
008888  97895F     MOV [W15-102], W2
00888A  610104     AND W2, W4, W2
00888C  710100     IOR W2, W0, W2
00888E  97985F     MOV [W15-70], W0
008890  DE00C8     LSR W0, #8, W1
008892  608084     AND W1, W4, W1
008894  97886F     MOV [W15-100], W0
008896  600006     AND W0, W6, W0
008898  700001     IOR W0, W1, W0
00889A  9F8FE0     MOV W0, [W15-100]
00889C  9798CF     MOV [W15-72], W1
00889E  608004     AND W1, W4, W0
0088A0  DD0048     SL W0, #8, W0
0088A2  618184     AND W3, W4, W3
0088A4  718180     IOR W3, W0, W3
0088A6  9F8FC3     MOV W3, [W15-104]
0088A8  DE0848     LSR W1, #8, W0
0088AA  600004     AND W0, W4, W0
0088AC  610106     AND W2, W6, W2
0088AE  710100     IOR W2, W0, W2
0088B0  9F8FD2     MOV W2, [W15-102]
0088B2  97A92F     MOV [W15-44], W2
0088B4  610004     AND W2, W4, W0
0088B6  DD0048     SL W0, #8, W0
0088B8  97889F     MOV [W15-110], W1
0088BA  608084     AND W1, W4, W1
0088BC  708080     IOR W1, W0, W1
0088BE  DE1048     LSR W2, #8, W0
0088C0  600004     AND W0, W4, W0
0088C2  628286     AND W5, W6, W5
0088C4  728280     IOR W5, W0, W5
0088C6  9F8FA5     MOV W5, [W15-108]
0088C8  97A99F     MOV [W15-46], W3
0088CA  618004     AND W3, W4, W0
0088CC  DD0048     SL W0, #8, W0
0088CE  978A8F     MOV [W15-112], W5
0088D0  628284     AND W5, W4, W5
0088D2  728280     IOR W5, W0, W5
0088D4  DE1848     LSR W3, #8, W0
0088D6  600004     AND W0, W4, W0
0088D8  608086     AND W1, W6, W1
0088DA  708080     IOR W1, W0, W1
0088DC  9F8F91     MOV W1, [W15-110]
0088DE  97A80F     MOV [W15-48], W0
0088E0  9F9790     MOV W0, [W15-94]
0088E2  97C8EF     MOV.B [W15-50], W1
0088E4  9F5FD1     MOV.B W1, [W15-99]
0088E6  97A16F     MOV [W15-52], W2
0088E8  9F87A2     MOV W2, [W15-124]
0088EA  97A1DF     MOV [W15-54], W3
0088EC  9F8793     MOV W3, [W15-126]
0088EE  97A0CF     MOV [W15-56], W1
0088F0  608004     AND W1, W4, W0
0088F2  DD0048     SL W0, #8, W0
0088F4  97816F     MOV [W15-116], W2
0088F6  610104     AND W2, W4, W2
0088F8  710100     IOR W2, W0, W2
0088FA  DE0848     LSR W1, #8, W0
0088FC  600004     AND W0, W4, W0
0088FE  9781FF     MOV [W15-114], W3
008900  618186     AND W3, W6, W3
008902  718180     IOR W3, W0, W3
008904  97A03F     MOV [W15-58], W0
008906  600084     AND W0, W4, W1
008908  DD08C8     SL W1, #8, W1
00890A  97805F     MOV [W15-118], W0
00890C  600004     AND W0, W4, W0
00890E  700001     IOR W0, W1, W0
008910  9F87D0     MOV W0, [W15-118]
008912  97A0BF     MOV [W15-58], W1
008914  DE0848     LSR W1, #8, W0
008916  600004     AND W0, W4, W0
008918  610106     AND W2, W6, W2
00891A  710100     IOR W2, W0, W2
00891C  9F87E2     MOV W2, [W15-116]
00891E  97A12F     MOV [W15-60], W2
008920  9F87C2     MOV W2, [W15-120]
008922  97A01F     MOV [W15-62], W0
008924  9F87B0     MOV W0, [W15-122]
008926  97A08F     MOV [W15-64], W1
008928  9F8781     MOV W1, [W15-128]
00892A  97997F     MOV [W15-66], W2
00892C  9F3FF2     MOV W2, [W15-130]
00892E  97785F     MOV.B [W15-67], W0
008930  9F4FA0     MOV.B W0, [W15-118]
008932  660004     AND W12, W4, W0
008934  DD0048     SL W0, #8, W0
008936  618184     AND W3, W4, W3
008938  718180     IOR W3, W0, W3
00893A  9F87F3     MOV W3, [W15-114]
00893C  DE6048     LSR W12, #8, W0
00893E  600004     AND W0, W4, W0
008940  628286     AND W5, W6, W5
008942  728280     IOR W5, W0, W5
008944  9F8F85     MOV W5, [W15-112]
008946  9778CF     MOV.B [W15-68], W1
008948  9F77F1     MOV.B W1, [W15-73]
00894A  2FF422     MOV #0xFF42, W2
00894C  41010F     ADD W2, W15, W2
00894E  20BC63     MOV #0xBC6, W3
008950  090075     REPEAT #0x75
008952  7859B2     MOV.B [W2++], [W3++]
008954  B10762     SUB #0x76, W2
380:               }
008956  78074F     MOV [--W15], W14
008958  BE064F     MOV.D [--W15], W12
00895A  BE054F     MOV.D [--W15], W10
00895C  BE044F     MOV.D [--W15], W8
00895E  B10B2F     SUB #0xB2, W15
008960  060000     RETURN
381:               
382:               //check to see if controller is idle, if there is change, then reset the idle timer.
383:               //probably only need the accels, could save some processing here.
384:               BOOL CheckIdle(void) {
008962  781F88     MOV W8, [W15++]
008964  EB0400     CLR W8
008966  780188     MOV W8, W3
008968  20B1A5     MOV #0xB1A, W5
00896A  20BC64     MOV #0xBC6, W4
00896C  200FF6     MOV #0xFF, W6
385:                   unsigned int i;
386:                   static volatile ANALOGS LastAnalogs; //for checking for change
387:                   static volatile BUTTONS LastButtons; //for checking for change
388:                   BOOL changeFlag = FALSE;
389:                   signed int analogChange;
390:                   
391:                   //check for change
392:                   for (i=0; i<NUM_BUTTONS; i++){
0089A6  E80183     INC W3, W3
0089A8  518FF2     SUB W3, #0x12, [W15]
0089AA  3AFFE1     BRA NZ, 0x896E
0089AC  EB0280     CLR W5
0089AE  20BC67     MOV #0xBC6, W7
0089B0  20B3E6     MOV #0xB3E, W6
393:                       if (LastButtons.array[i] != CurrentStateBuffer.Buttons.array[i]){
00896E  418003     ADD W3, W3, W0
008970  400085     ADD W0, W5, W1
008972  FB8111     ZE [W1], W2
008974  904091     MOV.B [W1+1], W1
008976  DD08C8     SL W1, #8, W1
008978  708082     IOR W1, W2, W1
00897A  400004     ADD W0, W4, W0
00897C  FB8110     ZE [W0], W2
00897E  904010     MOV.B [W0+1], W0
008980  DD0048     SL W0, #8, W0
008982  700002     IOR W0, W2, W0
008984  508F80     SUB W1, W0, [W15]
008986  320001     BRA Z, 0x898A
008988  200018     MOV #0x1, W8
394:                           changeFlag = TRUE;
395:                       }
396:                       LastButtons.array[i] = CurrentStateBuffer.Buttons.array[i];
00898A  418083     ADD W3, W3, W1
00898C  408004     ADD W1, W4, W0
00898E  FB8110     ZE [W0], W2
008990  904010     MOV.B [W0+1], W0
008992  DD0048     SL W0, #8, W0
008994  700002     IOR W0, W2, W0
008996  408085     ADD W1, W5, W1
008998  600106     AND W0, W6, W2
00899A  784391     MOV.B [W1], W7
00899C  63C8E0     AND.B W7, #0x0, [W1]
00899E  714891     IOR.B W2, [W1], [W1]
0089A0  DE0048     LSR W0, #8, W0
0089A2  904111     MOV.B [W1+1], W2
0089A4  984090     MOV.B W0, [W1+1]
397:                   }
398:                   
399:                   for (i = 0; i<NUM_SERVOS; i++){
008A30  E80285     INC W5, W5
008A32  528FEC     SUB W5, #0xC, [W15]
008A34  3AFFBE     BRA NZ, 0x89B2
400:                       if (CurrentStateBuffer.Analogs.array[i] > LastAnalogs.array[i]) {
0089B2  428105     ADD W5, W5, W2
0089B4  200240     MOV #0x24, W0
0089B6  400002     ADD W0, W2, W0
0089B8  400207     ADD W0, W7, W4
0089BA  FB8014     ZE [W4], W0
0089BC  904094     MOV.B [W4+1], W1
0089BE  DD08C8     SL W1, #8, W1
0089C0  708080     IOR W1, W0, W1
0089C2  410186     ADD W2, W6, W3
0089C4  FB8113     ZE [W3], W2
0089C6  904013     MOV.B [W3+1], W0
0089C8  DD0048     SL W0, #8, W0
0089CA  700002     IOR W0, W2, W0
0089CC  508F80     SUB W1, W0, [W15]
0089CE  34000A     BRA LE, 0x89E4
401:                           analogChange = CurrentStateBuffer.Analogs.array[i] - LastAnalogs.array[i];
0089D0  FB8014     ZE [W4], W0
0089D2  904094     MOV.B [W4+1], W1
0089D4  DD08C8     SL W1, #8, W1
0089D6  708080     IOR W1, W0, W1
0089D8  FB8113     ZE [W3], W2
0089DA  904013     MOV.B [W3+1], W0
0089DC  DD0048     SL W0, #8, W0
0089DE  700002     IOR W0, W2, W0
0089E0  508080     SUB W1, W0, W1
0089E2  37000D     BRA 0x89FE
402:                       }
403:                       else {
404:                           analogChange = LastAnalogs.array[i] - CurrentStateBuffer.Analogs.array[i];
0089E4  428005     ADD W5, W5, W0
0089E6  400086     ADD W0, W6, W1
0089E8  FB8111     ZE [W1], W2
0089EA  904091     MOV.B [W1+1], W1
0089EC  DD08C8     SL W1, #8, W1
0089EE  708082     IOR W1, W2, W1
0089F0  B00240     ADD #0x24, W0
0089F2  400007     ADD W0, W7, W0
0089F4  FB8110     ZE [W0], W2
0089F6  904010     MOV.B [W0+1], W0
0089F8  DD0048     SL W0, #8, W0
0089FA  700002     IOR W0, W2, W0
0089FC  508080     SUB W1, W0, W1
405:                       }
406:               
407:                       if (i == TILT_X || i ==TILT_Y) {
0089FE  52806A     SUB W5, #0xA, W0
008A00  500FE1     SUB W0, #0x1, [W15]
008A02  3E0004     BRA GTU, 0x8A0C
408:                           if (analogChange > 200) {
008A04  200C80     MOV #0xC8, W0
008A06  508F80     SUB W1, W0, [W15]
008A08  3C0003     BRA GT, 0x8A10
008A0A  370003     BRA 0x8A12
409:                               changeFlag = TRUE;
410:                           }
411:                       } else {
412:                           if (analogChange > 5) {
008A0C  508FE5     SUB W1, #0x5, [W15]
008A0E  340001     BRA LE, 0x8A12
008A10  200018     MOV #0x1, W8
413:                               changeFlag = TRUE;
414:                           }
415:                       }
416:                       LastAnalogs.array[i] = CurrentStateBuffer.Analogs.array[i];
008A12  428085     ADD W5, W5, W1
008A14  200240     MOV #0x24, W0
008A16  400001     ADD W0, W1, W0
008A18  400007     ADD W0, W7, W0
008A1A  FB8110     ZE [W0], W2
008A1C  904010     MOV.B [W0+1], W0
008A1E  DD0048     SL W0, #8, W0
008A20  700002     IOR W0, W2, W0
008A22  408086     ADD W1, W6, W1
008A24  784111     MOV.B [W1], W2
008A26  6148E0     AND.B W2, #0x0, [W1]
008A28  704891     IOR.B W0, [W1], [W1]
008A2A  DE0048     LSR W0, #8, W0
008A2C  904111     MOV.B [W1+1], W2
008A2E  984090     MOV.B W0, [W1+1]
417:                   }
418:                   
419:                   if (CurrentStateBuffer.Tpad.wholePad.incrementX != 0 || CurrentStateBuffer.Tpad.wholePad.incrementY!= 0) {
008A36  20C0F1     MOV #0xC0F, W1
008A38  784091     MOV.B [W1], W1
008A3A  FB8081     ZE W1, W1
008A3C  BFCC10     MOV.B 0xC10, WREG
008A3E  DD0048     SL W0, #8, W0
008A40  700001     IOR W0, W1, W0
008A42  3A0002     BRA NZ, 0x8A48
008A44  BFCC11     MOV.B 0xC11, WREG
008A46  BFCC12     MOV.B 0xC12, WREG
420:                       //changeFlag = TRUE;
421:                   }
422:                   //update idle timer if no input change.
423:                   if (changeFlag == FALSE) {
008A48  E00008     CP0 W8
008A4A  3A0005     BRA NZ, 0x8A56
424:                       if (idleTimer < 0xFFFF) {
008A4C  805880     MOV idleTimer, W0
008A4E  400FE1     ADD W0, #0x1, [W15]
008A50  320003     BRA Z, 0x8A58
425:                           idleTimer++;
008A52  EC2B10     INC idleTimer
008A54  370001     BRA 0x8A58
426:                       }
427:                   }
428:                   else {
429:                       ResetIdleTimer();
008A56  070144     RCALL ResetIdleTimer
008A58  140061     SUBR W8, #0x1, W0
430:                   }
431:                   /*
432:                   if (changeFlag){
433:                       UART2PutHex(changeFlag);
434:                   }
435:                   UART2PutDecInt(idleTimer);
436:                   UART2PrintString("\n\r");
437:                    */
438:                   return !changeFlag;
439:               
440:               }
008A5A  78044F     MOV [--W15], W8
008A5C  060000     RETURN
441:               
442:               
443:               /*******************************************************************************
444:               Function:  UpdateNewPress(void)
445:               
446:               Precondition:
447:                   None.
448:               
449:               Overview:
450:                   This routine updates the states for button presses 
451:                * PressDuration: how long the button has been held down (10ms per count)
452:                * NewPress: if this is a new button press
453:               
454:               Input: level: 0-255, determines rumble strength.  6 levels available.
455:               
456:               Output: None
457:               
458:                *******************************************************************************/
459:               void UpdateNewPress(void) {
008A5E  BE9F88     MOV.D W8, [W15++]
008A60  781F8A     MOV W10, [W15++]
008A62  EB0180     CLR W3
008A64  20BC65     MOV #0xBC6, W5
008A66  20BA2A     MOV #0xBA2, W10
008A68  200FF7     MOV #0xFF, W7
008A6A  EB4400     CLR.B W8
008A6C  20B5A6     MOV #0xB5A, W6
008A6E  20B7E9     MOV #0xB7E, W9
460:                   unsigned int i;
461:                   //BOOL changeFlag = FALSE; //this flag is set if there there is change in
462:                   //unsigned int analogChange;
463:               
464:                   //Update Button state record
465:                   for (i = 0; i < NUM_BUTTONS; i++) {
008AF6  E80183     INC W3, W3
008AF8  518FF2     SUB W3, #0x12, [W15]
008AFA  3AFFBA     BRA NZ, 0x8A70
466:                       //Set press duration counter to 1 immediately after being pressed or 0 after being released, or else it won't update until the Timer4 flag is set
467:                       if (CurrentStateBuffer.Buttons.array[i] > 0) {
008A70  418103     ADD W3, W3, W2
008A72  410005     ADD W2, W5, W0
008A74  FB8090     ZE [W0], W1
008A76  904010     MOV.B [W0+1], W0
008A78  DD0048     SL W0, #8, W0
008A7A  700001     IOR W0, W1, W0
008A7C  32000E     BRA Z, 0x8A9A
468:                           PressDuration.array[i]++;
008A7E  41008A     ADD W2, W10, W1
008A80  FB8111     ZE [W1], W2
008A82  904011     MOV.B [W1+1], W0
008A84  DD0048     SL W0, #8, W0
008A86  700002     IOR W0, W2, W0
008A88  E80000     INC W0, W0
008A8A  600107     AND W0, W7, W2
008A8C  784211     MOV.B [W1], W4
008A8E  6248E0     AND.B W4, #0x0, [W1]
008A90  714891     IOR.B W2, [W1], [W1]
008A92  DE0048     LSR W0, #8, W0
008A94  904111     MOV.B [W1+1], W2
008A96  984090     MOV.B W0, [W1+1]
008A98  370006     BRA 0x8AA6
469:                       }
470:                       else {
471:                           PressDuration.array[i] = 0;
008A9A  418003     ADD W3, W3, W0
008A9C  40000A     ADD W0, W10, W0
008A9E  784090     MOV.B [W0], W1
008AA0  60C860     AND.B W1, #0x0, [W0]
008AA2  904090     MOV.B [W0+1], W1
008AA4  984018     MOV.B W8, [W0+1]
472:                       }
473:                       //detect if a button is newly pressed
474:                       if (CurrentStateBuffer.Buttons.array[i] > 0 && LastPress.array[i] == 0) {
008AA6  418103     ADD W3, W3, W2
008AA8  410005     ADD W2, W5, W0
008AAA  FB8090     ZE [W0], W1
008AAC  904010     MOV.B [W0+1], W0
008AAE  DD0048     SL W0, #8, W0
008AB0  700001     IOR W0, W1, W0
008AB2  32000D     BRA Z, 0x8ACE
008AB4  410006     ADD W2, W6, W0
008AB6  FB8090     ZE [W0], W1
008AB8  904010     MOV.B [W0+1], W0
008ABA  DD0048     SL W0, #8, W0
008ABC  700201     IOR W0, W1, W4
008ABE  3A0007     BRA NZ, 0x8ACE
475:                           NewPress.array[i] = 1;
008AC0  410009     ADD W2, W9, W0
008AC2  784090     MOV.B [W0], W1
008AC4  60C860     AND.B W1, #0x0, [W0]
008AC6  A00410     BSET.B [W0], #0
008AC8  904090     MOV.B [W0+1], W1
008ACA  984014     MOV.B W4, [W0+1]
008ACC  370006     BRA 0x8ADA
476:                       }
477:                       else {
478:                           NewPress.array[i] = 0;
008ACE  418003     ADD W3, W3, W0
008AD0  400009     ADD W0, W9, W0
008AD2  784210     MOV.B [W0], W4
008AD4  624860     AND.B W4, #0x0, [W0]
008AD6  904090     MOV.B [W0+1], W1
008AD8  984018     MOV.B W8, [W0+1]
479:                       }
480:                       LastPress.array[i] = CurrentStateBuffer.Buttons.array[i];
008ADA  418083     ADD W3, W3, W1
008ADC  408005     ADD W1, W5, W0
008ADE  FB8110     ZE [W0], W2
008AE0  904010     MOV.B [W0+1], W0
008AE2  DD0048     SL W0, #8, W0
008AE4  700002     IOR W0, W2, W0
008AE6  408086     ADD W1, W6, W1
008AE8  600107     AND W0, W7, W2
008AEA  784211     MOV.B [W1], W4
008AEC  6248E0     AND.B W4, #0x0, [W1]
008AEE  714891     IOR.B W2, [W1], [W1]
008AF0  DE0048     LSR W0, #8, W0
008AF2  904111     MOV.B [W1+1], W2
008AF4  984090     MOV.B W0, [W1+1]
481:                   }
482:               }
008AFC  78054F     MOV [--W15], W10
008AFE  BE044F     MOV.D [--W15], W8
008B00  060000     RETURN
483:               ////////////////////////GET functions////////////////////////////////////
484:               
485:               BUTTONS* GetButtonPress(void) {
486:                   return (BUTTONS*)&(CurrentStateBuffer.Buttons);
487:               }
008B02  20BC60     MOV #0xBC6, W0
008B04  060000     RETURN
488:               
489:               BUTTONS* GetPressDuration(void) {
490:                   return (BUTTONS*)&(PressDuration);
491:               }
008B06  20BA20     MOV #0xBA2, W0
008B08  060000     RETURN
492:               
493:               BUTTONS* GetNewPress(void) {
494:                   return (BUTTONS*)&(NewPress);
495:               }
008B0A  20B7E0     MOV #0xB7E, W0
008B0C  060000     RETURN
496:               
497:               ANALOGS* GetAnalogs(void) {
498:                   return (ANALOGS*)&(CurrentStateBuffer.Analogs);
499:               }
008B0E  20BEA0     MOV #0xBEA, W0
008B10  060000     RETURN
500:               
501:               TOUCHPAD_STRUCT* GetTouchpads(void) {
502:                   return (TOUCHPAD_STRUCT*)&(CurrentStateBuffer.Tpad);
503:               }
008B12  20C020     MOV #0xC02, W0
008B14  060000     RETURN
504:               
505:               //Returns PS4 input report.  We first byte to 0xFF to identify stagnant data.
506:               
507:               BYTE* GetPS4Report(void) {
508:                   return (BYTE*) PS4_report_buf;
509:               }
008B16  20C3C0     MOV #0xC3C, W0
008B18  060000     RETURN
510:               
511:               CONTROLLER_OUTPUT* GetOutputPacket(void) {
008B1A  806FA0     MOV 0xDF4, W0
512:                   return (CONTROLLER_OUTPUT*) PS4OutputPtr;
513:               }
008B1C  060000     RETURN
514:               
515:               BYTE* GetOutputReportWire(void) {
008B1E  806F90     MOV 0xDF2, W0
516:                   return (BYTE*) outputReportWire;
517:               }
008B20  060000     RETURN
518:               
519:               BYTE* GetOutputReportBT(void) {
520:                   return (BYTE*) outputReportBT;
521:               }
008B22  20D9A0     MOV #0xD9A, W0
008B24  060000     RETURN
522:               
523:               void SetLEDColor(LED_COLORS color, unsigned char intensity, unsigned char blinkOn, unsigned char blinkOff) {
008B26  780280     MOV W0, W5
008B28  784201     MOV.B W1, W4
008B2A  784083     MOV.B W3, W1
524:                   //Beware that the intensity parameter can cause overflow, too lazy to put in checks.  Use carefully!
525:                   /*
526:               typedef enum {
527:                   RED = 0,
528:                   ORANGE = 1,
529:                   YELLOW = 2,
530:                   LIME = 3,
531:                   GREEN = 4,
532:                   TURQUOISE = 5,
533:                   BLUE = 6,
534:                   PURPLE = 7,
535:                   PINK = 8,
536:                   WHITE = 9,
537:                   LED_OFF = 10,
538:                   COLOR_ADC = 11,
539:                   BATTERY = 12
540:               }LED_COLORS;
541:                    */
542:                   if (intensity >= 50)
008B2C  B3C310     MOV.B #0x31, W0
008B2E  524F80     SUB.B W4, W0, [W15]
008B30  360001     BRA LEU, 0x8B34
008B32  B3C324     MOV.B #0x32, W4
543:                   {
544:                       intensity = 50;
545:                   }
546:                   
547:                   PS4OutputPtr->blinkOnDuration = blinkOn;
008B34  806FA0     MOV 0xDF4, W0
008B36  985042     MOV.B W2, [W0+20]
548:                   PS4OutputPtr->blinkOffDuration = blinkOff;
008B38  806FA0     MOV 0xDF4, W0
008B3A  985051     MOV.B W1, [W0+21]
549:                   
550:                   switch (color) {
008B3C  B82861     MUL.UU W5, #1, W0
008B3E  500FE9     SUB W0, #0x9, [W15]
008B40  588FE0     SUBB W1, #0x0, [W15]
008B42  3E0071     BRA GTU, 0x8C26
008B44  016000     BRA W0
008B46  370013     BRA 0x8B6E
008B48  37001C     BRA 0x8B82
008B4A  370026     BRA 0x8B98
008B4C  37002F     BRA 0x8BAC
008B4E  370039     BRA 0x8BC2
008B50  370042     BRA 0x8BD6
008B52  370003     BRA 0x8B5A
008B54  37004B     BRA 0x8BEC
008B56  370055     BRA 0x8C02
008B58  37005F     BRA 0x8C18
551:                       case BLUE: //blue
552:                           PS4OutputPtr->LEDRed = 0;
008B5A  EB4080     CLR.B W1
008B5C  806FA0     MOV 0xDF4, W0
008B5E  985011     MOV.B W1, [W0+17]
553:                           PS4OutputPtr->LEDGreen = 0;
008B60  806FA0     MOV 0xDF4, W0
008B62  985021     MOV.B W1, [W0+18]
554:                           PS4OutputPtr->LEDBlue = 4 * intensity;
008B64  FB8004     ZE W4, W0
008B66  DD0042     SL W0, #2, W0
008B68  806FA1     MOV 0xDF4, W1
008B6A  9850B0     MOV.B W0, [W1+19]
008B6C  370063     BRA 0x8C34
555:                           break;
556:                       case RED: //red
557:                           PS4OutputPtr->LEDRed = 4 * intensity;
008B6E  FB8004     ZE W4, W0
008B70  DD0042     SL W0, #2, W0
008B72  806FA1     MOV 0xDF4, W1
008B74  985090     MOV.B W0, [W1+17]
558:                           PS4OutputPtr->LEDGreen = 0;
008B76  EB4080     CLR.B W1
008B78  806FA0     MOV 0xDF4, W0
008B7A  985021     MOV.B W1, [W0+18]
559:                           PS4OutputPtr->LEDBlue = 0;
008B7C  806FA0     MOV 0xDF4, W0
008B7E  985031     MOV.B W1, [W0+19]
008B80  370059     BRA 0x8C34
560:                           break;
561:                       case ORANGE: //orange
562:                           PS4OutputPtr->LEDRed = 3 * intensity;
008B82  784004     MOV.B W4, W0
008B84  B3C032     MOV.B #0x3, W2
008B86  BC4004     MUL.B WREG2
008B88  806FA0     MOV 0xDF4, W0
008B8A  985012     MOV.B W2, [W0+17]
563:                           PS4OutputPtr->LEDGreen = 1 * intensity;
008B8C  806FA0     MOV 0xDF4, W0
008B8E  985024     MOV.B W4, [W0+18]
564:                           PS4OutputPtr->LEDBlue = 0;
008B90  EB4080     CLR.B W1
008B92  806FA0     MOV 0xDF4, W0
008B94  985031     MOV.B W1, [W0+19]
008B96  37004E     BRA 0x8C34
565:                           break;
566:                       case YELLOW: //yellow
567:                           PS4OutputPtr->LEDRed = 2 * intensity;
008B98  FB8004     ZE W4, W0
008B9A  400000     ADD W0, W0, W0
008B9C  806FA1     MOV 0xDF4, W1
008B9E  985090     MOV.B W0, [W1+17]
568:                           PS4OutputPtr->LEDGreen = 2 * intensity;
008BA0  806FA1     MOV 0xDF4, W1
008BA2  9850A0     MOV.B W0, [W1+18]
569:                           PS4OutputPtr->LEDBlue = 0;
008BA4  EB4080     CLR.B W1
008BA6  806FA0     MOV 0xDF4, W0
008BA8  985031     MOV.B W1, [W0+19]
008BAA  370044     BRA 0x8C34
570:                           break;
571:                       case LIME://lime
572:                           PS4OutputPtr->LEDRed = 1 * intensity;
008BAC  806FA0     MOV 0xDF4, W0
008BAE  985014     MOV.B W4, [W0+17]
573:                           PS4OutputPtr->LEDGreen = 3 * intensity;
008BB0  784004     MOV.B W4, W0
008BB2  B3C032     MOV.B #0x3, W2
008BB4  BC4004     MUL.B WREG2
008BB6  806FA0     MOV 0xDF4, W0
008BB8  985022     MOV.B W2, [W0+18]
574:                           PS4OutputPtr->LEDBlue = 0;
008BBA  EB4080     CLR.B W1
008BBC  806FA0     MOV 0xDF4, W0
008BBE  985031     MOV.B W1, [W0+19]
008BC0  370039     BRA 0x8C34
575:                           break;
576:                       case GREEN: //green
577:                           PS4OutputPtr->LEDRed = 0;
008BC2  EB4100     CLR.B W2
008BC4  806FA0     MOV 0xDF4, W0
008BC6  985012     MOV.B W2, [W0+17]
578:                           PS4OutputPtr->LEDGreen = 4 * intensity;
008BC8  FB8004     ZE W4, W0
008BCA  DD0042     SL W0, #2, W0
008BCC  806FA1     MOV 0xDF4, W1
008BCE  9850A0     MOV.B W0, [W1+18]
579:                           PS4OutputPtr->LEDBlue = 0;
008BD0  806FA0     MOV 0xDF4, W0
008BD2  985032     MOV.B W2, [W0+19]
008BD4  37002F     BRA 0x8C34
580:                           break;
581:                       case TURQUOISE: //turquoise
582:                           PS4OutputPtr->LEDRed = 0;
008BD6  EB4080     CLR.B W1
008BD8  806FA0     MOV 0xDF4, W0
008BDA  985011     MOV.B W1, [W0+17]
583:                           PS4OutputPtr->LEDGreen = 3 * intensity;
008BDC  784004     MOV.B W4, W0
008BDE  B3C032     MOV.B #0x3, W2
008BE0  BC4004     MUL.B WREG2
008BE2  806FA0     MOV 0xDF4, W0
008BE4  985022     MOV.B W2, [W0+18]
584:                           PS4OutputPtr->LEDBlue = 1 * intensity;
008BE6  806FA0     MOV 0xDF4, W0
008BE8  985034     MOV.B W4, [W0+19]
008BEA  370024     BRA 0x8C34
585:                           break;
586:                       case PURPLE: //purple
587:                           PS4OutputPtr->LEDRed = 1 * intensity;
008BEC  806FA0     MOV 0xDF4, W0
008BEE  985014     MOV.B W4, [W0+17]
588:                           PS4OutputPtr->LEDGreen = 0;
008BF0  EB4080     CLR.B W1
008BF2  806FA0     MOV 0xDF4, W0
008BF4  985021     MOV.B W1, [W0+18]
589:                           PS4OutputPtr->LEDBlue = 3 * intensity;
008BF6  784004     MOV.B W4, W0
008BF8  B3C032     MOV.B #0x3, W2
008BFA  BC4004     MUL.B WREG2
008BFC  806FA0     MOV 0xDF4, W0
008BFE  985032     MOV.B W2, [W0+19]
008C00  370019     BRA 0x8C34
590:                           break;
591:                       case PINK: //pink
592:                           PS4OutputPtr->LEDRed = 3 * intensity;
008C02  784004     MOV.B W4, W0
008C04  B3C032     MOV.B #0x3, W2
008C06  BC4004     MUL.B WREG2
008C08  806FA0     MOV 0xDF4, W0
008C0A  985012     MOV.B W2, [W0+17]
593:                           PS4OutputPtr->LEDGreen = 0;
008C0C  EB4080     CLR.B W1
008C0E  806FA0     MOV 0xDF4, W0
008C10  985021     MOV.B W1, [W0+18]
594:                           PS4OutputPtr->LEDBlue = 1 * intensity;
008C12  806FA0     MOV 0xDF4, W0
008C14  985034     MOV.B W4, [W0+19]
008C16  37000E     BRA 0x8C34
595:                           break;
596:                       case WHITE: //white
597:                           PS4OutputPtr->LEDRed = 1 * intensity;
008C18  806FA0     MOV 0xDF4, W0
008C1A  985014     MOV.B W4, [W0+17]
598:                           PS4OutputPtr->LEDGreen = 1 * intensity;
008C1C  806FA0     MOV 0xDF4, W0
008C1E  985024     MOV.B W4, [W0+18]
599:                           PS4OutputPtr->LEDBlue = 1 * intensity;
008C20  806FA0     MOV 0xDF4, W0
008C22  985034     MOV.B W4, [W0+19]
008C24  370007     BRA 0x8C34
600:                           break;
601:                       default:
602:                           PS4OutputPtr->LEDRed = 0;
008C26  EB4080     CLR.B W1
008C28  806FA0     MOV 0xDF4, W0
008C2A  985011     MOV.B W1, [W0+17]
603:                           PS4OutputPtr->LEDGreen = 0;
008C2C  806FA0     MOV 0xDF4, W0
008C2E  985021     MOV.B W1, [W0+18]
604:                           PS4OutputPtr->LEDBlue = 0;
008C30  806FA0     MOV 0xDF4, W0
008C32  985031     MOV.B W1, [W0+19]
605:               
606:                           break;
607:                   }
608:               }
008C34  060000     RETURN
609:               
610:               void SetLEDColorRGB(unsigned char red, unsigned char green, unsigned char blue, unsigned char blinkOn, unsigned char blinkOff) {
611:                   PS4OutputPtr->LEDRed = red;
008C36  806FA5     MOV 0xDF4, W5
008C38  985290     MOV.B W0, [W5+17]
612:                   PS4OutputPtr->LEDGreen = green;
008C3A  806FA0     MOV 0xDF4, W0
008C3C  985021     MOV.B W1, [W0+18]
613:                   PS4OutputPtr->LEDBlue = blue;
008C3E  806FA0     MOV 0xDF4, W0
008C40  985032     MOV.B W2, [W0+19]
614:                   PS4OutputPtr->blinkOnDuration = blinkOn;
008C42  806FA0     MOV 0xDF4, W0
008C44  985043     MOV.B W3, [W0+20]
615:                   PS4OutputPtr->blinkOffDuration = blinkOff;
008C46  806FA0     MOV 0xDF4, W0
008C48  985054     MOV.B W4, [W0+21]
616:               }
008C4A  060000     RETURN
617:               /*******************************************************************************
618:               Function: SetRumbleH(unsigned char level)
619:               
620:               Precondition:
621:                   None.
622:               
623:               Overview:
624:                   This turns on the fast rumble
625:               
626:               Input: level: 0-255, determines rumble strength. 
627:               Output: None
628:               
629:                *******************************************************************************/
630:               void SetRumbleH(unsigned char level) {
008C4C  784080     MOV.B W0, W1
631:                   if (level < 10) level = 0;
008C4E  504FE9     SUB.B W0, #0x9, [W15]
008C50  3E0001     BRA GTU, 0x8C54
008C52  EB4080     CLR.B W1
632:                   PS4OutputPtr->rumbleHPower = level;
008C54  806FA0     MOV 0xDF4, W0
008C56  984871     MOV.B W1, [W0+15]
633:               }
008C58  060000     RETURN
634:               
635:               /*******************************************************************************
636:               Function: SetRumbleL(unsigned char level)
637:               
638:               Precondition:
639:                   None.
640:               
641:               Overview:
642:                   This turns on the slow rumble
643:               
644:               Input: level: 0-255, determines rumble strength.
645:               
646:               Output: None
647:               
648:                *******************************************************************************/
649:               void SetRumbleL(unsigned char level) {
008C5A  784080     MOV.B W0, W1
650:                   if (level < 10) level = 0;
008C5C  504FE9     SUB.B W0, #0x9, [W15]
008C5E  3E0001     BRA GTU, 0x8C62
008C60  EB4080     CLR.B W1
651:                   PS4OutputPtr->rumbleLPower = level;
008C62  806FA0     MOV 0xDF4, W0
008C64  985001     MOV.B W1, [W0+16]
652:               }
008C66  060000     RETURN
653:               
654:               void UpdateBatteryDisplay(BOOL override) { //override will display battery even if psButton isn't pressed
008C68  780100     MOV W0, W2
655:                   static unsigned int displayBattCounter;
656:                   
657:                   //override LED state with battery meter if PS button is pressed.
658:                   if (CurrentStateBuffer.Buttons.psButton == 1 || override == TRUE) {
008C6A  20BE81     MOV #0xBE8, W1
008C6C  784091     MOV.B [W1], W1
008C6E  FB8081     ZE W1, W1
008C70  BFCBE9     MOV.B 0xBE9, WREG
008C72  DD0048     SL W0, #8, W0
008C74  700001     IOR W0, W1, W0
008C76  500FE1     SUB W0, #0x1, [W15]
008C78  320002     BRA Z, 0x8C7E
008C7A  510FE1     SUB W2, #0x1, [W15]
008C7C  3A0002     BRA NZ, 0x8C82
659:                       displayBattCounter = 10;
008C7E  2000A0     MOV #0xA, W0
008C80  885AB0     MOV W0, displayBattCounter
660:                   }
661:                   if (displayBattCounter > 0) {
008C82  E20B56     CP0 displayBattCounter
008C84  32001B     BRA Z, 0x8CBC
662:                       if (CurrentStateBuffer.battery >= 4) 
008C86  BFCC3B     MOV.B 0xC3B, WREG
008C88  504FE3     SUB.B W0, #0x3, [W15]
008C8A  360007     BRA LEU, 0x8C9A
663:                       {
664:                           SetLEDColor(GREEN,GetLEDBrightness(),0,0);
008C8C  07ECFD     RCALL GetLEDBrightness
008C8E  EB4180     CLR.B W3
008C90  784103     MOV.B W3, W2
008C92  784080     MOV.B W0, W1
008C94  200040     MOV #0x4, W0
008C96  07FF47     RCALL SetLEDColor
008C98  370010     BRA 0x8CBA
665:                       }
666:                       else if (CurrentStateBuffer.battery >= 2)
008C9A  BFCC3B     MOV.B 0xC3B, WREG
008C9C  504FE1     SUB.B W0, #0x1, [W15]
008C9E  360007     BRA LEU, 0x8CAE
667:                       {
668:                           SetLEDColor(YELLOW,GetLEDBrightness(),0,0);
008CA0  07ECF3     RCALL GetLEDBrightness
008CA2  EB4180     CLR.B W3
008CA4  784103     MOV.B W3, W2
008CA6  784080     MOV.B W0, W1
008CA8  200020     MOV #0x2, W0
008CAA  07FF3D     RCALL SetLEDColor
008CAC  370006     BRA 0x8CBA
669:                       }
670:                       else
671:                       {
672:                           SetLEDColor(RED,GetLEDBrightness(),0,0);
008CAE  07ECEC     RCALL GetLEDBrightness
008CB0  EB4180     CLR.B W3
008CB2  784103     MOV.B W3, W2
008CB4  784080     MOV.B W0, W1
008CB6  EB0000     CLR W0
008CB8  07FF36     RCALL SetLEDColor
673:                       }
674:                       //UART2PutHex(CurrentStateBuffer.battery);
675:                       //UART2PrintString("\n\r");
676:                       displayBattCounter--;
008CBA  ED2B56     DEC displayBattCounter
677:               
678:                   }
679:               }
008CBC  060000     RETURN
680:               
681:               //This function is used to control timing for rumble feedback when setting configurations.
682:               
683:               void UpdateRumbleFeedback(unsigned int duration) {
684:                   static unsigned int rumbleCounter;
685:               
686:                   // if duration > 0, then it is a set operation
687:                   //if duration == 0, then decrement the counter
688:                   if (duration > 0) //set duration
008CBE  E00000     CP0 W0
008CC0  320004     BRA Z, 0x8CCA
689:                   {
690:                       rumbleCounter = duration;
008CC2  885AC0     MOV W0, rumbleCounter
691:                       SetRumbleH(0xFF);
008CC4  EBC000     SETM.B W0
008CC6  07FFC2     RCALL SetRumbleH
008CC8  370008     BRA 0x8CDA
692:                   }
693:                   else if (duration == 0) //update timer
694:                   {
695:                       if (rumbleCounter > 0) {
008CCA  E20B58     CP0 rumbleCounter
008CCC  320006     BRA Z, 0x8CDA
696:                           SetRumbleH(0xFF);
008CCE  EBC000     SETM.B W0
008CD0  07FFBD     RCALL SetRumbleH
697:                           rumbleCounter--;
008CD2  ED0B58     DEC rumbleCounter, WREG
008CD4  885AC0     MOV W0, rumbleCounter
698:                           if (rumbleCounter == 0) {
008CD6  3A0001     BRA NZ, 0x8CDA
699:                               SetRumbleH(0);
008CD8  07FFB9     RCALL SetRumbleH
700:                           }
701:                       }
702:                   }
703:               }
008CDA  060000     RETURN
704:               
705:               //Check idle timer used for auto-disconnect
706:               
707:               unsigned int GetIdleTimer(void) {
708:                   return idleTimer;
008CDC  805880     MOV idleTimer, W0
709:               }
008CDE  060000     RETURN
710:               
711:               //reset idle timer used for auto-disconnect
712:               
713:               void ResetIdleTimer(void) {
714:                   idleTimer = 0;
008CE0  EF2B10     CLR idleTimer
715:               }
008CE2  060000     RETURN
716:               
717:               
---  D:/PIC/PIC_PS4_Host/trunk/PS4_SPI.c  ---------------------------------------------------------------
1:                 /***********************************************************************
2:                     PS4 USB Host
3:                     Copyright (C) 2013 Cross Product Creations
4:                 
5:                     This program is free software: you can redistribute it and/or modify
6:                     it under the terms of the GNU General Public License as published by
7:                     the Free Software Foundation, either version 3 of the License, or
8:                     (at your option) any later version.
9:                 
10:                    This program is distributed in the hope that it will be useful,
11:                    but WITHOUT ANY WARRANTY; without even the implied warranty of
12:                    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
13:                    GNU General Public License for more details.
14:                
15:                    You should have received a copy of the GNU General Public License
16:                    along with this program.  If not, see <http://www.gnu.org/licenses/>.
17:                 *************************************************************************/
18:                
19:                #include "PS4_SPI.h"
20:                
21:                volatile BYTE spiInputBuf[SPI_INPUT_PACKET_LENGTH];
22:                
23:                void initSPI(void) {
24:                    BYTE temp;
25:                
26:                    RPINR20bits.SCK1R = 2; //map SCK1IN to RP2
009B88  BFC6A9     MOV.B 0x6A9, WREG
009B8A  B3CC01     MOV.B #0xC0, W1
009B8C  604001     AND.B W0, W1, W0
009B8E  A01400     BSET.B W0, #1
009B90  B7E6A9     MOV.B WREG, 0x6A9
27:                    RPINR20bits.SDI1R = 4; //map SDI1 to RP4
009B92  BFC6A8     MOV.B RPINR20, WREG
009B94  604001     AND.B W0, W1, W0
009B96  A02400     BSET.B W0, #2
009B98  B7E6A8     MOV.B WREG, RPINR20
28:                    RPINR21bits.SS1R = 12; //map SS1R to RP12
009B9A  BFC6AA     MOV.B RPINR21, WREG
009B9C  604001     AND.B W0, W1, W0
009B9E  B340C0     IOR.B #0xC, W0
009BA0  B7E6AA     MOV.B WREG, RPINR21
29:                    RPOR1bits.RP3R = 7; //map RP3 to SDO1
009BA2  BFC6C3     MOV.B 0x6C3, WREG
009BA4  604001     AND.B W0, W1, W0
009BA6  B34070     IOR.B #0x7, W0
009BA8  B7E6C3     MOV.B WREG, 0x6C3
30:                
31:                    //Map interrupt for /SS line
32:                    _TRISD0 = 1;
009BAA  A802D8     BSET TRISD, #0
33:                    RPINR0bits.INT1R = 11;
009BAC  BFC681     MOV.B 0x681, WREG
009BAE  604001     AND.B W0, W1, W0
009BB0  B340B0     IOR.B #0xB, W0
009BB2  B7E681     MOV.B WREG, 0x681
34:                    IPC5bits.INT1IP = 5; //set slave select interrupt priority
009BB4  BFC0AE     MOV.B IPC5, WREG
009BB6  B3CF81     MOV.B #0xF8, W1
009BB8  604001     AND.B W0, W1, W0
009BBA  B34050     IOR.B #0x5, W0
009BBC  B7E0AE     MOV.B WREG, IPC5
35:                    INTCON2bits.INT1EP = 0; //interrupt on positive edge
009BBE  A92082     BCLR INTCON2, #1
36:                    IFS1bits.INT1IF = 0;
009BC0  A98086     BCLR IFS1, #4
37:                
38:                    SPI1STATbits.SISEL = 0b001; //interrupt when data is available.
009BC2  BFC240     MOV.B SPI1STAT, WREG
009BC4  B3CE31     MOV.B #0xE3, W1
009BC6  604001     AND.B W0, W1, W0
009BC8  A02400     BSET.B W0, #2
009BCA  B7E240     MOV.B WREG, SPI1STAT
39:                    SPI1CON1 = 0;
009BCC  EB0000     CLR W0
009BCE  881210     MOV W0, SPI1CON1
40:                    SPI1CON1bits.SMP = 0;
009BD0  A92243     BCLR 0x243, #1
41:                    SPI1CON1bits.SSEN = 1;
009BD2  A8E242     BSET SPI1CON1, #7
42:                    SPI1CON1bits.MSTEN = 0; //slave mode
009BD4  A9A242     BCLR SPI1CON1, #5
43:                    SPI1CON2 = 0;
009BD6  881220     MOV W0, SPI1CON2
44:                    SPI1CON2bits.SPIBEN = 1;
009BD8  A80244     BSET SPI1CON2, #0
45:                    switch (GetSpiBusMode()) {
009BDA  07E554     RCALL GetSpiBusMode
009BDC  500FE1     SUB W0, #0x1, [W15]
009BDE  32000B     BRA Z, 0x9BF6
009BE0  390005     BRA NC, 0x9BEC
009BE2  500FE2     SUB W0, #0x2, [W15]
009BE4  32000D     BRA Z, 0x9C00
009BE6  500FE3     SUB W0, #0x3, [W15]
009BE8  3A0015     BRA NZ, 0x9C14
009BEA  37000F     BRA 0x9C0A
46:                        case 0:
47:                            UART2PrintString("SPI Bus Mode 0\n\r");
009BEC  29ED80     MOV #0x9ED8, W0
009BEE  07FD47     RCALL UART2PrintString
48:                            SPI1CON1bits.CKP = 0;
009BF0  A9C242     BCLR SPI1CON1, #6
49:                            SPI1CON1bits.CKE = 1;
009BF2  A80243     BSET 0x243, #0
009BF4  370011     BRA 0x9C18
50:                            break;
51:                
52:                        case 1:
53:                            UART2PrintString("SPI Bus Mode 1\n\r");
009BF6  29EE90     MOV #0x9EE9, W0
009BF8  07FD42     RCALL UART2PrintString
54:                            SPI1CON1bits.CKP = 0;
009BFA  A9C242     BCLR SPI1CON1, #6
55:                            SPI1CON1bits.CKE = 0;
009BFC  A90243     BCLR 0x243, #0
009BFE  37000C     BRA 0x9C18
56:                            break;
57:                
58:                        case 2:
59:                            UART2PrintString("SPI Bus Mode 2\n\r");
009C00  29EFA0     MOV #0x9EFA, W0
009C02  07FD3D     RCALL UART2PrintString
60:                            SPI1CON1bits.CKP = 1;
009C04  A8C242     BSET SPI1CON1, #6
61:                            SPI1CON1bits.CKE = 1;
009C06  A80243     BSET 0x243, #0
009C08  370007     BRA 0x9C18
62:                            break;
63:                
64:                        case 3:
65:                            UART2PrintString("SPI Bus Mode 3\n\r");
009C0A  29F0B0     MOV #0x9F0B, W0
009C0C  07FD38     RCALL UART2PrintString
66:                            SPI1CON1bits.CKP = 1;
009C0E  A8C242     BSET SPI1CON1, #6
67:                            SPI1CON1bits.CKE = 0;
009C10  A90243     BCLR 0x243, #0
009C12  370002     BRA 0x9C18
68:                            break;
69:                
70:                        default:
71:                            UART2PrintString("ERROR SPI BUS MODE\n\r");
009C14  29F1C0     MOV #0x9F1C, W0
009C16  07FD33     RCALL UART2PrintString
72:                            break;
73:                    }
74:                
75:                    IFS0bits.SPI1IF = 0; //clear spi interrupt flag
009C18  A94085     BCLR 0x85, #2
76:                    IPC2bits.SPI1IP = 6; ///set interrupt priority
009C1A  BFC0A9     MOV.B 0xA9, WREG
009C1C  B3CF81     MOV.B #0xF8, W1
009C1E  604001     AND.B W0, W1, W0
009C20  B34060     IOR.B #0x6, W0
009C22  B7E0A9     MOV.B WREG, 0xA9
77:                    IEC0bits.SPI1IE = 1; //enable interrupts
009C24  A84095     BSET 0x95, #2
78:                
79:                    SPI1STATbits.SPIEN = 1;
009C26  A8E241     BSET 0x241, #7
80:                
81:                    while (!SPI1STATbits.SPITBF) {
009C28  BFC240     MOV.B SPI1STAT, WREG
009C2A  A31800     BTST.Z W0, #1
009C2C  3A0005     BRA NZ, 0x9C38
009C2E  200AC1     MOV #0xAC, W1
009C32  BFC240     MOV.B SPI1STAT, WREG
009C34  A31800     BTST.Z W0, #1
009C36  32FFFC     BRA Z, 0x9C30
82:                        SPI1BUF = 0xAC; //fill the buffer so we always start on byte 9
009C30  881241     MOV W1, SPI1BUF
83:                    }
84:                
85:                    while (!SPI1STATbits.SRXMPT) {
009C38  BFC240     MOV.B SPI1STAT, WREG
009C3A  A35800     BTST.Z W0, #5
009C3C  3A0004     BRA NZ, 0x9C46
009C40  BFC240     MOV.B SPI1STAT, WREG
009C42  A35800     BTST.Z W0, #5
009C44  32FFFC     BRA Z, 0x9C3E
86:                        temp = SPI1BUF; //burn off bytes to empty the input buffer.
009C3E  801240     MOV SPI1BUF, W0
87:                    }
88:                
89:                }
009C46  060000     RETURN
90:                
91:                SPI_INPUT_PACKET* GetSpiInputPacket(void) {
92:                    return (SPI_INPUT_PACKET*)&spiInputBuf;
93:                }
009C48  20E760     MOV #0xE76, W0
009C4A  060000     RETURN
94:                
95:                
96:                
---  D:/PIC/PIC_PS4_Host/trunk/DEE Emulation 16-bit/Flash Operations.s  ---------------------------------
                                                  1:     ;*************************************************************************
                                                  2:     ;*
                                                  3:     ;*   Emulating Data EEPROM for PIC24 Microcontrollers and
                                                  4:     ;*           dsPIC Digital Signal Controllers
                                                  5:     ;*
                                                  6:     ;*************************************************************************
                                                  7:     ;* FileName:     Flash Operations.s
                                                  8:     ;* Compiler:     MPLAB C30, v2.01 or higher
                                                  9:     ;* Company:      Microchip Technology, Inc.
                                                  10:    ;*
                                                  11:    ;* Software License Agreement
                                                  12:    ;*
                                                  13:    ;* Copyright  2007 Microchip Technology Inc. All rights reserved.
                                                  14:    ;*
                                                  15:    ;* Microchip licenses to you the right to use, modify, copy and distribute
                                                  16:    ;* Software only when embedded on a Microchip microcontroller or digital
                                                  17:    ;* signal controller, which is integrated into your product or third party
                                                  18:    ;* product (pursuant to the sublicense terms in the accompanying license
                                                  19:    ;* agreement).
                                                  20:    ;*
                                                  21:    ;* You should refer to the license agreement accompanying this Software for
                                                  22:    ;* additional information regarding your rights and obligations.
                                                  23:    ;*
                                                  24:    ;* SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
                                                  25:    ;* KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
                                                  26:    ;* WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A
                                                  27:    ;* PARTICULAR PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE
                                                  28:    ;* LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY,
                                                  29:    ;* CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY
                                                  30:    ;* DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
                                                  31:    ;* INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST
                                                  32:    ;* PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
                                                  33:    ;* SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO
                                                  34:    ;* ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
                                                  35:    ;*
                                                  36:    ;* Author        Date        Comment
                                                  37:    ;*************************************************************************
                                                  38:    ;* D. Otten      2007/05/01  Version 1.0.0 - Initial Release
                                                  39:    ;* D. Otten      2007/05/15  Version 1.0.1 - First publication release
                                                  40:    ;************************************************************************/
                                                  41:    .global _ReadPMHigh
                                                  42:    .global _ReadPMLow
                                                  43:    .global _UnlockPM
                                                  44:    .global _WritePMHigh
                                                  45:    .global _WritePMHighB
                                                  46:    .global _WritePMLow
                                                  47:    .global _WritePMLowB
                                                  48:    
                                                  49:    .section .text
                                                  50:    _ReadPMHigh:
001F62  BA8010     TBLRDH [W0], W0                51:        tblrdh [W0],W0
001F64  060000     RETURN                         52:        return
                                                  53:    
                                                  54:    _ReadPMLow:
001F66  BA0010     TBLRDL [W0], W0                55:        tblrdl [W0],W0
001F68  060000     RETURN                         56:        return		
                                                  57:    	
                                                  58:    _UnlockPM:
001F6A  781F80     MOV W0, [W15++]                59:        push	W0
001F6C  FC0005     DISI #0x5                      60:        disi	#5
001F6E  200550     MOV #0x55, W0                  61:        mov		#0x55,W0
001F70  883B30     MOV W0, NVMKEY                 62:        mov		W0, NVMKEY
001F72  200AA0     MOV #0xAA, W0                  63:        mov		#0xAA, W0
001F74  883B30     MOV W0, NVMKEY                 64:        mov		W0, NVMKEY
001F76  A8E761     BSET 0x761, #7                 65:        bset	NVMCON, #15
001F78  000000     NOP                            66:        nop
001F7A  000000     NOP                            67:        nop
001F7C  AFE761     BTSC 0x761, #7                 68:        btsc	NVMCON, #15
001F7E  37FFFE     BRA 0x1F7C                     69:        bra		$-2
001F80  78004F     MOV [--W15], W0                70:        pop		W0
001F82  060000     RETURN                         71:        return	
                                                  72:    	
                                                  73:    _WritePMHigh:
001F84  BB8880     TBLWTH W0, [W1]                74:        tblwth	W0,[W1]
001F86  060000     RETURN                         75:        return
                                                  76:    
                                                  77:    _WritePMHighB:
001F88  BBC880     TBLWTH.B W0, [W1]              78:        tblwth.b	W0,[W1]
001F8A  060000     RETURN                         79:        return
                                                  80:    
                                                  81:    _WritePMLow:
001F8C  BB0880     TBLWTL W0, [W1]                82:        tblwtl	W0,[W1]
001F8E  060000     RETURN                         83:        return
                                                  84:    
                                                  85:    _WritePMLowB:
001F90  BB4880     TBLWTL.B W0, [W1]              86:        tblwtl.b	W0,[W1]
001F92  060000     RETURN                         87:        return
                                                  88:    	
                                                  89:    .end
---  D:/PIC/PIC_PS4_Host/trunk/DEE Emulation 16-bit/DEE Emulation 16-bit.c  -----------------------------
1:                 /************************************************************************
2:                  *
3:                  *   Emulating Data EEPROM for PIC24 Microcontrollers and
4:                  *           dsPIC Digital Signal Controllers
5:                  *
6:                  * This application note provides a standard interface to an efficient
7:                  * Data EEPROM emulation algorithm and uses available program memory. 
8:                  * It is designed for Microchip Technology 16-bit PIC and dsPIC J devices 
9:                  * which currently include PIC24F, PIC24H and dsPIC33 products. The
10:                 * project is initially configured to use PIC24FJ128GA010 on the Explorer
11:                 * 16 Development Board. To use different device, simply select new device
12:                 * in MPLAB, replace C30 linker script and rebuild.
13:                 * User must select number pages of program memory, erase/write limit and 
14:                 * emulated DEE size. These are defined in "DEE Emulation 16-bit.h".
15:                 * At build-time, the linker reserves pages in the next available 
16:                 * locations in program memory. Compiler error occurs if more than 255 
17:                 * DEE locations are declared, less than 2 pages of program memory is 
18:                 * reserved, greater than 65,535 erase/write cycles specified or if 
19:                 * insufficient program memory is available. 
20:                 * Call initialization routine and clear status flags before attempting 
21:                 * any other DEE operation.
22:                 *
23:                 *************************************************************************
24:                 * FileName:     DEE Emulation 16-bit.c
25:                 * Dependencies: Flash Operations.s
26:                 *               DEE Emulation 16-bit.h
27:                 * Compiler:     MPLAB C30, v3.30 or higher
28:                 * Company:      Microchip Technology, Inc.
29:                 *
30:                 * Software License Agreement
31:                 *
32:                 * Copyright  2007 Microchip Technology Inc. All rights reserved.
33:                 *
34:                 * Microchip licenses to you the right to use, modify, copy and distribute
35:                 * Software only when embedded on a Microchip microcontroller or digital
36:                 * signal controller, which is integrated into your product or third party
37:                 * product (pursuant to the sublicense terms in the accompanying license
38:                 * agreement).
39:                 *
40:                 * You should refer to the license agreement accompanying this Software for
41:                 * additional information regarding your rights and obligations.
42:                 *
43:                 * SOFTWARE AND DOCUMENTATION ARE PROVIDED AS IS WITHOUT WARRANTY OF ANY
44:                 * KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY
45:                 * WARRANTY OF MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A
46:                 * PARTICULAR PURPOSE. IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE
47:                 * LIABLE OR OBLIGATED UNDER CONTRACT, NEGLIGENCE, STRICT LIABILITY,
48:                 * CONTRIBUTION, BREACH OF WARRANTY, OR OTHER LEGAL EQUITABLE THEORY ANY
49:                 * DIRECT OR INDIRECT DAMAGES OR EXPENSES INCLUDING BUT NOT LIMITED TO ANY
50:                 * INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE OR CONSEQUENTIAL DAMAGES, LOST
51:                 * PROFITS OR LOST DATA, COST OF PROCUREMENT OF SUBSTITUTE GOODS, TECHNOLOGY,
52:                 * SERVICES, OR ANY CLAIMS BY THIRD PARTIES (INCLUDING BUT NOT LIMITED TO
53:                 * ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
54:                 *
55:                 * Author            Date        Comment
56:                 *************************************************************************
57:                 * D. Otten          2007/05/01  Version 1.0.0 - Initial Release
58:                 * D. Otten          2007/05/15  Version 1.0.1 - First publication release
59:                 * Pradeep Budagutta 2008/04/02  Version 1.1.0 - Multi EEPROM banks included
60:                 * Pradeep Budagutta 2008/05/05  Version 1.1.1 - TBLPAG page boundary problem solved
61:                 * Pradeep Budagutta 2009/08/31  Version 1.1.2 - A bug related to initial storage of value 0xFF solved
62:                 * Priyabrata Sinha  2011/01/20  Version 2.0.0 - Added dsPIC33E/PIC24E support
63:                 * Anantha R	       2011/12/20  Version 2.0.1 - modified to support proper packing on dsPIC33E/PIC24E
64:                 * Priyabrata Sinha  2012/4/19   Version 2.2.0 - removed absolute path
65:                 ************************************************************************/
66:                
67:                #if defined (__dsPIC33F__)
68:                #include <p33Fxxxx.h>
69:                #elif defined (__PIC24H__)
70:                #include <p24Hxxxx.h>
71:                #elif defined (__PIC24F__)
72:                #include <p24Fxxxx.h>
73:                #elif defined (__dsPIC33E__)
74:                #include <p33Exxxx.h>
75:                #elif defined (__PIC24E__)
76:                #include <p24Exxxx.h>
77:                #else
78:                #error Selected processor not supported
79:                #endif
80:                
81:                #include "DEE Emulation 16-bit.h"
82:                
83:                // User constant validation
84:                #if DATA_EE_BANKS == 0
85:                #error Minimum data EE banks is 1
86:                #endif
87:                
88:                #if DATA_EE_SIZE > 255
89:                #error Maximum data EE size is 255
90:                #endif
91:                
92:                #if NUM_DATA_EE_PAGES < 2
93:                #error Minimum number of program memory pages is 2
94:                #endif
95:                
96:                #if ERASE_WRITE_CYCLE_MAX > 65535
97:                #error Maximum number of erase/write cycles is 65,535
98:                #endif
99:                
100:               
101:               DATA_EE_FLAGS dataEEFlags;
102:               
103:               //Data EE info stored in PM in following format
104:               //  Status in first two locations of PM page,
105:               //  8-bit DEE Address (odd address, low byte) 16-bit DEE data (even address)
106:               #ifdef __AUXFLASH
107:               
108:               #define DEE_BANK_SIZE (NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2 * NUM_DATA_EE_PAGES)
109:               #define DEE_PAGE_SIZE (NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2)
110:               
111:               #define DEE_PAGE_TBL(bank, page) ((0x7FC000 + (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) >> 16)
112:               #define DEE_PAGE_OFFSET(bank, page) ((0x7FC000 + (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) & 0xFFFF)
113:               
114:               #else
115:               
116:               unsigned char emulationPages[DATA_EE_BANKS * NUM_DATA_EE_PAGES][NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2]
117:               __attribute__((space(psv), aligned(NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2), noload));
118:               
119:               #define DEE_BANK_SIZE (sizeof(emulationPages[0])*NUM_DATA_EE_PAGES)
120:               #define DEE_PAGE_SIZE (sizeof(emulationPages[0]))
121:               
122:               #if __C30_VERSION__ > 301
123:               #define DEE_PAGE_TBL(bank, page) ((__builtin_tbladdress(&emulationPages) + (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) >> 16)
124:               #define DEE_PAGE_OFFSET(bank, page) ((__builtin_tbladdress(&emulationPages) + (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) & 0xFFFF)
125:               #else
126:               #warning "Please upgrade your C30 compiler"
127:               #define DEE_PAGE_TBL(bank, page) ((((((unsigned long)__builtin_tblpage(&emulationPages)) << 16) + __builtin_tbloffset(&emulationPages)) + \
128:                                                    (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) >> 16)
129:               #define DEE_PAGE_OFFSET(bank, page) ((((((unsigned long)__builtin_tblpage(&emulationPages)) << 16) + __builtin_tbloffset(&emulationPages)) + \
130:                                                       (DEE_BANK_SIZE * (bank)) + (DEE_PAGE_SIZE * (page))) & 0xFFFF)
131:               #endif
132:               
133:               #endif
134:               
135:               /************************************************************************
136:               UnlockWrite
137:               
138:               This routine saves the current CPU priority and sets it the highest
139:               user level of 7. It calls an assembly routine to perform an unlock
140:               sequence and sets the WR bit in NVMCON. The WR bit is polled until it
141:               clears indicating the flash operation is complete. The previous CPU
142:               priority is restored.
143:               
144:               Parameters:		None
145:               Return:			None
146:               Side Effects:	None
147:                ************************************************************************/
148:               void UnlockWrite(void) {
008CE4  781F88     MOV W8, [W15++]
149:                   unsigned int sh_SR;
150:               
151:                   SET_AND_SAVE_CPU_IPL(sh_SR, 7);
008CE6  200428     MOV #0x42, W8
008CE8  784418     MOV.B [W8], W8
008CEA  FB8408     ZE W8, W8
008CEC  DE4445     LSR W8, #5, W8
008CEE  800291     MOV DISICNT, W1
008CF0  FC3FFF     DISI #0x3FFF
008CF2  B3CE00     MOV.B #0xE0, W0
008CF4  B76042     IOR.B SR
008CF6  880291     MOV W1, DISICNT
152:               
153:                   UnlockPM();
008CF8  07C938     RCALL _UnlockPM
154:               
155:                   RESTORE_CPU_IPL(sh_SR);
008CFA  800291     MOV DISICNT, W1
008CFC  FC3FFF     DISI #0x3FFF
008CFE  DD4445     SL W8, #5, W8
008D00  BFC042     MOV.B SR, WREG
008D02  60407F     AND.B W0, #0x1F, W0
008D04  704008     IOR.B W0, W8, W0
008D06  B7E042     MOV.B WREG, SR
008D08  880291     MOV W1, DISICNT
156:               
157:                   return;
158:               }
008D0A  78044F     MOV [--W15], W8
008D0C  060000     RETURN
159:               
160:               /************************************************************************
161:               GetPageStatus
162:               
163:               This routine returns the page status for the selected page for the
164:               selected field. The return value is right shifted into LSb position.
165:               
166:               Parameters:		Page number, Status Field
167:               Return:			Right justified bit value representing selected Status
168:                               Field value
169:               Side Effects:	None
170:                ************************************************************************/
171:               int GetPageStatus(unsigned char bank, unsigned char page, unsigned char field) {
008D0E  BE9F88     MOV.D W8, [W15++]
008D10  784402     MOV.B W2, W8
172:                   unsigned int statusOffset;
173:                   unsigned char statusByte;
174:                   unsigned char status;
175:                   int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
176:               
177:                   savedTBLPAG = TBLPAG;
008D12  200322     MOV #0x32, W2
008D14  784112     MOV.B [W2], W2
008D16  FB8482     ZE W2, W9
178:               
179:                   // Point to proper TBLPAG and offset
180:                   TBLPAG = DEE_PAGE_TBL(bank, page);
008D18  220006     MOV #0x2000, W6
008D1A  200007     MOV #0x0, W7
008D1C  FB8000     ZE W0, W0
008D1E  FB8081     ZE W1, W1
008D20  DD024B     SL W0, #11, W4
008D22  430204     ADD W6, W4, W4
008D24  4B82E0     ADDC W7, #0x0, W5
008D26  DD094A     SL W1, #10, W2
008D28  420102     ADD W4, W2, W2
008D2A  4A81E0     ADDC W5, #0x0, W3
008D2C  DE1940     LSR W3, #0, W2
008D2E  FD0100     EXCH W0, W2
008D30  B7E032     MOV.B WREG, TBLPAG
008D32  FD0100     EXCH W0, W2
181:                   statusOffset = DEE_PAGE_OFFSET(bank, page);
182:               
183:                   statusByte = (ReadPMHigh(statusOffset) & 0xFF);
008D34  400000     ADD W0, W0, W0
008D36  408080     ADD W1, W0, W1
008D38  DD08CA     SL W1, #10, W1
008D3A  408006     ADD W1, W6, W0
008D3C  07C912     RCALL _ReadPMHigh
184:               
185:                   switch (field) {
008D3E  544FF3     SUB.B W8, #0x13, [W15]
008D40  320008     BRA Z, 0x8D52
008D42  544FF4     SUB.B W8, #0x14, [W15]
008D44  320009     BRA Z, 0x8D58
008D46  EB4080     CLR.B W1
008D48  544FF2     SUB.B W8, #0x12, [W15]
008D4A  3A0008     BRA NZ, 0x8D5C
186:                       case STATUS_AVAILABLE:
187:                           status = ((statusByte & 4) >> 2);
008D4C  600064     AND W0, #0x4, W0
008D4E  DE00C2     LSR W0, #2, W1
008D50  370005     BRA 0x8D5C
188:                           break;
189:                       case STATUS_CURRENT:
190:                           status = ((statusByte & 8) >> 3);
008D52  600068     AND W0, #0x8, W0
008D54  DE00C3     LSR W0, #3, W1
008D56  370002     BRA 0x8D5C
191:                           break;
192:                       case STATUS_EXPIRED:
193:                           status = ((statusByte & 16) >> 4);
008D58  600070     AND W0, #0x10, W0
008D5A  DE00C4     LSR W0, #4, W1
194:                           break;
195:                       default:
196:                           status = 0;
197:                           break;
198:                   }
199:               
200:                   TBLPAG = savedTBLPAG;
008D5C  780009     MOV W9, W0
008D5E  B7E032     MOV.B WREG, TBLPAG
008D60  FB8001     ZE W1, W0
201:               
202:                   return (status);
203:               }
008D62  BE044F     MOV.D [--W15], W8
008D64  060000     RETURN
204:               
205:               /************************************************************************
206:               ErasePage
207:               
208:               This routine erases the selected page.
209:               
210:               Parameters:		Page number
211:               Return:			None
212:               Side Effects:	Loads NVCOM with erase opcode
213:                ************************************************************************/
214:               void ErasePage(unsigned char bank, unsigned char page) {
008D66  781F88     MOV W8, [W15++]
215:                   unsigned int pmOffset; //Current array (page) offset of selected element (PM 16-bit word)
216:                   int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
217:               
218:                   savedTBLPAG = TBLPAG;
008D68  200328     MOV #0x32, W8
008D6A  784418     MOV.B [W8], W8
219:               
220:                   // Point to proper TBLPAG and offset
221:                   TBLPAG = DEE_PAGE_TBL(bank, page);
008D6C  220006     MOV #0x2000, W6
008D6E  200007     MOV #0x0, W7
008D70  FB8000     ZE W0, W0
008D72  FB8081     ZE W1, W1
008D74  DD024B     SL W0, #11, W4
008D76  430204     ADD W6, W4, W4
008D78  4B82E0     ADDC W7, #0x0, W5
008D7A  DD094A     SL W1, #10, W2
008D7C  420102     ADD W4, W2, W2
008D7E  4A81E0     ADDC W5, #0x0, W3
008D80  DE1940     LSR W3, #0, W2
008D82  FD0100     EXCH W0, W2
008D84  B7E032     MOV.B WREG, TBLPAG
008D86  FD0100     EXCH W0, W2
222:               
223:                   NVMCON = ERASE;
008D88  240422     MOV #0x4042, W2
008D8A  883B02     MOV W2, NVMCON
224:               
225:                   pmOffset = DEE_PAGE_OFFSET(bank, page);
226:               
227:                   WritePMLow(pmOffset, pmOffset);
008D8C  400000     ADD W0, W0, W0
008D8E  408080     ADD W1, W0, W1
008D90  DD08CA     SL W1, #10, W1
008D92  408006     ADD W1, W6, W0
008D94  780080     MOV W0, W1
008D96  07C8FA     RCALL _WritePMLow
228:               
229:                   UnlockWrite();
008D98  07FFA5     RCALL UnlockWrite
230:               
231:                   TBLPAG = savedTBLPAG;
008D9A  780008     MOV W8, W0
008D9C  B7E032     MOV.B WREG, TBLPAG
232:               
233:                   return;
234:               }
008D9E  78044F     MOV [--W15], W8
008DA0  060000     RETURN
235:               
236:               /************************************************************************
237:               GetNextAvailCount
238:               
239:               This routine finds the active page and performs a backward search to find
240:               the first available location. The available location is determined by
241:               reading an LSB (odd address) with 0xFF. The returned value can be added
242:               to the first address in page to compute the available address. A return
243:               value of 0 means the entire page was filled which is an error condition.
244:               This routine can be called by the user to determine how full the current
245:               page is prior to a pack.
246:               
247:               Parameters:		None
248:               Return:			Page offset to next available location
249:               Side Effects:	None
250:                ************************************************************************/
251:               unsigned int GetNextAvailCount(unsigned char bank) {
008DA2  BE9F88     MOV.D W8, [W15++]
008DA4  BE9F8A     MOV.D W10, [W15++]
008DA6  784480     MOV.B W0, W9
252:                   int i = 0;
253:                   int currentPage; //Array row (PM page) of active DEE page
254:                   unsigned char dataEEval;
255:                   unsigned int pmOffset; //Current array (page) offset of selected element (PM 16-bit word)
256:                   int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
257:               
258:                   savedTBLPAG = TBLPAG;
008DA8  BFC032     MOV.B TBLPAG, WREG
008DAA  FB8580     ZE W0, W11
008DAC  EB0400     CLR W8
008DAE  370003     BRA 0x8DB6
259:               
260:                   // Find the active page.
261:                   for (currentPage = 0;
262:                           (currentPage < NUM_DATA_EE_PAGES) &&
008DB2  540FE2     SUB W8, #0x2, [W15]
008DB4  320006     BRA Z, 0x8DC2
008DB6  B3C132     MOV.B #0x13, W2
008DB8  784088     MOV.B W8, W1
008DBA  784009     MOV.B W9, W0
008DBC  07FFA8     RCALL GetPageStatus
008DBE  500FE1     SUB W0, #0x1, [W15]
008DC0  32FFF7     BRA Z, 0x8DB0
263:                           (GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_NOT_CURRENT);
264:                           currentPage++) {
008DB0  E80408     INC W8, W8
265:                   }
266:               
267:                   TBLPAG = DEE_PAGE_TBL(bank, currentPage);
008DC2  220006     MOV #0x2000, W6
008DC4  200007     MOV #0x0, W7
008DC6  FB8209     ZE W9, W4
008DC8  DD214B     SL W4, #11, W2
008DCA  430102     ADD W6, W2, W2
008DCC  4B81E0     ADDC W7, #0x0, W3
008DCE  DD404A     SL W8, #10, W0
008DD0  410000     ADD W2, W0, W0
008DD2  4980E0     ADDC W3, #0x0, W1
008DD4  DE0840     LSR W1, #0, W0
008DD6  B7E032     MOV.B WREG, TBLPAG
268:                   pmOffset = DEE_PAGE_OFFSET(bank, currentPage);
008DD8  420204     ADD W4, W4, W4
008DDA  440204     ADD W8, W4, W4
008DDC  DD224A     SL W4, #10, W4
008DDE  420406     ADD W4, W6, W8
008DE0  EB0480     CLR W9
008DE2  20400A     MOV #0x400, W10
269:               
270:                   do {
271:                       i += 2;
008DE4  E88489     INC2 W9, W9
272:                       pmOffset += 2;
008DE6  E88408     INC2 W8, W8
273:               
274:                       dataEEval = (ReadPMHigh(pmOffset) & 0xFF);
008DE8  780008     MOV W8, W0
008DEA  07C8BB     RCALL _ReadPMHigh
275:                   }    while ((i < NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2) && (dataEEval != 0xFF));
008DEC  548F8A     SUB W9, W10, [W15]
008DEE  3A0002     BRA NZ, 0x8DF4
008DF0  EB0480     CLR W9
008DF2  370002     BRA 0x8DF8
008DF4  404FE1     ADD.B W0, #0x1, [W15]
008DF6  3AFFF6     BRA NZ, 0x8DE4
276:               
277:                   if (i == NUMBER_OF_INSTRUCTIONS_IN_PAGE * 2) {
278:                       i = 0; //Error - No available locations
279:                   }
280:               
281:                   TBLPAG = savedTBLPAG;
008DF8  78000B     MOV W11, W0
008DFA  B7E032     MOV.B WREG, TBLPAG
282:               
283:                   return (i);
284:               }
008DFC  780009     MOV W9, W0
008DFE  BE054F     MOV.D [--W15], W10
008E00  BE044F     MOV.D [--W15], W8
008E02  060000     RETURN
285:               
286:               /************************************************************************
287:               PackEE
288:               
289:               This routine finds the active page and an unexpired packed page. The most
290:               recent data EEPROM values are located for each address using ReadEE
291:               function and written into write latches. Page status is read from active
292:               page and erase/write count is incremented if page 0 is packed. After all
293:               information is programmed and verified, the current page is erased. The
294:               packed page becomes the active page. This function can be called at any-
295:               time by the user to schedule the CPU stall.
296:               
297:               Parameters:		None
298:               Return:			Status value (0 for pass)
299:               Side Effects:	Generates CPU stall during program/erase operations and
300:                               overwrites program memory write latches. Data EE flags
301:                               may be updated
302:                ************************************************************************/
303:               int PackEE(unsigned char bank) {
008E04  B0022F     ADD #0x22, W15
008E06  BE9F88     MOV.D W8, [W15++]
008E08  BE9F8A     MOV.D W10, [W15++]
008E0A  BE9F8C     MOV.D W12, [W15++]
008E0C  781F8E     MOV W14, [W15++]
008E0E  784700     MOV.B W0, W14
304:                   int currentPage; //Array row (PM page) of active DEE page
305:                   int packedPage; //Array row (PM page) of packed page
306:                   int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
307:                   int currentOffset; //Current page offset
308:                   int packedOffset; //Packed page offset
309:                   int i;
310:                   unsigned char latchAddr;
311:                   unsigned int latchData;
312:                   unsigned char dataEEFlags_sh;
313:               
314:                   savedTBLPAG = TBLPAG;
008E10  BFC032     MOV.B TBLPAG, WREG
008E12  FB8000     ZE W0, W0
008E14  9FAFB0     MOV W0, [W15-42]
008E16  EB0480     CLR W9
008E18  370003     BRA 0x8E20
315:               
316:                   // Find the active page.
317:                   for (currentPage = 0;
318:                           (currentPage < NUM_DATA_EE_PAGES) &&
008E1C  548FE2     SUB W9, #0x2, [W15]
008E1E  320007     BRA Z, 0x8E2E
008E20  B3C132     MOV.B #0x13, W2
008E22  784089     MOV.B W9, W1
008E24  78400E     MOV.B W14, W0
008E26  07FF73     RCALL GetPageStatus
008E28  500FE1     SUB W0, #0x1, [W15]
008E2A  32FFF7     BRA Z, 0x8E1A
008E2C  37000F     BRA 0x8E4C
319:                           (GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_NOT_CURRENT);
320:                           currentPage++) {
008E1A  E80489     INC W9, W9
321:                   }
322:               
323:               
324:                   if (currentPage == NUM_DATA_EE_PAGES) {
325:                       TBLPAG = savedTBLPAG;
008E2E  97D06F     MOV.B [W15-42], W0
008E30  B7E032     MOV.B WREG, TBLPAG
326:                       SetPagePackBeforeInit(1);
008E32  A86F2A     BSET dataEEFlags, #3
008E34  200030     MOV #0x3, W0
008E36  3700EB     BRA 0x900E
327:                       return (3); // Error - no active page
328:                   } else {
329:                       // Find the next unexpired page to use
330:                       packedPage = currentPage + 1;
008E4C  E80509     INC W9, W10
331:                       if (packedPage == NUM_DATA_EE_PAGES) {
008E4E  550FE2     SUB W10, #0x2, [W15]
008E50  3A0008     BRA NZ, 0x8E62
008E52  EB0500     CLR W10
008E54  370006     BRA 0x8E62
332:                           packedPage = 0;
333:                       }
334:                       while (GetPageStatus(bank, packedPage, STATUS_EXPIRED) == PAGE_EXPIRED) {
008E62  B3C142     MOV.B #0x14, W2
008E64  78408A     MOV.B W10, W1
008E66  78400E     MOV.B W14, W0
008E68  07FF52     RCALL GetPageStatus
008E6A  E00000     CP0 W0
008E6C  32FFF4     BRA Z, 0x8E56
335:                           packedPage++;
008E56  E8050A     INC W10, W10
336:                           if (packedPage == NUM_DATA_EE_PAGES) {
008E58  550FE2     SUB W10, #0x2, [W15]
008E5A  3A0001     BRA NZ, 0x8E5E
008E5C  EB0500     CLR W10
337:                               packedPage = 0;
338:                           }
339:                           if (packedPage == currentPage) {
008E5E  550F89     SUB W10, W9, [W15]
008E60  32FFEB     BRA Z, 0x8E38
340:                               TBLPAG = savedTBLPAG;
008E38  97D06F     MOV.B [W15-42], W0
008E3A  B7E032     MOV.B WREG, TBLPAG
341:                               SetPageExpiredPage(1);
008E3C  A82F2A     BSET dataEEFlags, #1
008E3E  200010     MOV #0x1, W0
008E40  3700E6     BRA 0x900E
342:                               return (1); // Error - all pages expired
343:                           }
344:                       }
345:                   }
346:               
347:                   // Point to first location in packed page
348:                   TBLPAG = DEE_PAGE_TBL(bank, packedPage);
008E6E  220004     MOV #0x2000, W4
008E70  200005     MOV #0x0, W5
008E72  FB810E     ZE W14, W2
008E74  DD104B     SL W2, #11, W0
008E76  B80361     MUL.UU W0, #1, W6
008E78  9FB7A6     MOV W6, [W15-28]
008E7A  9FB7B7     MOV W7, [W15-26]
008E7C  DD504A     SL W10, #10, W0
008E7E  B80361     MUL.UU W0, #1, W6
008E80  9FB786     MOV W6, [W15-32]
008E82  9FB797     MOV W7, [W15-30]
008E84  97B32F     MOV [W15-28], W6
008E86  97B3BF     MOV [W15-26], W7
008E88  430004     ADD W6, W4, W0
008E8A  4B8085     ADDC W7, W5, W1
008E8C  97B30F     MOV [W15-32], W6
008E8E  97B39F     MOV [W15-30], W7
008E90  430000     ADD W6, W0, W0
008E92  4B8081     ADDC W7, W1, W1
008E94  DE0840     LSR W1, #0, W0
008E96  B7E032     MOV.B WREG, TBLPAG
349:                   packedOffset = DEE_PAGE_OFFSET(bank, packedPage);
008E98  410582     ADD W2, W2, W11
008E9A  45000B     ADD W10, W11, W0
008E9C  DD004A     SL W0, #10, W0
008E9E  9FAFF0     MOV W0, [W15-34]
008EA0  400404     ADD W0, W4, W8
350:               
351:                   if (GetNextAvailCount(bank)) {
008EA2  78400E     MOV.B W14, W0
008EA4  07FF7E     RCALL GetNextAvailCount
008EA6  E00000     CP0 W0
008EA8  320001     BRA Z, 0x8EAC
352:                       SetPagePackBeforePageFull(1); // Pack called before the page was full
008EAA  A84F2A     BSET dataEEFlags, #2
353:                   }
354:               
355:                   dataEEFlags_sh = dataEEFlags.val;
008EAC  BFCF2A     MOV.B dataEEFlags, WREG
008EAE  9FD7A0     MOV.B W0, [W15-46]
356:                   SetaddrNotFound(0); // Initialize flag
008EB0  A90F2A     BCLR dataEEFlags, #0
357:                   i = 0;
358:                   NVMCON = PROGRAM_ROW;
008EB2  240010     MOV #0x4001, W0
008EB4  883B00     MOV W0, NVMCON
359:               
360:                   WritePMLow(0xFFFF, packedOffset);
008EB6  780088     MOV W8, W1
008EB8  EB8000     SETM W0
008EBA  07C868     RCALL _WritePMLow
361:                   WritePMHigh(0xFF, packedOffset);
008EBC  780088     MOV W8, W1
008EBE  200FF0     MOV #0xFF, W0
008EC0  07C861     RCALL _WritePMHigh
362:                   packedOffset += 2;
008EC2  E88408     INC2 W8, W8
363:               
364:                   latchAddr = 0;
365:                   i++;
366:               
367:                   do {
368:                       while ((latchAddr != DATA_EE_SIZE) && (i < NUMBER_OF_INSTRUCTIONS_IN_ROW)) {
008F42  2003F0     MOV #0x3F, W0
008F44  560F80     SUB W12, W0, [W15]
008F46  3C0002     BRA GT, 0x8F4C
008F48  37FFDD     BRA 0x8F04
008F4A  EBC680     SETM.B W13
369:                           latchData = DataEERead((255 * bank) + latchAddr);
008EC4  FB800E     ZE W14, W0
008EC6  200FF2     MOV #0xFF, W2
008EC8  B98002     MUL.SS W0, W2, W0
008ECA  9FAFE0     MOV W0, [W15-36]
008ECC  EB4680     CLR.B W13
008ECE  20001C     MOV #0x1, W12
008ED0  220002     MOV #0x2000, W2
008ED2  200003     MOV #0x0, W3
008ED4  9FAFC2     MOV W2, [W15-40]
008ED6  9FAFD3     MOV W3, [W15-38]
008ED8  97B22F     MOV [W15-28], W4
008EDA  97B2BF     MOV [W15-26], W5
008EDC  410204     ADD W2, W4, W4
008EDE  498285     ADDC W3, W5, W5
008EE0  9FB7C4     MOV W4, [W15-24]
008EE2  9FB7D5     MOV W5, [W15-22]
008EE4  97B30F     MOV [W15-32], W6
008EE6  97B39F     MOV [W15-30], W7
008EE8  420006     ADD W4, W6, W0
008EEA  4A8087     ADDC W5, W7, W1
008EEC  DE0840     LSR W1, #0, W0
008EEE  200001     MOV #0x0, W1
008EF0  9FB7E0     MOV W0, [W15-20]
008EF2  9FB7F1     MOV W1, [W15-18]
008EF4  97ABFF     MOV [W15-34], W7
008EF6  438382     ADD W7, W2, W7
008EF8  9FBF87     MOV W7, [W15-16]
008EFA  458009     ADD W11, W9, W0
008EFC  DD004A     SL W0, #10, W0
008EFE  97A8CF     MOV [W15-40], W1
008F00  400001     ADD W0, W1, W0
008F02  9FAFA0     MOV W0, [W15-44]
008F04  FB858D     ZE W13, W11
008F06  97A96F     MOV [W15-36], W2
008F08  41000B     ADD W2, W11, W0
008F0A  0700F8     RCALL DataEERead
370:                           if (GetaddrNotFound()) //if address is unwritten, skip to next address
008F0C  AB0F2A     BTST dataEEFlags, #0
008F0E  320002     BRA Z, 0x8F14
371:                           {
372:                               SetaddrNotFound(0);
008F10  A90F2A     BCLR dataEEFlags, #0
008F12  370007     BRA 0x8F22
373:                           } else {
374:                               WritePMLow(latchData, packedOffset);
008F14  780088     MOV W8, W1
008F16  07C83A     RCALL _WritePMLow
375:                               WritePMHigh(latchAddr, packedOffset);
008F18  780088     MOV W8, W1
008F1A  78000B     MOV W11, W0
008F1C  07C833     RCALL _WritePMHigh
376:                               packedOffset += 2;
008F1E  E88408     INC2 W8, W8
377:                               i++;
008F20  E8060C     INC W12, W12
378:                           }
379:                           latchAddr++;
008F22  E8468D     INC.B W13, W13
380:                           while ((latchAddr == DATA_EE_SIZE) && (i < NUMBER_OF_INSTRUCTIONS_IN_ROW)) {
008F24  46CFE1     ADD.B W13, #0x1, [W15]
008F26  3A000D     BRA NZ, 0x8F42
008F28  37006E     BRA 0x9006
008F3A  200400     MOV #0x40, W0
008F3C  560F80     SUB W12, W0, [W15]
008F3E  320005     BRA Z, 0x8F4A
008F40  37FFF4     BRA 0x8F2A
009006  2003F0     MOV #0x3F, W0
009008  560F80     SUB W12, W0, [W15]
00900A  3CFF9F     BRA GT, 0x8F4A
00900C  37FF8E     BRA 0x8F2A
381:                               WritePMLow(0xFFFF, packedOffset);
008F2A  780088     MOV W8, W1
008F2C  EB8000     SETM W0
008F2E  07C82E     RCALL _WritePMLow
382:                               WritePMHigh(0xFF, packedOffset);
008F30  780088     MOV W8, W1
008F32  200FF0     MOV #0xFF, W0
008F34  07C827     RCALL _WritePMHigh
383:                               packedOffset += 2;
008F36  E88408     INC2 W8, W8
384:                               i++;
008F38  E8060C     INC W12, W12
385:                           }
386:                       }
387:                       UnlockWrite();
008F4C  07FECB     RCALL UnlockWrite
388:                       i = 0;
389:                   }    while (latchAddr != DATA_EE_SIZE);
008F4E  46CFE1     ADD.B W13, #0x1, [W15]
008F50  320002     BRA Z, 0x8F56
008F52  EB0600     CLR W12
008F54  37FFD7     BRA 0x8F04
390:               
391:                   dataEEFlags.val = dataEEFlags_sh; //Restore status flags
008F56  97D02F     MOV.B [W15-46], W0
008F58  B7EF2A     MOV.B WREG, dataEEFlags
392:               
393:                   //Verify data was written correctly into packed page
394:               
395:                   // Point to first location after status
396:                   TBLPAG = DEE_PAGE_TBL(bank, packedPage);
008F5A  97E84F     MOV.B [W15-20], W0
008F5C  B7E032     MOV.B WREG, TBLPAG
397:                   packedOffset = DEE_PAGE_OFFSET(bank, packedPage) + 2;
008F5E  97B88F     MOV [W15-16], W1
008F60  E88401     INC2 W1, W8
398:               
399:                   latchAddr = ReadPMHigh(packedOffset++);
008F62  780008     MOV W8, W0
008F64  07C7FE     RCALL _ReadPMHigh
008F66  784580     MOV.B W0, W11
400:                   latchData = ReadPMLow(packedOffset++);
008F68  E88608     INC2 W8, W12
008F6A  97B90F     MOV [W15-16], W2
008F6C  410063     ADD W2, #0x3, W0
008F6E  07C7FB     RCALL _ReadPMLow
008F70  780400     MOV W0, W8
401:               
402:                   while (latchAddr != 0xFF) {
008F72  45CFE1     ADD.B W11, #0x1, [W15]
008F74  320010     BRA Z, 0x8F96
008F92  45CFE1     ADD.B W11, #0x1, [W15]
008F94  3AFFF0     BRA NZ, 0x8F76
403:                       if (DataEERead((255 * bank) + latchAddr) != latchData) {
008F76  FB800B     ZE W11, W0
008F78  97A9EF     MOV [W15-36], W3
008F7A  400003     ADD W0, W3, W0
008F7C  0700BF     RCALL DataEERead
008F7E  540F80     SUB W8, W0, [W15]
008F80  3AFF60     BRA NZ, 0x8E42
404:                           TBLPAG = savedTBLPAG;
008E42  97D06F     MOV.B [W15-42], W0
008E44  B7E032     MOV.B WREG, TBLPAG
405:                           SetPageWriteError(1);
008E46  A8EF2A     BSET dataEEFlags, #7
008E48  200070     MOV #0x7, W0
008E4A  3700E1     BRA 0x900E
406:                           return (7); //Error - data does not match
008F82  E8040C     INC W12, W8
407:                       }
408:                       latchAddr = ReadPMHigh(packedOffset++);
008F84  78000C     MOV W12, W0
008F86  07C7ED     RCALL _ReadPMHigh
008F88  784580     MOV.B W0, W11
409:                       latchData = ReadPMLow(packedOffset++);
008F8A  E8860C     INC2 W12, W12
008F8C  780008     MOV W8, W0
008F8E  07C7EB     RCALL _ReadPMLow
008F90  780400     MOV W0, W8
410:                   }
411:               
412:               
413:                   //Program page status
414:                   currentOffset = DEE_PAGE_OFFSET(bank, currentPage);
415:                   packedOffset = DEE_PAGE_OFFSET(bank, packedPage);
008F96  97AA7F     MOV [W15-34], W4
008F98  97AACF     MOV [W15-40], W5
008F9A  420605     ADD W4, W5, W12
416:               
417:                   // Point to proper TBLPAG
418:                   TBLPAG = DEE_PAGE_TBL(bank, currentPage);
008F9C  DD484A     SL W9, #10, W0
008F9E  97B34F     MOV [W15-24], W6
008FA0  97B3DF     MOV [W15-22], W7
008FA2  430000     ADD W6, W0, W0
008FA4  4B80E0     ADDC W7, #0x0, W1
008FA6  DE0840     LSR W1, #0, W0
008FA8  B7E032     MOV.B WREG, TBLPAG
419:                   latchData = ReadPMLow(currentOffset);
008FAA  97A82F     MOV [W15-44], W0
008FAC  07C7DC     RCALL _ReadPMLow
008FAE  780580     MOV W0, W11
420:                   latchAddr = ReadPMHigh(currentOffset);
008FB0  97A82F     MOV [W15-44], W0
008FB2  07C7D7     RCALL _ReadPMHigh
008FB4  784080     MOV.B W0, W1
421:                   if (packedPage == 0) {
008FB6  E0000A     CP0 W10
008FB8  3A0001     BRA NZ, 0x8FBC
422:                       latchData++; //Increment E/W counter
008FBA  E8058B     INC W11, W11
423:                   }
424:               
425:                   if (latchData >= ERASE_WRITE_CYCLE_MAX - 1) {
008FBC  558FE3     SUB W11, #0x3, [W15]
008FBE  360002     BRA LEU, 0x8FC4
426:                       SetPageExpiredPage(1);
008FC0  A82F2A     BSET dataEEFlags, #1
427:                       latchAddr &= 0b11101111;
008FC2  A14401     BCLR.B W1, #4
428:                   }
429:               
430:                   // Point to proper TBLPAG
431:                   TBLPAG = DEE_PAGE_TBL(bank, packedPage);
008FC4  97E84F     MOV.B [W15-20], W0
008FC6  B7E032     MOV.B WREG, TBLPAG
432:                   WritePMHigh(latchAddr, packedOffset);
008FC8  FB8401     ZE W1, W8
008FCA  78008C     MOV W12, W1
008FCC  780008     MOV W8, W0
008FCE  07C7DA     RCALL _WritePMHigh
433:                   WritePMLow(latchData, packedOffset);
008FD0  78008C     MOV W12, W1
008FD2  78000B     MOV W11, W0
008FD4  07C7DB     RCALL _WritePMLow
434:               
435:                   NVMCON = PROGRAM_WORD;
008FD6  240030     MOV #0x4003, W0
008FD8  883B00     MOV W0, NVMCON
436:                   UnlockWrite();
008FDA  07FE84     RCALL UnlockWrite
437:               
438:                   if ((latchAddr != ReadPMHigh(packedOffset)) ||
008FDC  78000C     MOV W12, W0
008FDE  07C7C1     RCALL _ReadPMHigh
008FE0  540F80     SUB W8, W0, [W15]
008FE2  3A0004     BRA NZ, 0x8FEC
008FE4  78000C     MOV W12, W0
008FE6  07C7BF     RCALL _ReadPMLow
008FE8  558F80     SUB W11, W0, [W15]
008FEA  320005     BRA Z, 0x8FF6
439:                           (latchData != ReadPMLow(packedOffset))) {
440:                       TBLPAG = savedTBLPAG;
008FEC  97D06F     MOV.B [W15-42], W0
008FEE  B7E032     MOV.B WREG, TBLPAG
441:                       SetPageWriteError(1);
008FF0  A8EF2A     BSET dataEEFlags, #7
008FF2  200070     MOV #0x7, W0
008FF4  37000C     BRA 0x900E
442:                       return (7);
443:                   }
444:               
445:                   //Erase active page
446:                   ErasePage(bank, currentPage);
008FF6  784089     MOV.B W9, W1
008FF8  78400E     MOV.B W14, W0
008FFA  07FEB5     RCALL ErasePage
447:               
448:                   TBLPAG = savedTBLPAG;
008FFC  97D06F     MOV.B [W15-42], W0
008FFE  B7E032     MOV.B WREG, TBLPAG
449:                   return (GetPageExpiredPage());
009000  D50F2A     LSR dataEEFlags, WREG
009002  600061     AND W0, #0x1, W0
009004  370004     BRA 0x900E
450:               }
00900E  78074F     MOV [--W15], W14
009010  BE064F     MOV.D [--W15], W12
009012  BE054F     MOV.D [--W15], W10
009014  BE044F     MOV.D [--W15], W8
009016  B1022F     SUB #0x22, W15
009018  060000     RETURN
451:               
452:               /************************************************************************
453:               DataEEInit
454:               
455:               This routine finds an unexpired page to become an active page. It then
456:               counts the number of active pages. If no active pages are found, the
457:               first unexpired page is initialized for emulation. If one active page is
458:               found, it is assumes a reset occurred and the function does nothing. If
459:               two active pages are found, it is assumes a reset occurred during a pack.
460:               The second page is erased and a pack is called. If three, an error code
461:               is returned as the allocated memory is assumed to be corrupted. This
462:               function must be called prior to any other operation.
463:               
464:               Parameters:		None
465:               Return:			Status value (0 for pass)
466:               Side Effects:	Data EE flags may be updated.
467:                ************************************************************************/
468:               unsigned char DataEEInit(void) {
00901A  BE9F88     MOV.D W8, [W15++]
00901C  781F8A     MOV W10, [W15++]
469:                   unsigned char pageCnt;
470:                   unsigned char erasePage;
471:                   unsigned int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
472:                   unsigned int currentPage;
473:                   unsigned int statusOffset;
474:                   int packedPage; //Array row (PM page) of packed page
475:                   unsigned char bank;
476:               
477:                   savedTBLPAG = TBLPAG;
00901E  BFC032     MOV.B TBLPAG, WREG
009020  FB8500     ZE W0, W10
478:               
479:                   // Point the table page pointer to the emulation pages
480:                   TBLPAG = DEE_PAGE_TBL(0, 0);
009022  220000     MOV #0x2000, W0
009024  200001     MOV #0x0, W1
009026  DE0840     LSR W1, #0, W0
009028  B7E032     MOV.B WREG, TBLPAG
00902A  EB0400     CLR W8
00902C  370003     BRA 0x9034
481:               
482:                   for (bank = 0; bank < DATA_EE_BANKS; bank++) {
483:                       pageCnt = 0;
484:                       erasePage = 0;
485:                       packedPage = 0;
486:               
487:                       // Find unexpired page
488:                       for (currentPage = 0;
489:                               (currentPage < NUM_DATA_EE_PAGES) &&
009030  540FE2     SUB W8, #0x2, [W15]
009032  320007     BRA Z, 0x9042
009034  B3C142     MOV.B #0x14, W2
009036  784088     MOV.B W8, W1
009038  EB4000     CLR.B W0
00903A  07FE69     RCALL GetPageStatus
00903C  E00000     CP0 W0
00903E  32FFF7     BRA Z, 0x902E
009040  370005     BRA 0x904C
490:                               (GetPageStatus(bank, currentPage, STATUS_EXPIRED) == PAGE_EXPIRED);
491:                               currentPage++) {
00902E  E80408     INC W8, W8
492:                       }
493:               
494:                       if (currentPage == NUM_DATA_EE_PAGES) {
495:                           TBLPAG = savedTBLPAG;
009042  78000A     MOV W10, W0
009044  B7E032     MOV.B WREG, TBLPAG
496:                           SetPageExpiredPage(1);
009046  A82F2A     BSET dataEEFlags, #1
009048  200010     MOV #0x1, W0
00904A  370055     BRA 0x90F6
497:                           return (1); // Error - All pages expired
00904C  EB4480     CLR.B W9
00904E  EB0400     CLR W8
498:                       }
499:               
500:                       // Count active page(s).
501:                       for (currentPage = 0; currentPage < NUM_DATA_EE_PAGES; currentPage++) {
00905E  E80408     INC W8, W8
009060  540FE2     SUB W8, #0x2, [W15]
009062  3AFFF6     BRA NZ, 0x9050
502:                           if (GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_CURRENT) {
009050  B3C132     MOV.B #0x13, W2
009052  784088     MOV.B W8, W1
009054  EB4000     CLR.B W0
009056  07FE5B     RCALL GetPageStatus
009058  E00000     CP0 W0
00905A  3A0001     BRA NZ, 0x905E
503:                               pageCnt++;
00905C  E84489     INC.B W9, W9
504:                           }
505:                       }
506:               
507:                       //If no active pages found, initialize page 0
508:                       if (pageCnt == 0) {
009064  E00409     CP0.B W9
009066  3A0015     BRA NZ, 0x9092
509:                           ErasePage(bank, 0);
009068  784089     MOV.B W9, W1
00906A  784009     MOV.B W9, W0
00906C  07FE7C     RCALL ErasePage
510:               
511:                           // Point to proper TBLPAG and offset
512:                           TBLPAG = DEE_PAGE_TBL(bank, 0);
00906E  220008     MOV #0x2000, W8
009070  200009     MOV #0x0, W9
009072  DE4840     LSR W9, #0, W0
009074  200001     MOV #0x0, W1
009076  B7E032     MOV.B WREG, TBLPAG
513:                           statusOffset = DEE_PAGE_OFFSET(bank, 0);
514:               
515:                           NVMCON = PROGRAM_WORD;
009078  240030     MOV #0x4003, W0
00907A  883B00     MOV W0, NVMCON
516:               
517:                           WritePMLow(0, statusOffset); //New page: unavailable, active, reset count
00907C  780088     MOV W8, W1
00907E  EB0000     CLR W0
009080  07C785     RCALL _WritePMLow
518:                           WritePMHigh(0xF3, statusOffset);
009082  780088     MOV W8, W1
009084  200F30     MOV #0xF3, W0
009086  07C77E     RCALL _WritePMHigh
519:                           UnlockWrite();
009088  07FE2D     RCALL UnlockWrite
520:               
521:                           TBLPAG = savedTBLPAG;
00908A  78000A     MOV W10, W0
00908C  B7E032     MOV.B WREG, TBLPAG
00908E  EB0000     CLR W0
009090  370032     BRA 0x90F6
522:                           continue;
523:                       }            //If one active page, do nothing
524:                       else if (pageCnt == 1) {
009092  54CFE1     SUB.B W9, #0x1, [W15]
009094  3A0004     BRA NZ, 0x909E
525:                           TBLPAG = savedTBLPAG;
009096  78000A     MOV W10, W0
009098  B7E032     MOV.B WREG, TBLPAG
00909A  EB0000     CLR W0
00909C  37002C     BRA 0x90F6
526:                           continue;
527:                       }            //If two active pages, erase second and repack first
528:                       else if (pageCnt == 2) {
00909E  54CFE2     SUB.B W9, #0x2, [W15]
0090A0  3A0026     BRA NZ, 0x90EE
529:                           if ((GetPageStatus(bank, NUM_DATA_EE_PAGES - 1, STATUS_CURRENT) == PAGE_CURRENT) &&
0090A2  B3C132     MOV.B #0x13, W2
0090A4  B3C011     MOV.B #0x1, W1
0090A6  EB4000     CLR.B W0
0090A8  07FE32     RCALL GetPageStatus
0090AA  E00000     CP0 W0
0090AC  3A0005     BRA NZ, 0x90B8
0090AE  B3C132     MOV.B #0x13, W2
0090B0  784080     MOV.B W0, W1
0090B2  07FE2D     RCALL GetPageStatus
0090B4  E00000     CP0 W0
0090B6  32000F     BRA Z, 0x90D6
0090B8  EB0400     CLR W8
0090BA  370001     BRA 0x90BE
530:                                   (GetPageStatus(bank, 0, STATUS_CURRENT) == PAGE_CURRENT)) {
531:                               currentPage = NUM_DATA_EE_PAGES - 1;
532:                               erasePage = 0;
533:                           } else {
534:                               currentPage = 0;
535:                               while ((GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_NOT_CURRENT) &&
0090C0  B3C132     MOV.B #0x13, W2
0090C2  784088     MOV.B W8, W1
0090C4  EB4000     CLR.B W0
0090C6  07FE23     RCALL GetPageStatus
0090C8  500FE1     SUB W0, #0x1, [W15]
0090CA  3A0002     BRA NZ, 0x90D0
0090CC  540FE2     SUB W8, #0x2, [W15]
0090CE  3AFFF6     BRA NZ, 0x90BC
536:                                       (currentPage < NUM_DATA_EE_PAGES)) {
537:                                   currentPage++;
0090BC  E80408     INC W8, W8
0090BE  784488     MOV.B W8, W9
538:                               }
539:                               erasePage = currentPage + 1;
0090D0  E84089     INC.B W9, W1
540:                               if (erasePage == NUM_DATA_EE_PAGES) {
0090D2  50CFE2     SUB.B W1, #0x2, [W15]
0090D4  3A0001     BRA NZ, 0x90D8
0090D6  EB4080     CLR.B W1
541:                                   erasePage = 0;
542:                               }
543:                           }
544:                           ErasePage(bank, erasePage);
0090D8  EB4000     CLR.B W0
0090DA  07FE45     RCALL ErasePage
545:               
546:                           if (!GetNextAvailCount(bank)) {
0090DC  EB4000     CLR.B W0
0090DE  07FE61     RCALL GetNextAvailCount
0090E0  E00000     CP0 W0
0090E2  3A0001     BRA NZ, 0x90E6
547:                               PackEE(bank);
0090E4  07FE8F     RCALL PackEE
548:                           }
549:                           TBLPAG = savedTBLPAG;
0090E6  78000A     MOV W10, W0
0090E8  B7E032     MOV.B WREG, TBLPAG
0090EA  EB0000     CLR W0
0090EC  370004     BRA 0x90F6
550:                           continue;
551:                       } else {
552:                           TBLPAG = savedTBLPAG;
0090EE  78000A     MOV W10, W0
0090F0  B7E032     MOV.B WREG, TBLPAG
553:                           SetPageCorruptStatus(1);
0090F2  A8CF2A     BSET dataEEFlags, #6
0090F4  200060     MOV #0x6, W0
554:                           return (6);
555:                       }
556:                   }
557:                   return (0);
558:               }
0090F6  78054F     MOV [--W15], W10
0090F8  BE044F     MOV.D [--W15], W8
0090FA  060000     RETURN
559:               
560:               /************************************************************************
561:               DataEERead
562:               
563:               This routine verifies the address is valid. If not, the Illegal Address
564:               flag is set and 0xFFFF is returned. It then finds the active page. If an
565:               active page can not be found, the Page Corrupt status bit is set and
566:               0xFFFF is returned. A reverse search of the active page attempts to find
567:               the matching address in the program memory MSB (odd address). If a match
568:               is found, the corresponding data EEPROM data (even address) is returned,
569:               otherwise 0xFFFF is returned. This function can be called by the user.
570:               
571:               Parameters:		Data EE address
572:               Return:			Data EE data or 0xFFFF if address not found
573:               Side Effects:	Data EE flags may be updated.
574:                ************************************************************************/
575:               unsigned int DataEERead(unsigned int addr) {
0090FC  BE9F88     MOV.D W8, [W15++]
0090FE  BE9F8A     MOV.D W10, [W15++]
009100  780400     MOV W0, W8
576:                   unsigned int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
577:                   unsigned int currentPage;
578:                   unsigned int pmOffset; //Current array (page) offset of selected element (PM 16-bit word)
579:                   unsigned int latch;
580:                   unsigned int i;
581:                   unsigned char bank;
582:               
583:                   if (addr >= DATA_EE_TOTAL_SIZE) {
009102  200FE0     MOV #0xFE, W0
009104  540F80     SUB W8, W0, [W15]
009106  360003     BRA LEU, 0x910E
584:                       SetPageIllegalAddress(1);
009108  A8AF2A     BSET dataEEFlags, #5
00910A  EB8000     SETM W0
00910C  37003F     BRA 0x918C
585:                       return (0xFFFF);
586:                   }
587:               
588:                   bank = addr / DATA_EE_SIZE;
00910E  200FF2     MOV #0xFF, W2
009110  090011     REPEAT #0x11
009112  D88402     DIV.UW W8, W2
009114  780100     MOV W0, W2
009116  784502     MOV.B W2, W10
589:               
590:                   savedTBLPAG = TBLPAG;
009118  BFC032     MOV.B TBLPAG, WREG
00911A  FB8580     ZE W0, W11
00911C  EB0480     CLR W9
00911E  370003     BRA 0x9126
591:               
592:                   // Find the active page.
593:                   for (currentPage = 0;
594:                           (currentPage < NUM_DATA_EE_PAGES) &&
009122  548FE2     SUB W9, #0x2, [W15]
009124  320007     BRA Z, 0x9134
009126  B3C132     MOV.B #0x13, W2
009128  784089     MOV.B W9, W1
00912A  78400A     MOV.B W10, W0
00912C  07FDF0     RCALL GetPageStatus
00912E  500FE1     SUB W0, #0x1, [W15]
009130  32FFF7     BRA Z, 0x9120
009132  370005     BRA 0x913E
595:                           (GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_NOT_CURRENT);
596:                           currentPage++) {
009120  E80489     INC W9, W9
597:                   }
598:               
599:                   if (currentPage == NUM_DATA_EE_PAGES) {
600:                       TBLPAG = savedTBLPAG;
009134  78000B     MOV W11, W0
009136  B7E032     MOV.B WREG, TBLPAG
601:                       SetPageCorruptStatus(1);
009138  A8CF2A     BSET dataEEFlags, #6
00913A  EB8000     SETM W0
00913C  370027     BRA 0x918C
602:                       return (0xFFFF); // Error - no active page
603:                   }
604:               
605:                   // Point to proper TBLPAG and offset
606:                   TBLPAG = DEE_PAGE_TBL(bank, currentPage);
00913E  220004     MOV #0x2000, W4
009140  200005     MOV #0x0, W5
009142  DD514B     SL W10, #11, W2
009144  DD49CA     SL W9, #10, W3
009146  420002     ADD W4, W2, W0
009148  4A80E0     ADDC W5, #0x0, W1
00914A  400003     ADD W0, W3, W0
00914C  4880E0     ADDC W1, #0x0, W1
00914E  DE0840     LSR W1, #0, W0
009150  B7E032     MOV.B WREG, TBLPAG
607:                   pmOffset = DEE_PAGE_OFFSET(bank, (currentPage + 1)) - 2;
009152  410104     ADD W2, W4, W2
009154  418182     ADD W3, W2, W3
009156  203FE1     MOV #0x3FE, W1
009158  408083     ADD W1, W3, W1
608:               
609:                   i = NUMBER_OF_INSTRUCTIONS_IN_PAGE;
610:               
611:                   do {
612:                       latch = ReadPMHigh(pmOffset);
009168  780001     MOV W1, W0
00916A  07C6FB     RCALL _ReadPMHigh
613:                       pmOffset -= 2;
00916C  E98088     DEC2 W8, W1
614:               
615:                       i--;
00916E  E90489     DEC W9, W9
616:                   }    while ((i > 0) && (latch != (addr % DATA_EE_SIZE)));
00915A  200FF2     MOV #0xFF, W2
00915C  780501     MOV W1, W10
00915E  090011     REPEAT #0x11
009160  D88402     DIV.UW W8, W2
009162  FD0501     EXCH W1, W10
009164  202009     MOV #0x200, W9
009166  780401     MOV W1, W8
009170  320003     BRA Z, 0x9178
009172  500F8A     SUB W0, W10, [W15]
009174  320006     BRA Z, 0x9182
009176  37FFF7     BRA 0x9166
617:               
618:                   if (!i) {
619:                       SetaddrNotFound(1);
009178  A80F2A     BSET dataEEFlags, #0
620:                       TBLPAG = savedTBLPAG;
00917A  78000B     MOV W11, W0
00917C  B7E032     MOV.B WREG, TBLPAG
00917E  EB8000     SETM W0
009180  370005     BRA 0x918C
621:                       return (0xFFFF);
622:                   }
623:               
624:                   pmOffset += 2;
625:                   latch = ReadPMLow(pmOffset);
009182  780008     MOV W8, W0
009184  07C6F0     RCALL _ReadPMLow
626:               
627:                   TBLPAG = savedTBLPAG;
009186  FD0580     EXCH W0, W11
009188  B7E032     MOV.B WREG, TBLPAG
00918A  FD0580     EXCH W0, W11
628:                   return (latch);
629:               }
00918C  BE054F     MOV.D [--W15], W10
00918E  BE044F     MOV.D [--W15], W8
009190  060000     RETURN
630:               
631:               /************************************************************************
632:               DataEEWrite
633:               
634:               This routine verifies the address is valid. If not, the Illegal Address
635:               flag is set and an error code is returned. It then finds the active page.
636:               If an active page can not be found, the Page Corrupt status bit is set
637:               and an error code is returned. A read is performed, if the data was not
638:               changed, the function exits. If the last location is programmed, the Pack
639:               Skipped error flag is set (one location should always be available). The
640:               data EE information (MSB = address, LSW = data) is programmed and
641:               verified. If the verify fails, the Write Error flag is set. If the write
642:               went into the last location of the page, pack is called. This function
643:               can be called by the user.
644:               
645:               Parameters:		Data EE address and data
646:               Return:			Pass or fail status (0 = Pass)
647:               Side Effects:	Data EE flags may be updated. CPU stall occurs for flash
648:                               programming. Pack may be generated.
649:                ************************************************************************/
650:               unsigned char DataEEWrite(unsigned int data, unsigned int addr) {
009192  4787E4     ADD W15, #0x4, W15
009194  BE9F88     MOV.D W8, [W15++]
009196  BE9F8A     MOV.D W10, [W15++]
009198  BE9F8C     MOV.D W12, [W15++]
00919A  781F8E     MOV W14, [W15++]
00919C  780500     MOV W0, W10
00919E  780481     MOV W1, W9
651:                   int savedTBLPAG; //Context save of TBLPAG value. Current and packed page are on same page.
652:                   int currentPage;
653:                   int pmOffset; //Current array (page) offset of selected element (PM 16-bit word)
654:                   unsigned int nextLoc;
655:                   volatile unsigned char latch;
656:                   unsigned char dataEEFlags_sh;
657:                   unsigned int bank;
658:               
659:                   if (addr >= DATA_EE_TOTAL_SIZE) {
0091A0  200FE0     MOV #0xFE, W0
0091A2  508F80     SUB W1, W0, [W15]
0091A4  360003     BRA LEU, 0x91AC
660:                       SetPageIllegalAddress(1);
0091A6  A8AF2A     BSET dataEEFlags, #5
0091A8  200050     MOV #0x5, W0
0091AA  370080     BRA 0x92AC
661:                       return (5);
662:                   }
663:               
664:                   bank = addr / DATA_EE_SIZE;
0091AC  200FF2     MOV #0xFF, W2
0091AE  090011     REPEAT #0x11
0091B0  D88082     DIV.UW W1, W2
0091B2  780580     MOV W0, W11
665:               
666:                   savedTBLPAG = TBLPAG;
0091B4  BFC032     MOV.B TBLPAG, WREG
0091B6  FB8600     ZE W0, W12
667:                   NVMCON = PROGRAM_WORD;
0091B8  240030     MOV #0x4003, W0
0091BA  883B00     MOV W0, NVMCON
0091BC  EB0400     CLR W8
0091BE  78468B     MOV.B W11, W13
0091C0  370003     BRA 0x91C8
668:               
669:                   // Find the active page.
670:                   for (currentPage = 0;
671:                           (currentPage < NUM_DATA_EE_PAGES) &&
0091C4  540FE2     SUB W8, #0x2, [W15]
0091C6  320007     BRA Z, 0x91D6
0091C8  B3C132     MOV.B #0x13, W2
0091CA  784088     MOV.B W8, W1
0091CC  78400B     MOV.B W11, W0
0091CE  07FD9F     RCALL GetPageStatus
0091D0  500FE1     SUB W0, #0x1, [W15]
0091D2  32FFF7     BRA Z, 0x91C2
0091D4  370005     BRA 0x91E0
672:                           (GetPageStatus(bank, currentPage, STATUS_CURRENT) == PAGE_NOT_CURRENT);
673:                           currentPage++) {
0091C2  E80408     INC W8, W8
674:                   }
675:               
676:                   if (currentPage == NUM_DATA_EE_PAGES) {
677:                       TBLPAG = savedTBLPAG;
0091D6  78000C     MOV W12, W0
0091D8  B7E032     MOV.B WREG, TBLPAG
678:                       SetPageCorruptStatus(1);
0091DA  A8CF2A     BSET dataEEFlags, #6
0091DC  200060     MOV #0x6, W0
0091DE  370066     BRA 0x92AC
679:                       return (6); // Error - no active page
680:                   }
681:               
682:                   // Point to proper TBLPAG and offset
683:                   TBLPAG = DEE_PAGE_TBL(bank, currentPage);
0091E0  220004     MOV #0x2000, W4
0091E2  200005     MOV #0x0, W5
0091E4  DD594B     SL W11, #11, W2
0091E6  420102     ADD W4, W2, W2
0091E8  4A81E0     ADDC W5, #0x0, W3
0091EA  DD404A     SL W8, #10, W0
0091EC  410000     ADD W2, W0, W0
0091EE  4980E0     ADDC W3, #0x0, W1
0091F0  DE0840     LSR W1, #0, W0
0091F2  B7E032     MOV.B WREG, TBLPAG
684:                   pmOffset = DEE_PAGE_OFFSET(bank, currentPage);
0091F4  45800B     ADD W11, W11, W0
0091F6  440000     ADD W8, W0, W0
0091F8  DD004A     SL W0, #10, W0
0091FA  400584     ADD W0, W4, W11
685:               
686:                   dataEEFlags_sh = dataEEFlags.val;
0091FC  20F2A8     MOV #0xF2A, W8
0091FE  784418     MOV.B [W8], W8
687:               
688:                   //Do not write data if it did not change
689:                   if (DataEERead(addr) == data) {
009200  780009     MOV W9, W0
009202  07FF7C     RCALL DataEERead
009204  500F8A     SUB W0, W10, [W15]
009206  3A000A     BRA NZ, 0x921C
690:                       if (GetaddrNotFound() == 0) // Check if the read was successful
009208  807950     MOV dataEEFlags, W0
00920A  600061     AND W0, #0x1, W0
00920C  3A0007     BRA NZ, 0x921C
691:                       {
692:                           TBLPAG = savedTBLPAG;
00920E  FD0600     EXCH W0, W12
009210  B7E032     MOV.B WREG, TBLPAG
009212  FD0600     EXCH W0, W12
693:                           dataEEFlags.val = dataEEFlags_sh;
009214  FD0400     EXCH W0, W8
009216  B7EF2A     MOV.B WREG, dataEEFlags
009218  FD0400     EXCH W0, W8
00921A  370048     BRA 0x92AC
694:                           return (0);
695:                       }
696:                   }
697:               
698:                   dataEEFlags.val = dataEEFlags_sh; //Restore status flags
00921C  780008     MOV W8, W0
00921E  B7EF2A     MOV.B WREG, dataEEFlags
699:                   nextLoc = GetNextAvailCount(bank);
009220  78400D     MOV.B W13, W0
009222  07FDBF     RCALL GetNextAvailCount
009224  780700     MOV W0, W14
700:               
701:                   if (!nextLoc) {
009226  E00000     CP0 W0
009228  3A0005     BRA NZ, 0x9234
702:                       TBLPAG = savedTBLPAG;
00922A  78000C     MOV W12, W0
00922C  B7E032     MOV.B WREG, TBLPAG
703:                       SetPagePackSkipped(1);
00922E  A88F2A     BSET dataEEFlags, #4
009230  200040     MOV #0x4, W0
009232  37003C     BRA 0x92AC
704:                       return (4); //Error - Number of writes exceeds page size
705:                   }
706:               
707:                   pmOffset = pmOffset + nextLoc;
009234  40058B     ADD W0, W11, W11
708:               
709:                   WritePMLow(data, pmOffset);
009236  BE000A     MOV.D W10, W0
009238  07C6A9     RCALL _WritePMLow
710:                   WritePMHigh((addr % DATA_EE_SIZE), pmOffset);
00923A  200FF8     MOV #0xFF, W8
00923C  090011     REPEAT #0x11
00923E  D88488     DIV.UW W9, W8
009240  780481     MOV W1, W9
009242  78008B     MOV W11, W1
009244  780009     MOV W9, W0
009246  07C69E     RCALL _WritePMHigh
711:               
712:                   UnlockWrite();
009248  07FD4D     RCALL UnlockWrite
713:               
714:                   Nop();
00924A  000000     NOP
715:                   Nop();
00924C  000000     NOP
716:               
717:                   latch = (ReadPMLow(pmOffset) & 0xFF);
00924E  78000B     MOV W11, W0
009250  07C68A     RCALL _ReadPMLow
009252  9FF780     MOV.B W0, [W15-16]
718:               
719:                   if (latch != (data & 0xFF)) {
009254  97F08F     MOV.B [W15-16], W1
009256  FB8001     ZE W1, W0
009258  650408     AND W10, W8, W8
00925A  500F88     SUB W0, W8, [W15]
00925C  320005     BRA Z, 0x9268
720:                       TBLPAG = savedTBLPAG;
00925E  78000C     MOV W12, W0
009260  B7E032     MOV.B WREG, TBLPAG
721:                       SetPageWriteError(1);
009262  A8EF2A     BSET dataEEFlags, #7
009264  200070     MOV #0x7, W0
009266  370022     BRA 0x92AC
722:                       return (7); //Error - RAM does not match PM
723:                   }
724:               
725:                   latch = (ReadPMHigh(pmOffset) & 0xFF);
009268  78000B     MOV W11, W0
00926A  07C67B     RCALL _ReadPMHigh
00926C  9FF780     MOV.B W0, [W15-16]
726:               
727:                   if (latch != (addr % DATA_EE_SIZE)) {
00926E  97F08F     MOV.B [W15-16], W1
009270  FB8001     ZE W1, W0
009272  548F80     SUB W9, W0, [W15]
009274  320005     BRA Z, 0x9280
728:                       TBLPAG = savedTBLPAG;
009276  78000C     MOV W12, W0
009278  B7E032     MOV.B WREG, TBLPAG
729:                       SetPageWriteError(1);
00927A  A8EF2A     BSET dataEEFlags, #7
00927C  200070     MOV #0x7, W0
00927E  370016     BRA 0x92AC
730:                       return (7); //Error - RAM does not match PM
731:                   }
732:               
733:                   pmOffset += 1;
734:                   latch = ((ReadPMLow(pmOffset) >> 8) & 0xFF);
009280  E8000B     INC W11, W0
009282  07C671     RCALL _ReadPMLow
009284  DE8048     ASR W0, #8, W0
009286  9FF780     MOV.B W0, [W15-16]
735:               
736:                   if (latch != ((data >> 8) & 0xFF)) {
009288  97F00F     MOV.B [W15-16], W0
00928A  FB8080     ZE W0, W1
00928C  DE5048     LSR W10, #8, W0
00928E  508F80     SUB W1, W0, [W15]
009290  320005     BRA Z, 0x929C
737:                       TBLPAG = savedTBLPAG;
009292  78000C     MOV W12, W0
009294  B7E032     MOV.B WREG, TBLPAG
738:                       SetPageWriteError(1);
009296  A8EF2A     BSET dataEEFlags, #7
009298  200070     MOV #0x7, W0
00929A  370008     BRA 0x92AC
739:                       return (7); //Error - RAM does not match PM
740:                   }
741:               
742:                   //Pack if page is full
743:                   if ((nextLoc + 2) == ((NUMBER_OF_INSTRUCTIONS_IN_PAGE) * 2)) {
00929C  203FE0     MOV #0x3FE, W0
00929E  570F80     SUB W14, W0, [W15]
0092A0  3A0002     BRA NZ, 0x92A6
744:                       PackEE(bank);
0092A2  78400D     MOV.B W13, W0
0092A4  07FDAF     RCALL PackEE
745:                   }
746:               
747:                   TBLPAG = savedTBLPAG;
0092A6  78000C     MOV W12, W0
0092A8  B7E032     MOV.B WREG, TBLPAG
0092AA  EB0000     CLR W0
748:               
749:                   return (0);
750:               }
0092AC  78074F     MOV [--W15], W14
0092AE  BE064F     MOV.D [--W15], W12
0092B0  BE054F     MOV.D [--W15], W10
0092B2  BE044F     MOV.D [--W15], W8
0092B4  B1004F     SUB #0x4, W15
0092B6  060000     RETURN
---  D:/PIC/PIC_PS4_Host/trunk/Common/uart2.c  ----------------------------------------------------------
1:                 /*
2:                 
3:                 UART2 Driver File for PIC24.
4:                 
5:                  ********************************************************************************
6:                  FileName:        uart2.c
7:                  Dependencies:    HardwareProfile.h
8:                  Processor:       PIC24
9:                  Compiler:        MPLAB C30
10:                 Linker:          MPLAB LINK30
11:                 Company:         Microchip Technology Incorporated
12:                
13:                Author                Date      Comment
14:                ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
15:                KO                 12-Feb-2008  Modified to use HardwareProfile.h
16:                KO                 11-Oct-2006  v1.0
17:                Anton Alkhimenok   18-Oct-2005
18:                Anton Alkhimenok   17-Feb-2009  Added UART2Char2Hex(), UART2Hex2Char(),
19:                                UART2ClearError(), UART2DataReceived()
20:                PAT                 27-Jan-2010  Added UART2GetBaudError() for dynamic checking
21:                                of baud rate percentage error.
22:                 MH                 22-Oct-2012 Changed BAUDRATEREG2 formula
23:                 *                              Fixed bug in UART2PutDec
24:                 *                              Added UART2PutSDec
25:                 *                              Added UART2PutDecInt(unsigned int dec);
26:                 *                              Added UART2PutDecSInt(signed int dec);
27:                 ********************************************************************************
28:                Software License Agreement
29:                
30:                Microchip Technology Inc. ("Microchip") licenses to you the right to use, copy,
31:                modify and distribute the software - including source code - only for use with
32:                Microchip microcontrollers or Microchip digital signal controllers; provided
33:                that no open source or free software is incorporated into the Source Code
34:                without Microchips prior written consent in each instance.
35:                
36:                The software is owned by Microchip and its licensors, and is protected under
37:                applicable copyright laws.  All rights reserved.
38:                
39:                SOFTWARE AND DOCUMENTATION ARE PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND,
40:                EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF
41:                MERCHANTABILITY, TITLE, NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE.
42:                IN NO EVENT SHALL MICROCHIP OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER
43:                CONTRACT, NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR
44:                OTHER LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
45:                INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT OR
46:                CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT OF
47:                SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, ANY CLAIMS BY THIRD PARTIES (INCLUDING
48:                BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
49:                
50:                 ********************************************************************************
51:                 */
52:                
53:                #include "Compiler.h"
54:                #include "HardwareProfile.h"
55:                #include "uart2.h"
56:                
57:                //******************************************************************************
58:                // Constants
59:                //******************************************************************************
60:                
61:                //U2BRG register value and baudrate mistake calculation
62:                
63:                #if defined (__C30__)
64:                #if defined (__dsPIC33E__) || defined (__PIC24E__)
65:                #define BAUDRATEREG2        (((GetPeripheralClock())/(BRG_DIV2 * BAUDRATE2)) - 1)
66:                #else
67:                #define BAUDRATEREG2        (((GetInstructionClock())/(BRG_DIV2 * BAUDRATE2)) - 1) //MH, use new formula
68:                #endif
69:                #elif defined (__PIC32MX__)
70:                #define BAUDRATEREG2        ((GetPeripheralClock()+(BRG_DIV2/2*BAUDRATE2))/BRG_DIV2/BAUDRATE2-1)
71:                #else
72:                #error Cannot calculate BRG value
73:                #endif
74:                
75:                #if defined (__C30__)
76:                #if defined (__dsPIC33E__)|| defined (__PIC24E__)
77:                #define BAUD_ACTUAL         ((GetPeripheralClock())/(BRG_DIV2 * (BAUDRATEREG2+1)))
78:                #else
79:                #define BAUD_ACTUAL         ((GetSystemClock()/2)/BRG_DIV2/(BAUDRATEREG2+1))
80:                #endif
81:                #elif defined (__PIC32MX__)
82:                #define BAUD_ACTUAL         (GetPeripheralClock()/BRG_DIV2/(BAUDRATEREG2+1))
83:                #else
84:                #error Cannot calculate actual baud rate
85:                #endif
86:                
87:                #define BAUD_ERROR              ((BAUD_ACTUAL > BAUDRATE2) ? BAUD_ACTUAL-BAUDRATE2 : BAUDRATE2-BAUD_ACTUAL)
88:                #define BAUD_ERROR_PERCENT      ((BAUD_ERROR*100+BAUDRATE2/2)/BAUDRATE2)
89:                
90:                #if defined (__C30__)
91:                
92:                #if (BAUD_ERROR_PERCENT > 3)
93:                #error UART frequency error is worse than 3%
94:                #elif (BAUD_ERROR_PERCENT > 2)
95:                #warning UART frequency error is worse than 2%
96:                #endif
97:                
98:                #endif // #if defined (__C30__)
99:                
100:               /*******************************************************************************
101:               Function: UART2GetBaudError()
102:               
103:               Precondition:
104:                   None.
105:               
106:               Overview:
107:                   This routine checks the UART baud rate error percentage and returns it.
108:               
109:               Input: None.
110:               
111:               Output: Returns the baud rate error in percent.
112:               
113:                *******************************************************************************/
114:               char UART2GetBaudError() {
115:                   unsigned int errorPercent = 0;
116:               
117:                   errorPercent = ((BAUD_ERROR * 100 + BAUDRATE2 / 2) / BAUDRATE2);
118:                   return (char) errorPercent;
119:               }
009640  200020     MOV #0x2, W0
009642  060000     RETURN
120:               
121:               /*******************************************************************************
122:               Function: UART2GetChar()
123:               
124:               Precondition:
125:                   UART2Init must be called prior to calling this routine.
126:               
127:               Overview:
128:                   This routine waits for a byte to be received.  It then returns that byte.
129:               
130:               Input: None.
131:               
132:               Output: Byte received.
133:               
134:                *******************************************************************************/
135:               char UART2GetChar() {
136:                   char Temp;
137:               
138:                   //while (IFS1bits.U2RXIF == 0);
139:                   Temp = 'E';
140:                   if (UART2DataReceived()){
009644  BFC232     MOV.B U2STA, WREG
009646  B3C451     MOV.B #0x45, W1
009648  A30800     BTST.Z W0, #0
00964A  320002     BRA Z, 0x9650
141:                       Temp = U2RXREG;
00964C  8011B0     MOV U2RXREG, W0
00964E  784080     MOV.B W0, W1
142:                   }
143:                   IFS1bits.U2RXIF = 0;
009650  A9C087     BCLR 0x87, #6
009652  FB0001     SE W1, W0
144:                   return Temp;
145:               }
009654  060000     RETURN
146:               
147:               /*******************************************************************************
148:               Function: UART2Init()
149:               
150:               Precondition: None.
151:               
152:               Overview:
153:                   This routine sets up the UART2 module.
154:               
155:               Input: None.
156:               
157:               Output: None.
158:               
159:               Notes:
160:                   Allow the peripheral to set the I/O pin directions.  If we set the TRIS
161:                   bits manually, then when we disable the UART, the shape of the stop bit
162:                   changes, and some terminal programs have problems.
163:                *******************************************************************************/
164:               void UART2Init() {
165:                   U2BRG = BAUDRATEREG2;
009656  200210     MOV #0x21, W0
009658  8811C0     MOV W0, U2BRG
166:                   U2MODE = 0;
00965A  EB0000     CLR W0
00965C  881180     MOV W0, U2MODE
167:                   U2MODEbits.BRGH = BRGH2;
00965E  A86230     BSET U2MODE, #3
168:                   U2STA = 0;
009660  881190     MOV W0, U2STA
169:                   U2MODEbits.UARTEN = 1;
009662  A8E231     BSET 0x231, #7
170:                   U2STAbits.UTXEN = 1;
009664  A84233     BSET 0x233, #2
171:                   IFS1bits.U2RXIF = 0;
009666  A9C087     BCLR 0x87, #6
172:               
173:               #if defined (__PIC32MX__)
174:                   U2STAbits.URXEN = 1;
175:               #endif
176:               
177:               
178:               
179:               
180:               
181:                   //**********************************************************
182:                   // Unlock Registers
183:                   //**********************************************************
184:                   /*
185:                       asm volatile (  "mov #OSCCON, w1 \n"
186:                                       "mov #0x46, w2 \n"
187:                                       "mov #0x57, w3 \n"
188:                                       "mov.b w2, [w1] \n"
189:                                       "mov.b w3, [w1] \n"
190:                                       "bclr OSCCON, #6 \n");
191:                    */
192:               
193:               
194:                   //**********************************************************
195:                   // Lock Registers
196:                   //**********************************************************
197:                   /*
198:                       asm volatile ( 	"mov #OSCCON, w1 \n"
199:                                       "mov #0x46, w2 \n"
200:                                       "mov #0x57, w3 \n"
201:                                       "mov.b w2, [w1] \n"
202:                                       "mov.b w3, [w1] \n"
203:                                       "bset OSCCON, #6 \n");
204:                    */
205:               }
009668  060000     RETURN
206:               
207:               /*******************************************************************************
208:               Function: UART2IsPressed()
209:               
210:               Precondition:
211:                   UART2Init must be called prior to calling this routine.
212:               
213:               Overview:
214:                   This routine checks to see if there is a new byte in UART reception buffer.
215:               
216:               Input: None.
217:               
218:               Output:
219:                   0 : No new data received.
220:                   1 : Data is in the receive buffer
221:               
222:                *******************************************************************************/
223:               char UART2IsPressed() {
224:                   if (IFS1bits.U2RXIF == 1 || U2STAbits.URXDA)
00966A  BFC087     MOV.B 0x87, WREG
00966C  A36800     BTST.Z W0, #6
00966E  3A0004     BRA NZ, 0x9678
009670  BFC232     MOV.B U2STA, WREG
009672  EB0080     CLR W1
009674  A30800     BTST.Z W0, #0
009676  320001     BRA Z, 0x967A
009678  200011     MOV #0x1, W1
225:                       return 1;
226:                   return 0;
227:               }
00967A  780001     MOV W1, W0
00967C  060000     RETURN
228:               
229:               /*******************************************************************************
230:               Function: UART2PrintString( char *str )
231:               
232:               Precondition:
233:                   UART2Init must be called prior to calling this routine.
234:               
235:               Overview:
236:                   This function prints a string of characters to the UART.
237:               
238:               Input: Pointer to a null terminated character string.
239:               
240:               Output: None.
241:               
242:                *******************************************************************************/
243:               void UART2PrintString(char *str) {
00967E  781F88     MOV W8, [W15++]
244:                   unsigned char c;
245:               
246:                   while ((c = *str++))
009680  7840B0     MOV.B [W0++], W1
009682  780400     MOV W0, W8
009684  E00401     CP0.B W1
009686  320006     BRA Z, 0x9694
00968C  784038     MOV.B [W8++], W0
00968E  784080     MOV.B W0, W1
009690  E00400     CP0.B W0
009692  3AFFFA     BRA NZ, 0x9688
247:                       UART2PutChar(c);
009688  784001     MOV.B W1, W0
00968A  070006     RCALL UART2PutChar
248:               }
009694  78044F     MOV [--W15], W8
009696  060000     RETURN
249:               
250:               /*******************************************************************************
251:               Function: UART2PutChar( char ch )
252:               
253:               Precondition:
254:                   UART2Init must be called prior to calling this routine.
255:               
256:               Overview:
257:                   This routine writes a character to the transmit FIFO, and then waits for the
258:                   transmit FIFO to be empty.
259:               
260:               Input: Byte to be sent.
261:               
262:               Output: None.
263:               
264:                *******************************************************************************/
265:               void UART2PutChar(char ch) {
266:                   U2TXREG = ch;
009698  FB0000     SE W0, W0
00969A  8811A0     MOV W0, U2TXREG
267:               #if !defined(__PIC32MX__)
268:                   Nop();
00969C  000000     NOP
269:               #endif
270:                   while (U2STAbits.TRMT == 0);
00969E  BFC233     MOV.B 0x233, WREG
0096A0  A30800     BTST.Z W0, #0
0096A2  32FFFD     BRA Z, 0x969E
271:               }
0096A4  060000     RETURN
272:               
273:               /*******************************************************************************
274:               Function: UART2PutDec(unsigned char dec)
275:               
276:               Precondition:
277:                   UART2Init must be called prior to calling this routine.
278:               
279:               Overview:
280:                   This function converts decimal data into a string and outputs it to UART.
281:               
282:               Input: Binary data.
283:               
284:               Output: None.
285:               
286:                *******************************************************************************/
287:               void UART2PutDec(unsigned char dec) {
0096A6  BE9F88     MOV.D W8, [W15++]
0096A8  BE9F8A     MOV.D W10, [W15++]
0096AA  784100     MOV.B W0, W2
288:                   unsigned char res;
289:                   unsigned char digit = 100;
290:                   res = dec;
291:               
292:                   if (res == 0){
0096AC  E00400     CP0.B W0
0096AE  3A001F     BRA NZ, 0x96EE
293:                       UART2PutChar('0');
0096B0  B3C300     MOV.B #0x30, W0
0096B2  07FFF2     RCALL UART2PutChar
0096B4  370023     BRA 0x96FC
0096EE  B3C649     MOV.B #0x64, W9
0096F0  2000A3     MOV #0xA, W3
294:                   }
295:                   else
296:                   {
297:                       while (digit>res) {
0096C0  514F81     SUB.B W2, W1, [W15]
0096C2  39FFF9     BRA NC, 0x96B6
0096F2  B3C630     MOV.B #0x63, W0
0096F4  514F80     SUB.B W2, W0, [W15]
0096F6  36FFDF     BRA LEU, 0x96B6
0096F8  784582     MOV.B W2, W11
0096FA  37FFE7     BRA 0x96CA
298:                           digit = digit/10;
0096B6  FB8009     ZE W9, W0
0096B8  090011     REPEAT #0x11
0096BA  D88003     DIV.UW W0, W3
0096BC  FD0080     EXCH W0, W1
0096BE  784481     MOV.B W1, W9
299:                       }
300:                       while (digit)
0096C4  E00401     CP0.B W1
0096C6  32001A     BRA Z, 0x96FC
0096C8  784582     MOV.B W2, W11
0096E8  E0040A     CP0.B W10
0096EA  320008     BRA Z, 0x96FC
0096EC  37FFEE     BRA 0x96CA
301:                       {
302:                           UART2PutChar(res / digit + '0');
0096CA  FB840B     ZE W11, W8
0096CC  FB8509     ZE W9, W10
0096CE  090011     REPEAT #0x11
0096D0  D8840A     DIV.UW W8, W10
0096D2  780400     MOV W0, W8
0096D4  B3C301     MOV.B #0x30, W1
0096D6  444001     ADD.B W8, W1, W0
0096D8  07FFDF     RCALL UART2PutChar
303:                           res = res - (res / digit)*digit;
0096DA  B9CC08     MUL.SS W9, W8, W8
0096DC  55C588     SUB.B W11, W8, W11
304:                           digit = digit/10;
0096DE  2000A2     MOV #0xA, W2
0096E0  090011     REPEAT #0x11
0096E2  D88502     DIV.UW W10, W2
0096E4  780500     MOV W0, W10
0096E6  78448A     MOV.B W10, W9
305:                       }
306:                   }
307:               }
0096FC  BE054F     MOV.D [--W15], W10
0096FE  BE044F     MOV.D [--W15], W8
009700  060000     RETURN
308:               
309:               void UART2PutSDec(signed char dec) {
009702  781F88     MOV W8, [W15++]
310:                   unsigned char res;
311:                   if (dec < 0) {
009704  E00400     CP0.B W0
009706  3D0004     BRA GE, 0x9710
312:                       res = ~dec + 1;
009708  EA4400     NEG.B W0, W8
313:                       UART2PutChar('-');
00970A  B3C2D0     MOV.B #0x2D, W0
00970C  07FFC5     RCALL UART2PutChar
00970E  370001     BRA 0x9712
314:                   } else {
315:                       res = dec;
009710  784400     MOV.B W0, W8
316:                   }
317:                   UART2PutDec(res);
009712  784008     MOV.B W8, W0
009714  07FFC8     RCALL UART2PutDec
318:               }
009716  78044F     MOV [--W15], W8
009718  060000     RETURN
319:               
320:               void UART2PutDecInt(unsigned int dec) {
00971A  BE9F88     MOV.D W8, [W15++]
00971C  BE9F8A     MOV.D W10, [W15++]
00971E  780080     MOV W0, W1
321:                   unsigned int res;
322:                   unsigned int digit = 10000;
323:                   res = dec;
324:               
325:                   if (res == 0){
009720  E00000     CP0 W0
009722  3A001E     BRA NZ, 0x9760
326:                       UART2PutChar('0');
009724  B3C300     MOV.B #0x30, W0
009726  07FFB8     RCALL UART2PutChar
009728  370021     BRA 0x976C
00972A  22710A     MOV #0x2710, W10
00972C  2000A2     MOV #0xA, W2
327:                   }
328:                   else
329:                   {
330:                       while (digit>res) {
009738  508F8A     SUB W1, W10, [W15]
00973A  39FFF9     BRA NC, 0x972E
009760  2270F0     MOV #0x270F, W0
009762  508F80     SUB W1, W0, [W15]
009764  36FFE2     BRA LEU, 0x972A
009766  780581     MOV W1, W11
009768  22710A     MOV #0x2710, W10
00976A  37FFEB     BRA 0x9742
331:                           digit = digit/10;
00972E  781F81     MOV W1, [W15++]
009730  090011     REPEAT #0x11
009732  D88502     DIV.UW W10, W2
009734  780500     MOV W0, W10
009736  7800CF     MOV [--W15], W1
332:                       }
333:                       while (digit)
00973C  E0000A     CP0 W10
00973E  320016     BRA Z, 0x976C
009740  780581     MOV W1, W11
00975A  E0000A     CP0 W10
00975C  320007     BRA Z, 0x976C
00975E  37FFF1     BRA 0x9742
334:                       {
335:                           UART2PutChar(res / digit + '0');
009742  090011     REPEAT #0x11
009744  D8858A     DIV.UW W11, W10
009746  780400     MOV W0, W8
009748  B3C301     MOV.B #0x30, W1
00974A  444001     ADD.B W8, W1, W0
00974C  07FFA5     RCALL UART2PutChar
336:                           res = res - (res / digit)*digit;
00974E  B9D408     MUL.SS W10, W8, W8
009750  558588     SUB W11, W8, W11
337:                           digit = digit/10;
009752  2000A2     MOV #0xA, W2
009754  090011     REPEAT #0x11
009756  D88502     DIV.UW W10, W2
009758  780500     MOV W0, W10
338:                       }
339:                   }
340:               }
00976C  BE054F     MOV.D [--W15], W10
00976E  BE044F     MOV.D [--W15], W8
009770  060000     RETURN
341:               
342:               
343:               void UART2PutDecSInt(signed int dec) {
009772  781F88     MOV W8, [W15++]
344:                   unsigned int res;
345:                   if (dec < 0) {
009774  E00000     CP0 W0
009776  3D0004     BRA GE, 0x9780
346:                       res = ~dec + 1;
009778  EA0400     NEG W0, W8
347:                       UART2PutChar('-');
00977A  B3C2D0     MOV.B #0x2D, W0
00977C  07FF8D     RCALL UART2PutChar
00977E  370001     BRA 0x9782
348:                   } else {
349:                       res = dec;
009780  780400     MOV W0, W8
350:                   }
351:                   UART2PutDecInt(res);
009782  780008     MOV W8, W0
009784  07FFCA     RCALL UART2PutDecInt
352:               }
009786  78044F     MOV [--W15], W8
009788  060000     RETURN
353:               
354:               void UART2PutDecLong(unsigned long dec) {
00978A  BE9F88     MOV.D W8, [W15++]
00978C  BE9F8A     MOV.D W10, [W15++]
00978E  BE9F8C     MOV.D W12, [W15++]
009790  BE0600     MOV.D W0, W12
355:                   unsigned long res;
356:                   unsigned long digit = 1000000000;
357:                   res = dec;
358:               
359:                   if (res == 0){
009792  500FE0     SUB W0, #0x0, [W15]
009794  588FE0     SUBB W1, #0x0, [W15]
009796  3A0025     BRA NZ, 0x97E2
360:                       UART2PutChar('0');
009798  B3C300     MOV.B #0x30, W0
00979A  07FF7E     RCALL UART2PutChar
00979C  37002A     BRA 0x97F2
0097E2  2CA00A     MOV #0xCA00, W10
0097E4  23B9AB     MOV #0x3B9A, W11
361:                   }
362:                   else
363:                   {
364:                       while (digit>res) {
0097A8  560F80     SUB W12, W0, [W15]
0097AA  5E8F81     SUBB W13, W1, [W15]
0097AC  39FFF8     BRA NC, 0x979E
0097E6  2C9FF0     MOV #0xC9FF, W0
0097E8  23B9A1     MOV #0x3B9A, W1
0097EA  560F80     SUB W12, W0, [W15]
0097EC  5E8F81     SUBB W13, W1, [W15]
0097EE  36FFD7     BRA LEU, 0x979E
0097F0  37FFE1     BRA 0x97B4
365:                           digit = digit/10;
00979E  2000A2     MOV #0xA, W2
0097A0  200003     MOV #0x0, W3
0097A2  BE000A     MOV.D W10, W0
0097A4  07B58E     RCALL ___udivsi3
0097A6  BE0500     MOV.D W0, W10
366:                       }
367:                       while (digit)
0097AE  500FE0     SUB W0, #0x0, [W15]
0097B0  588FE0     SUBB W1, #0x0, [W15]
0097B2  32001F     BRA Z, 0x97F2
0097DA  500FE0     SUB W0, #0x0, [W15]
0097DC  588FE0     SUBB W1, #0x0, [W15]
0097DE  320009     BRA Z, 0x97F2
0097E0  37FFE9     BRA 0x97B4
368:                       {
369:                           UART2PutChar(res / digit + '0');
0097B4  BE010A     MOV.D W10, W2
0097B6  BE000C     MOV.D W12, W0
0097B8  07B584     RCALL ___udivsi3
0097BA  BE0400     MOV.D W0, W8
0097BC  B3C301     MOV.B #0x30, W1
0097BE  444001     ADD.B W8, W1, W0
0097C0  07FF6B     RCALL UART2PutChar
370:                           res = res - (res / digit)*digit;
0097C2  B8410A     MUL.UU W8, W10, W2
0097C4  B9D009     MUL.SS W10, W9, W0
0097C6  400003     ADD W0, W3, W0
0097C8  B9C40B     MUL.SS W8, W11, W8
0097CA  400188     ADD W0, W8, W3
0097CC  560602     SUB W12, W2, W12
0097CE  5E8683     SUBB W13, W3, W13
371:                           digit = digit/10;
0097D0  2000A2     MOV #0xA, W2
0097D2  200003     MOV #0x0, W3
0097D4  BE000A     MOV.D W10, W0
0097D6  07B575     RCALL ___udivsi3
0097D8  BE0500     MOV.D W0, W10
372:                       }
373:                   }
374:               }
0097F2  BE064F     MOV.D [--W15], W12
0097F4  BE054F     MOV.D [--W15], W10
0097F6  BE044F     MOV.D [--W15], W8
0097F8  060000     RETURN
375:               
376:               void UART2PutDecSLong(signed long dec) {
0097FA  BE9F88     MOV.D W8, [W15++]
377:                   unsigned long res;
378:                   if (dec < 0) {
0097FC  500FE0     SUB W0, #0x0, [W15]
0097FE  588FE0     SUBB W1, #0x0, [W15]
009800  3D0005     BRA GE, 0x980C
379:                       res = ~dec + 1;
009802  100460     SUBR W0, #0x0, W8
009804  1884E0     SUBBR W1, #0x0, W9
380:                       UART2PutChar('-');
009806  B3C2D0     MOV.B #0x2D, W0
009808  07FF47     RCALL UART2PutChar
00980A  370001     BRA 0x980E
381:                   } else {
382:                       res = dec;
00980C  BE0400     MOV.D W0, W8
383:                   }
384:                   UART2PutDecLong(res);
00980E  BE0008     MOV.D W8, W0
009810  07FFBC     RCALL UART2PutDecLong
385:               }
009812  BE044F     MOV.D [--W15], W8
009814  060000     RETURN
386:               
387:               /*******************************************************************************
388:               Function: UART2PutHex
389:               
390:               Precondition:
391:                   UART2Init must be called prior to calling this routine.
392:               
393:               Overview:
394:                   This function converts hex data into a string and outputs it to UART.
395:               
396:               Input: Binary data.
397:               
398:               Output: None.
399:               
400:                *******************************************************************************/
401:               
402:               const unsigned char CharacterArray[] = {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};
403:               
404:               void UART2PutHex(int toPrint) {
009816  BE9F88     MOV.D W8, [W15++]
009818  780480     MOV W0, W9
405:                   int printVar;
406:               
407:                   printVar = toPrint;
408:                   toPrint = (toPrint >> 4) & 0x0F;
409:                   UART2PutChar(CharacterArray[toPrint]);
00981A  DE8044     ASR W0, #4, W0
00981C  60006F     AND W0, #0xF, W0
00981E  29F328     MOV #0x9F32, W8
009820  7C4060     MOV.B [W0+W8], W0
009822  07FF3A     RCALL UART2PutChar
410:               
411:                   toPrint = printVar & 0x0F;
412:                   UART2PutChar(CharacterArray[toPrint]);
009824  64806F     AND W9, #0xF, W0
009826  7C4060     MOV.B [W0+W8], W0
009828  07FF37     RCALL UART2PutChar
413:               
414:                   return;
415:               }
00982A  BE044F     MOV.D [--W15], W8
00982C  060000     RETURN
416:               
417:               /*******************************************************************************
418:               Function: UART2PutHexWord(unsigned int toPrint)
419:               
420:               Precondition:
421:                   UART2Init must be called prior to calling this routine.
422:               
423:               Overview:
424:                   This function converts hex data into a string and outputs it to UART.
425:               
426:               Input: Binary data.
427:               
428:               Output: None.
429:               
430:                *******************************************************************************/
431:               #if defined( __C30__ ) || defined( __PIC32MX__ )
432:               
433:               void UART2PutHexWord(unsigned int toPrint) {
00982E  BE9F88     MOV.D W8, [W15++]
009830  780480     MOV W0, W9
434:                   unsigned int printVar;
435:               
436:                   printVar = (toPrint >> 12) & 0x0F;
437:                   UART2PutChar(CharacterArray[printVar]);
009832  DE004C     LSR W0, #12, W0
009834  29F328     MOV #0x9F32, W8
009836  7C4060     MOV.B [W0+W8], W0
009838  07FF2F     RCALL UART2PutChar
438:               
439:                   printVar = (toPrint >> 8) & 0x0F;
440:                   UART2PutChar(CharacterArray[printVar]);
00983A  DE4848     LSR W9, #8, W0
00983C  60006F     AND W0, #0xF, W0
00983E  7C4060     MOV.B [W0+W8], W0
009840  07FF2B     RCALL UART2PutChar
441:               
442:                   printVar = (toPrint >> 4) & 0x0F;
443:                   UART2PutChar(CharacterArray[printVar]);
009842  DE4844     LSR W9, #4, W0
009844  60006F     AND W0, #0xF, W0
009846  7C4060     MOV.B [W0+W8], W0
009848  07FF27     RCALL UART2PutChar
444:               
445:                   printVar = toPrint & 0x0F;
446:                   UART2PutChar(CharacterArray[printVar]);
00984A  64806F     AND W9, #0xF, W0
00984C  7C4060     MOV.B [W0+W8], W0
00984E  07FF24     RCALL UART2PutChar
447:               
448:                   return;
449:               }
009850  BE044F     MOV.D [--W15], W8
009852  060000     RETURN
450:               
451:               void UART2PutHexDWord(unsigned long toPrint) {
009854  BE9F88     MOV.D W8, [W15++]
009856  781F8A     MOV W10, [W15++]
009858  BE0400     MOV.D W0, W8
452:                   unsigned long printVar;
453:               
454:                   printVar = (toPrint >> 28) & 0x0F;
455:                   UART2PutChar(CharacterArray[printVar]);
00985A  DE084C     LSR W1, #12, W0
00985C  60006F     AND W0, #0xF, W0
00985E  29F32A     MOV #0x9F32, W10
009860  7D4060     MOV.B [W0+W10], W0
009862  07FF1A     RCALL UART2PutChar
456:               
457:                   printVar = (toPrint >> 24) & 0x0F;
458:                   UART2PutChar(CharacterArray[printVar]);
009864  DE4848     LSR W9, #8, W0
009866  200001     MOV #0x0, W1
009868  60006F     AND W0, #0xF, W0
00986A  7D4060     MOV.B [W0+W10], W0
00986C  07FF15     RCALL UART2PutChar
459:               
460:                   printVar = (toPrint >> 20) & 0x0F;
461:                   UART2PutChar(CharacterArray[printVar]);
00986E  DE4844     LSR W9, #4, W0
009870  200001     MOV #0x0, W1
009872  60006F     AND W0, #0xF, W0
009874  7D4060     MOV.B [W0+W10], W0
009876  07FF10     RCALL UART2PutChar
462:               
463:                   printVar = (toPrint >> 16) & 0x0F;
464:                   UART2PutChar(CharacterArray[printVar]);
009878  DE4840     LSR W9, #0, W0
00987A  200001     MOV #0x0, W1
00987C  60006F     AND W0, #0xF, W0
00987E  7D4060     MOV.B [W0+W10], W0
009880  07FF0B     RCALL UART2PutChar
465:               
466:                   printVar = (toPrint >> 12) & 0x0F;
467:                   UART2PutChar(CharacterArray[printVar]);
009882  DD4944     SL W9, #4, W2
009884  DE404C     LSR W8, #12, W0
009886  710000     IOR W2, W0, W0
009888  DE48CC     LSR W9, #12, W1
00988A  60006F     AND W0, #0xF, W0
00988C  7D4060     MOV.B [W0+W10], W0
00988E  07FF04     RCALL UART2PutChar
468:               
469:                   printVar = (toPrint >> 8) & 0x0F;
470:                   UART2PutChar(CharacterArray[printVar]);
009890  DD4948     SL W9, #8, W2
009892  DE4048     LSR W8, #8, W0
009894  710000     IOR W2, W0, W0
009896  DE48C8     LSR W9, #8, W1
009898  60006F     AND W0, #0xF, W0
00989A  7D4060     MOV.B [W0+W10], W0
00989C  07FEFD     RCALL UART2PutChar
471:               
472:                   printVar = (toPrint >> 4) & 0x0F;
473:                   UART2PutChar(CharacterArray[printVar]);
00989E  DD494C     SL W9, #12, W2
0098A0  DE4044     LSR W8, #4, W0
0098A2  710000     IOR W2, W0, W0
0098A4  DE48C4     LSR W9, #4, W1
0098A6  60006F     AND W0, #0xF, W0
0098A8  7D4060     MOV.B [W0+W10], W0
0098AA  07FEF6     RCALL UART2PutChar
474:               
475:                   printVar = toPrint & 0x0F;
476:                   UART2PutChar(CharacterArray[printVar]);
0098AC  64046F     AND W8, #0xF, W8
0098AE  7D4068     MOV.B [W8+W10], W0
0098B0  07FEF3     RCALL UART2PutChar
477:               
478:                   return;
479:               }
0098B2  78054F     MOV [--W15], W10
0098B4  BE044F     MOV.D [--W15], W8
0098B6  060000     RETURN
480:               
481:               #endif
482:               
483:               /*********************************************************************
484:               Function: char UART2Char2Hex(char ch)
485:               
486:               PreCondition: none
487:               
488:               Input: ASCII to be converted
489:               
490:               Output: number
491:               
492:               Side Effects: none
493:               
494:               Overview: converts ASCII coded digit into number
495:               
496:               Note: none
497:               
498:                ********************************************************************/
499:               char UART2Char2Hex(char ch) {
0098B8  784080     MOV.B W0, W1
500:                   // Wrong char
501:                   if (ch > 102)
0098BA  B3C660     MOV.B #0x66, W0
0098BC  50CF80     SUB.B W1, W0, [W15]
0098BE  3C001B     BRA GT, 0x98F6
502:                       return 0;
503:               
504:                   // From a to f
505:                   if (ch > 96)
0098C0  504066     SUB.B W0, #0x6, W0
0098C2  50CF80     SUB.B W1, W0, [W15]
0098C4  340004     BRA LE, 0x98CE
506:                       return (ch - 87);
0098C6  B3CA90     MOV.B #0xA9, W0
0098C8  40C000     ADD.B W1, W0, W0
0098CA  FB0000     SE W0, W0
0098CC  370015     BRA 0x98F8
507:               
508:                   // Wrong char
509:                   if (ch > 70)
0098CE  B3C460     MOV.B #0x46, W0
0098D0  50CF80     SUB.B W1, W0, [W15]
0098D2  3C0011     BRA GT, 0x98F6
510:                       return 0;
511:               
512:                   // From A to F
513:                   if (ch > 64)
0098D4  504066     SUB.B W0, #0x6, W0
0098D6  50CF80     SUB.B W1, W0, [W15]
0098D8  340004     BRA LE, 0x98E2
514:                       return (ch - 55);
0098DA  B3CC90     MOV.B #0xC9, W0
0098DC  40C000     ADD.B W1, W0, W0
0098DE  FB0000     SE W0, W0
0098E0  37000B     BRA 0x98F8
515:               
516:                   // Wrong char
517:                   if (ch > 57)
0098E2  B3C390     MOV.B #0x39, W0
0098E4  50CF80     SUB.B W1, W0, [W15]
0098E6  3C0007     BRA GT, 0x98F6
518:                       return 0;
519:               
520:                   // From 0 - 9
521:                   if (ch > 47)
0098E8  50406A     SUB.B W0, #0xA, W0
0098EA  50CF80     SUB.B W1, W0, [W15]
0098EC  340004     BRA LE, 0x98F6
522:                       return (ch - 48);
0098EE  B3CD00     MOV.B #0xD0, W0
0098F0  40C000     ADD.B W1, W0, W0
0098F2  FB0000     SE W0, W0
0098F4  370001     BRA 0x98F8
0098F6  EB0000     CLR W0
523:                   else
524:                       // Wrong char
525:                       return 0;
526:               }
0098F8  060000     RETURN
527:               
528:               /*********************************************************************
529:               Function: char UART2Hex2Char(char hex)
530:               
531:               PreCondition: none
532:               
533:               Input: number
534:               
535:               Output: ASCII code
536:               
537:               Side Effects: none
538:               
539:               Overview: converts low nibble into ASCII coded digit
540:               
541:               Note: none
542:               
543:                ********************************************************************/
544:               char UART2Hex2Char(char hex) {
545:                   char h;
546:                   h = hex & 0x0f;
0098FA  60406F     AND.B W0, #0xF, W0
547:                   // From 0xa to 0xf
548:                   if (h > 9)
0098FC  504FE9     SUB.B W0, #0x9, [W15]
0098FE  340003     BRA LE, 0x9906
549:                       return (h + 55);
009900  B04370     ADD.B #0x37, W0
009902  FB0000     SE W0, W0
009904  370002     BRA 0x990A
550:                   else
551:                       return (h + 48);
009906  B04300     ADD.B #0x30, W0
009908  FB0000     SE W0, W0
552:               }
00990A  060000     RETURN
553:               
554:               
555:               
556:               /*********************************************************************
557:               Function: void UART2ClrError(void)
558:               
559:               PreCondition: none
560:               
561:               Input: none
562:               
563:               Output: character received
564:               
565:               Side Effects: none
566:               
567:               Overview: wait for character
568:               
569:               Note: none
570:               
571:                ********************************************************************/
572:               void UART2ClrError(void) {
573:                   // Clear error flag
574:                   if (U2STAbits.OERR)
00990C  BFC232     MOV.B U2STA, WREG
00990E  A31800     BTST.Z W0, #1
009910  320001     BRA Z, 0x9914
575:                       U2STAbits.OERR = 0;
009912  A92232     BCLR U2STA, #1
576:               }
009914  060000     RETURN
577:               
---  /Users/cawilkie/dev/builds/build_20111027/src/pic30-libs/src/sbrk.c  -------------------------------
00047A  BE9F88     MOV.D W8, [W15++]
00047C  780480     MOV W0, W9
00047E  8079E0     MOV __curbrk, W0
000480  E00000     CP0 W0
000482  3A0003     BRA NZ, 0x48A
000484  070010     RCALL brk
000486  E00000     CP0 W0
000488  35000A     BRA LT, 0x49E
00048A  8079E0     MOV __curbrk, W0
00048C  E00009     CP0 W9
00048E  3A0002     BRA NZ, 0x494
000490  780400     MOV W0, W8
000492  370006     BRA 0x4A0
000494  780400     MOV W0, W8
000496  400009     ADD W0, W9, W0
000498  070006     RCALL brk
00049A  E00000     CP0 W0
00049C  3D0001     BRA GE, 0x4A0
00049E  EB8400     SETM W8
0004A0  780008     MOV W8, W0
0004A2  BE044F     MOV.D [--W15], W8
0004A4  060000     RETURN
---  /Users/cawilkie/dev/builds/build_20111027/src/pic30-libs/src/brk.c  --------------------------------
0004A6  780080     MOV W0, W1
0004A8  E00000     CP0 W0
0004AA  3A0004     BRA NZ, 0x4B4
0004AC  210100     MOV #0x1010, W0
0004AE  8879E0     MOV W0, __curbrk
0004B0  780101     MOV W1, W2
0004B2  370006     BRA 0x4C0
0004B4  EB8100     SETM W2
0004B6  237200     MOV #0x3720, W0
0004B8  508F80     SUB W1, W0, [W15]
0004BA  3E0002     BRA GTU, 0x4C0
0004BC  8879E1     MOV W1, __curbrk
0004BE  EB0100     CLR W2
0004C0  780002     MOV W2, W0
0004C2  060000     RETURN
